<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: algorithm | Hujiawei Bujidao]]></title>
  <link href="http://hujiaweibujidao.github.io/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://hujiaweibujidao.github.io/"/>
  <updated>2014-05-08T09:40:47+08:00</updated>
  <id>http://hujiaweibujidao.github.io/</id>
  <author>
    <name><![CDATA[hujiawei]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Python Algorithms - Sort]]></title>
    <link href="http://hujiaweibujidao.github.io/blog/2014/05/07/python-algorithms-sort/"/>
    <updated>2014-05-07T22:00:00+08:00</updated>
    <id>http://hujiaweibujidao.github.io/blog/2014/05/07/python-algorithms-sort</id>
    <content type="html"><![CDATA[<p>参考内容：</p>

<p>1.<a href="http://interactivepython.org/courselib/static/pythonds/index.html">Problem Solving with Python</a>
Chapter5: Search and Sorting <a href="http://interactivepython.org/courselib/static/pythonds/SortSearch/sorting.html">online_link</a></p>

<p>2.<a href="http://en.wikipedia.org/wiki/Introduction_to_Algorithms">算法导论</a></p>

<h4 id="section">排序总结</h4>

<p>1.冒泡排序(bubble sort)：每个回合都从第一个元素开始和它后面的元素比较，如果比它后面的元素更大的话就交换，一直重复，直到这个元素到了它能到达的位置。注意检测是否已经完成了排序，如果已完成就可以退出了。时间复杂度$O(n^2)$</p>

<p><strong>Python支持对两个数字同时进行交换！<code>a,b = b,a</code>就可以交换a和b的值了。</strong></p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/bubblesort.png" alt="image" /></p>

<p>```python
def short_bubble_sort(a_list):
    exchanges = True
    pass_num = len(a_list) - 1
    while pass_num &gt; 0 and exchanges:
        exchanges = False
        for i in range(pass_num):
            if a_list[i] &gt; a_list[i + 1]:
                exchanges = True
                # temp = a_list[i]
                # a_list[i] = a_list[i + 1]
                # a_list[i + 1] = temp
                a_list[i],a_list[i+1] = a_list[i+1], a_list[i]
        pass_num = pass_num - 1</p>

<p>if <strong>name</strong> == ‘<strong>main</strong>’:
    a_list=[20, 40, 30, 90, 50, 80, 70, 60, 110, 100]
    short_bubble_sort(a_list)
    print(a_list)
```</p>

<p>2.选择排序(selection sort)：每个回合都选择出剩下的元素中最大的那个，选择的方法是首先默认第一元素是最大的，如果后面的元素比它大的话，那就更新剩下的最大的元素值，找到剩下元素中最大的之后将它放入到合适的位置就行了。时间复杂度$O(n^2)$</p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/selectionsort.png" alt="image" /></p>

<p>```
def selection_sort(a_list):
    for fill_slot in range(len(a_list) - 1, 0, -1):
        pos_of_max = 0
        for location in range(1, fill_slot + 1):
            if a_list[location] &gt; a_list[pos_of_max]:
                pos_of_max = location
        # temp = a_list[fill_slot]
        # a_list[fill_slot] = a_list[pos_of_max]
        # a_list[pos_of_max] = temp
        a_list[fill_slot],a_list[pos_of_max]=a_list[pos_of_max],a_list[fill_slot]</p>

<p>a_list = [54, 26, 93, 17, 77, 31, 44, 55, 20]
selection_sort(a_list)
print(a_list)
```</p>

<p>3.插入排序(insertion sort)：每次假设前面的元素都是已经排好序了的，然后将当前位置的元素插入到原来的序列中，为了尽快地查找合适的插入位置，可以使用二分查找。时间复杂度$O(n^2)$，别误以为二分查找可以降低它的复杂度，因为插入排序还需要移动元素的操作！</p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/insertionsort.png" alt="image" /></p>

<p>```python
def insertion_sort(a_list):
    for index in range(1, len(a_list)):
        current_value = a_list[index]
        position = index
        while position &gt; 0 and a_list[position - 1] &gt; current_value:
            a_list[position] = a_list[position - 1]
            position = position - 1
        a_list[position] = current_value</p>

<p>def insertion_sort_binarysearch(a_list):
    for index in range(1, len(a_list)):
        current_value = a_list[index]
        position = index
        low=0
        high=index-1
        while low&lt;=high:
            mid=(low+high)/2
            if a_list[mid]&gt;current_value:
                high=mid-1
            else:
                low=mid+1
        while position &gt; low:
            a_list[position] = a_list[position - 1]
        a_list[position] = current_value</p>

<p>a_list = [54, 26, 93, 15, 77, 31, 44, 55, 20]
insertion_sort(a_list)
print(a_list)
insertion_sort_binarysearch(a_list)
print(a_list)
```</p>

<p>4.合并排序(merge sort)：典型的是二路合并排序，将原始数据集分成两部分(不一定能够均分)，分别对它们进行排序，然后将排序后的子数据集进行合并，这是典型的分治法策略。时间复杂度$O(nlogn)$</p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/mergesort.png" alt="image" /></p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/mergesort2.png" alt="image" /></p>

<p>```python
def merge_sort(a_list):
    print(“Splitting “, a_list)
    if len(a_list) &gt; 1:
        mid = len(a_list) // 2
        left_half = a_list[:mid]
        right_half = a_list[mid:]
        merge_sort(left_half)
        merge_sort(right_half)
        i=0;j=0;k=0;
        while i &lt; len(left_half) and j &lt; len(right_half):
            if left_half[i] &lt; right_half[j]:
                a_list[k] = left_half[i]
                i=i+1
            else:
                a_list[k] = right_half[j]
                j=j+1
            k=k+1
        while i &lt; len(left_half):
            a_list[k] = left_half[i]
            i=i+1
            k=k+1
        while j &lt; len(right_half):
            a_list[k] = right_half[j]
            j=j+1
            k=k+1
    print(“Merging “, a_list)</p>

<p>a_list = [54, 26, 93, 17, 77, 31, 44, 55, 20]
merge_sort(a_list)
print(a_list)
```</p>

<p>算法导论2-4题利用合并排序可以在$O(nlogn)$的最坏情况下得到包含n个元素的数组的逆序对的数目。[下面使用的是C++来实现的，合并排序的代码格式类似算法导论]</p>

<p>```cpp
#include <iostream>
using namespace std;</iostream></p>

<p>int calculateInversions(int arr[], int p, int r);
int mergeInversions(int arr[], int p, int q, int r);</p>

<p>int main(int argc, const char * argv[])
{
    int arr[] = {2,3,8,6,1};
    int count = calculateInversions(arr, 0, 4);
    cout « “count inversions : “ « count « endl;
    return 0;
}</p>

<p>int calculateInversions(int arr[], int p, int r) {
	int count=0;
	if(p &lt; r) {
		int q = (p + r) / 2;
        count += calculateInversions(arr, p, q);
        count += calculateInversions(arr, q+1, r);
        count += mergeInversions(arr, p, q, r);
	}
	return count;
}</p>

<p>int mergeInversions(int arr[], int p, int q, int r){
    int count=0;
    int n1=q-p+1, n2=r-q;
    int left[n1+1], right[n2+1];
    for (int i=0; i&lt;n1; i++) {
        left[i]=arr[p+i];
    }
    for (int j=0; j&lt;n2; j++) {
        right[j]=arr[q+1+j];
    }
    left[n1]=INT32_MAX;
    right[n2]=INT32_MAX;
    int i=0, j=0;
    for (int k=p; k&lt;=r; k++) {
        if (left[i]&lt;=right[j]) {
            arr[k]=left[i];
            i++;
        }else{
            arr[k]=right[j];
            count += n1-i;
            j++;
        }
    }
    return count;
}
```</p>

<p>5.快速排序(quick sort)：</p>

<p>想法一：如下图所示，它选择第一个元素作为主元，它同样可以按照下面提到的算法导论中将数组分成了4个不同的部分，但是这里其实有更好的解释方法。<strong>首先，它每次都是选择第一个元素都为主元，这个回合就是要确定主元的位置；然后，有两个指针，一个leftmark指向主元的后面一个位置，另一个rightmark指向要排序的数组最后一个元素；接着，两个指针分别向中间移动，leftmark遇到比主元大的元素停止，rightmark遇到比主元小的元素停止，如果此时leftmark&lt;rightmark，也就是说中间还有未处理(未确定与主元大小关系)的元素，那么就交换leftmark和rightmark位置上的元素，然后重复刚才的移动操作，直到rightmark&lt;leftmark；最后，停止移动时候rightmark就是主元要放置的位置，因为它停在一个比主元小的元素的位置上，之后交换主元和rightmark指向的元素即可。完了之后，递归地对主元左右两边的数组进行排序即可。</strong></p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/quicksort.png" alt="image" /></p>

<p>```python
def quick_sort(a_list):
    quick_sort_helper(a_list, 0, len(a_list) - 1)</p>

<p>def quick_sort_helper(a_list, first, last):
    if first &lt; last:
        split_point = partition(a_list, first, last)
        quick_sort_helper(a_list, first, split_point - 1)
        quick_sort_helper(a_list, split_point + 1, last)</p>

<p>def partition(a_list, first, last):
    pivot_value = a_list[first]
    left_mark = first + 1
    right_mark = last
    done = False
    while not done:
        while left_mark &lt;= right_mark and a_list[left_mark] &lt;= pivot_value:
            left_mark = left_mark + 1
        while a_list[right_mark] &gt;= pivot_value and right_mark &gt;= left_mark:
            right_mark = right_mark - 1
        if right_mark &lt; left_mark:
            done = True
        else:
            temp = a_list[left_mark]
            a_list[left_mark] = a_list[right_mark]
            a_list[right_mark] = temp
    temp = a_list[first]
    a_list[first] = a_list[right_mark]
    a_list[right_mark] = temp
    return right_mark</p>

<p>a_list = [54, 26, 93, 17, 77, 31, 44, 55, 20]
quick_sort(a_list)
print(a_list)
```</p>

<p>想法二：如下图所示，它选择最后的那个元素作为主元，它的思路是将数组划分成4部分：</p>

<p>第一部分：$p \le k \le i, A[k] \le pivot$</p>

<p>第二部分：$i+1 \le k \le j-1, A[k] \gt pivot$</p>

<p>第三部分：$j \le k \le r-1, A[k]$可以取任何值(因为它们还没有进行处理)。</p>

<p>第四部分：$p \le k \le i, A[k] = pivot$</p>

<p><strong>首先，让i指向要排序的数组的第一个元素的前面，p和j都指向第一个元素；然后，一直移动j直到主元前一个位置，一旦发现一个大于主元的元素就让i指向它的下一个位置，然后交换i和j对应位置上的元素。这样一定是可行的，因为i一直都是指向已发现的小于主元的元素中的最后一个，从i+1开始就大于主元了(或者还未确定/未处理)，而j一直都是指向大于主元的元素中最后一个的后面一个位置，所以i+1和j位置上的元素交换就可以使得j发现的这个小于主元的元素移动到第一部分，而i+1位置上大于主元的元素移动到j的位置上，即第二部分的最后一个位置上。</strong></p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/quicksort_cn.png" alt="image" /></p>

<p>根据算法导论中的伪代码的C++版本实现</p>

<p>```cpp
#include <iostream>
using namespace std;</iostream></p>

<p>// partition, locate the pivot value in properate position
int partition(int a[], int low, int high){
    int key = a[high];//pivot
    int i=low-1, temp;
    for (int j=low; j&lt;high; j++) {
        if (a[j]&lt;key) {
            i++;
            temp = a[j];
            a[j]=a[i];
            a[i]=temp;
        }
    }
    temp = a[high];
    a[high] = a[i+1];
    a[i+1] = temp;//i+1 is the split point
    return i+1;
}</p>

<p>// quick sort
void quicksort(int a[], int low, int high) {
    if (low &lt; high) {
        int p = partition(a,low,high);
        quicksort(a, low, p-1);
        quicksort(a, p+1, high);
    }
}</p>

<p>// print array
void print(int a[],int len){
    for (int i=0; i&lt;len; i++) {
        cout « a[i] « ” ”;
    }
    cout « endl;
}</p>

<p>int main(int argc, const char * argv[])
{
    int a[]={3,5,2,7,9,10,33,28,19,6,8};
    quicksort(a, 0, 10);
    print(a,11);
}
```</p>

<p>由于快排每次都能够确定一个元素在数组中最终的位置，所以可以用快排来解决很多变种问题，例如在线性时间内求中位数问题。</p>

<p>6.希尔排序：类似合并排序和插入排序的结合体，二路合并排序将原来的数组分成左右两部分，希尔排序则将数组按照一定的间隔分成几部分，每部分采用插入排序来排序，有意思的是这样做了之后，元素很多情况下就差不多在它应该呆的位置，所以效率不一定比插入排序差。时间复杂度为$[O(n),O(n^2)]$。</p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/shellsort.png" alt="image" /></p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/shellsort2.png" alt="image" /></p>

<p>```python
def shell_sort(a_list):
    #how many sublists, also how many elements in a sublist
    sublist_count = len(a_list) // 2
    while sublist_count &gt; 0:
        for start_position in range(sublist_count):
            gap_insertion_sort(a_list, start_position, sublist_count)
        print(“After increments of size”, sublist_count, “The list is”, a_list)
        sublist_count = sublist_count // 2</p>

<p>def gap_insertion_sort(a_list, start, gap):
    #start+gap is the second element in this sublist
    for i in range(start + gap, len(a_list), gap):
        current_value = a_list[i]
        position = i
        while position &gt;= gap and a_list[position - gap] &gt; current_value:
            a_list[position] = a_list[position - gap] #move backward
            position = position - gap
            a_list[position] = current_value</p>

<p>a_list = [54, 26, 93, 17, 77, 31, 44, 55, 20, 88]
shell_sort(a_list)
print(a_list)
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Algorithms - Search]]></title>
    <link href="http://hujiaweibujidao.github.io/blog/2014/05/07/python-algorithms-search/"/>
    <updated>2014-05-07T16:00:00+08:00</updated>
    <id>http://hujiaweibujidao.github.io/blog/2014/05/07/python-algorithms-search</id>
    <content type="html"><![CDATA[<p>参考内容：</p>

<p>1.<a href="http://interactivepython.org/courselib/static/pythonds/index.html">Problem Solving with Python</a>
Chapter5: Search and Sorting <a href="http://interactivepython.org/courselib/static/pythonds/SortSearch/searching.html#searching">online_link</a></p>

<p>2.<a href="http://en.wikipedia.org/wiki/Introduction_to_Algorithms">算法导论</a></p>

<h4 id="section">搜索总结</h4>

<p>(1)顺序查找：O(n)</p>

<p>(2)二分查找：O(lgn)</p>

<p>(3)Hash查找：O(1)</p>

<p>概念：hash，hash table，hash function <a href="http://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8#.E5.A4.84.E7.90.86.E7.A2.B0.E6.92.9E">哈希表_on_wiki</a></p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/hashbasics.png" alt="image" />  </p>

<p>常用的哈希函数：</p>

<p>1.reminder method：取余数（size=11）</p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/reminder.png" alt="image" /></p>

<p>2.folding method</p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/folding.png" alt="image" /></p>

<p>3.mid-square method</p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/mid-square.png" alt="image" /></p>

<p>4.对于由字符的元素可以尝试使用<code>ord</code>函数来将字符串转换成一个有序的数值序列。</p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/stringord1.png" alt="image" /></p>

<p>但是，对于通过回文构词法构成的字符串它们得到的值总是一样，为了解决这个问题，可以根据字符的位置添加一个权重。</p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/stringord2.png" alt="image" /></p>

<p>From wiki</p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/hashfun.png" alt="image" />   </p>

<p>使用哈希查找，难免遇到冲突，该如何解决冲突(Collision Resolution)呢？</p>

<p>常用的解决冲突的办法：</p>

<p>1.open address(开放寻址)：线性探测(linear probing)下一个位置，缺点是容易造成聚集现象(cluster)，解决聚集现象的办法是跳跃式地查找下一个空槽。数值的顺序：(54, 26, 93, 17, 77, 31, 44, 55, 20).</p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/linearprob.png" alt="image" /></p>

<p>2.quadratic probing(平方探测)：一开始的hash值为h，如果不是空槽，那就尝试h+1，还不是空槽就尝试h+4，依次继续尝试h+9，h+16等等。</p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/quadraticprob.png" alt="image" /></p>

<p>3.chain：利用链表链接起来</p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/chain.png" alt="image" /></p>

<p>From wiki</p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/hashcollision.png" alt="image" />   </p>

<p>分析hash查找的性能：一般使用平均查找长度来衡量，和装载因子有关</p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/hashanalysis.png" alt="image" /></p>

<p>From wiki</p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/hashefficiency.png" alt="image" />   </p>

<p>下面的代码包含了顺序查找，二分查找，哈希查找(size=11, plus 1, reminder method)</p>

<p>```python
def sequential_search(a_list, item):
    pos = 0
    found = False
    while pos &lt; len(a_list) and not found:
        if a_list[pos] == item:
            found = True
        else:
            pos = pos+1
    return found</p>

<p>test_list = [1, 2, 32, 8, 17, 19, 42, 13, 0]
print(sequential_search(test_list, 3))
print(sequential_search(test_list, 13))</p>

<p>def binary_search(a_list, item):
    first = 0
    last = len(a_list) - 1
    found = False
    while first &lt;= last and not found:
        midpoint = (first + last) // 2
        if a_list[midpoint] == item:
            found = True
        else:
            if item &lt; a_list[midpoint]:
                last = midpoint - 1
            else:
                first = midpoint + 1
    return found</p>

<p>test_list = [0, 1, 2, 8, 13, 17, 19, 32, 42,]
print(binary_search(test_list, 3))
print(binary_search(test_list, 13))</p>

<p>class HashTable:
    def <strong>init</strong>(self):
        self.size = 11
        self.slots = [None] * self.size
        self.data = [None] * self.size</p>

<pre><code>#put data in slot
def put_data_in_slot(self,key,data,slot):
    if self.slots[slot] == None: # '==None' ? or  'is None' ?
        self.slots[slot] = key
        self.data[slot] = data
        return True
    else:
        if self.slots[slot] == key: # not None
            self.data[slot] = data #replace
            return True
        else:
            return False

def put(self, key, data):
    slot = self.hash_function(key, self.size);
    result = self.put_data_in_slot(key,data,slot);
    while not result:
        slot = self.rehash(slot, self.size);
        result=self.put_data_in_slot(key,data,slot);

#reminder method
def hash_function(self, key, size):
    return key % size

#plus 1
def rehash(self, old_hash, size):
    return (old_hash + 1) % size

def get(self, key):
    start_slot = self.hash_function(key, len(self.slots))
    data = None
    stop = False
    found = False
    position = start_slot
    while self.slots[position] != None and not found and not stop:
        if self.slots[position] == key:
            found = True
            data = self.data[position]
        else:
            position=self.rehash(position, len(self.slots))
            if position == start_slot:
                stop = True
    return data

def __getitem__(self, key):
    return self.get(key)

def __setitem__(self, key, data):
    self.put(key, data)
</code></pre>

<p>if <strong>name</strong> == ‘<strong>main</strong>’:
    table=HashTable();
    table[54]=’cat’;
    table[26]=’dog’;
    table[93]=’lion’;
    table[17]=”tiger”;
    table[77]=”bird”;
    table[44]=”goat”;
    table[55]=”pig”;
    table[20]=”chicken”;
    print table.slots;
    print table.data;</p>

<h1 id="none-26-93-17-none-none-20-54">[77, 44, 55, None, 26, 93, 17, None, None, 20, 54]</h1>
<p># [‘bird’, ‘goat’, ‘pig’, None, ‘dog’, ‘lion’, ‘tiger’, None, None, ‘chicken’, ‘cat’]
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vertext Cover Problem]]></title>
    <link href="http://hujiaweibujidao.github.io/blog/2014/04/13/vertext-cover-problem/"/>
    <updated>2014-04-13T23:57:00+08:00</updated>
    <id>http://hujiaweibujidao.github.io/blog/2014/04/13/vertext-cover-problem</id>
    <content type="html"><![CDATA[<h4 id="section">1.问题描述</h4>

<p>给定一个N个点M条边的无向图G（点的编号从1至N），问是否存在一个不超过K个点的集合S，使得G中的每条边都至少有一个点在集合S中。</p>

<p>例如，如下图所示的无向图G（报告中算法分析过程中一直使用下面的图G）  </p>

<p>(1)如果选择包含点1,2,6这3个点的集合S不能满足条件，因为边(3,7)两个端点都不在S中。</p>

<p><img src="/images/201404/exp1-3.png" alt="image" /></p>

<p>(2)如果选择包含点1,2,6,7这4个点的集合S虽然满足条件，但是它使用了4个点，其实可以使用更少的点，如下面(3)所示</p>

<p><img src="/images/201404/exp1-2.png" alt="image" /></p>

<p>(3)如果选择包含点1,3,5这3个点的集合S便满足条件，使得G中的每条边都至少有一个点在集合S中。</p>

<p><img src="/images/201404/exp1-1.png" alt="image" /></p>

<h4 id="section-1">2.解题思路</h4>

<p>我的解题思路基于分支定界和贪心两个策略，用一个优先队列维护当前可行的节点，每个节点维护着该节点情况下还可以选择的顶点数目k、需要覆盖的剩余边数e、顶点的状态state、顶点的边数edge等信息，这些节点的排序遵循下面的贪心策略，节点的扩展遵循下面的分支定界策略。总体思路是：</p>

<p>①将原图数据构造成一个解空间树的节点，利用定界策略判断是否有解，如果无解直接退出，如果有可能有解则插入到优先队列中；</p>

<p>②若优先队列不为空，那么便从优先队列中取出第一个可行的节点，进入步骤③，如果优先队列为空则退出；</p>

<p>③判断当前节点是否满足解的条件，如果满足便输出解退出，如果不满足便进入步骤④；</p>

<p>④检查当前节点是否可以扩展，不能扩展的话便进入②继续循环，如果能扩展的话则扩展，然后验证扩展到左右节点是否有解，将有解的扩展节点插入到优先队列中，然后进入②继续循环。</p>

<p>下面分别介绍下分支定界和贪心这两个策略：</p>

<h5 id="section-2">(1)分支定界策略</h5>

<p>首先，界的选择。在一个确定的无向图G中，每个顶点的边即确定了，那么对于该无向图中k个顶点能够覆盖的最多的边数e也就可以确定了！只要对顶点按照边的数目降序排列，然后选择前k个顶点，将它们的边数相加即能得到一个边数上界！因为这k个顶点相互之间可能有边存在也可能没有，所以这是个上界，而且有可能达到。以图G为例，各个顶点的边数统计，并采用降序排列的结果如下：</p>

<!--顶点 | 2 | 3 | 1| 5 | 6| 4| 7 
--| --| --|--|--|--|--|--
边数 | 3 | 3 | 2| 2| 2| 1| 1-->
<!--
顶点 | 边数
----| ---- 
2 | 3 
3 | 3
1 | 2 
5 | 2
6 | 2
4 | 1
7 | 1-->

<p><img src="/images/201404/exp1-f3.png" alt="image" /></p>

<p>假设取k=3个点，那么有Up(e)=(3+3+2)=8 &gt; 7 条边（7为图G的总边数），也就是说，如果从图G中取3个点，要覆盖8条边是有可能的。但是，如果取k=2个点，那么有Up(e)=(3+3)=6 &lt; 7 条边，说明从图G中取2个点，是不可能覆盖G中的全部7条边的！基于这个上界，可以在分支树中扩展出来的节点进行验证，已知它还可以选择的顶点数目以及还需要覆盖的边的条数，加上顶点的状态（下面会分析说明）即可判断当前节点是否存在解！如果不存在即可进行剪枝了。</p>

<p>其次，顶点的状态。该策略中顶点有三种状态，分别为已经选择了的状态S1，不选择的状态S2，可以选择的状态S3。其中，不选择的状态S2对应解空间树中的右节点，不选择该节点，然后设置该节点为不选择状态S2。这点很重要，因为有了这个状态，可以使得上界的判断更为精确，因为只能从剩余顶点集中选择那些状态S3的顶点，状态S1和S2都不行，那么上界便会更小，也就更加精确，从而利于剪枝！</p>

<h5 id="section-3">(2)贪心策略</h5>

<p>贪心的策略是指可行的结点都是按照还需要覆盖的剩余边数的降序排列，即，每次选择的节点都是可行节点中还需要覆盖的边数最小的那个节点，因为它最接近结果了。</p>

<h5 id="section-4">(3)例子分析</h5>

<p>以图G为例，此时e=7（要覆盖的边数），取k=3，图G用邻接矩阵保存为全局数据，计算每个顶点的边数，然后降序排列。</p>

<p>步骤①判断是否可能有解，Up(e)=3+3+2=8&gt;7，可能有解，那么将图G构造成一个解空间树的节点，它包含了还能选择的点数k=3，还需要覆盖的边数e=7，每个顶点的边数以及按边数大小的降序排列（上表），每个顶点的状态（初始时都是可选择的状态S3）。然后，将该节点插入到优先队列中，该优先队列是用最小堆实现的，按照前面的贪心策略对队列中的节点进行降序排列。</p>

<p>步骤②取出了优先队列中的根节点，很显然，还需要覆盖的边数为7，不为0，所以还不满足条件。接下来要检查是否能够进行扩展，从顶点集合中选择状态为可以选择的顶点中边数最多的点，该点存在为顶点2，接着进行扩展，扩展左节点时将还能选择的点数k-1=2，然后计算选择了该点之后删除了几条未覆盖的边，得到还需要覆盖的边数e=4，然后更新所有其他顶点的边数，并重新排序，最后将顶点2的状态设置为已经选择了；扩展右节点时，只要将顶点2的状态设置为不能选择，还能选择的点数k(=3)，还需要覆盖的边数e(=7)保持不变。扩展完了之后，同样判断左右节点是否可能有解，如果有解，将该节点插入到优先队列中。这里左右节点都有解，那么将左右节点都插入到优先队列中，因为左节点还需要覆盖的边数e=4小于右节点的e=7，所以根据贪心策略，左节点在右节点的前面。上面两个步骤的图示如下，其中标明了顶点状态颜色。</p>

<p><img src="/images/201404/exp1-f1.png" alt="image" /></p>

<p>算法然后继续进入步骤②，此时取出的是节点是刚才插入的左节点，很显然，还需要覆盖的边数为4，不为0，所以还不满足条件。接下来要检查是否能够进行扩展，从顶点集合中选择状态为可以选择的顶点中边数最多的点，该点存在为顶点3，接着进行扩展，扩展左节点时将还能选择的点数k-1=1，然后计算选择了该点之后删除了几条未覆盖的边，得到还需要覆盖的边数e=2，然后更新所有其他顶点的边数，并重新排序，最后将顶点3的状态设置为已经选择了；扩展右节点时，只要将顶点3的状态设置为不能选择，还能选择的点数k(=3)，还需要覆盖的边数e(=7)保持不变。扩展完了之后，同样判断左右节点是否可能有解，如果有解，将该节点插入到优先队列中。这里左右节点都不可能有解，那么直接进入步骤②继续循环。上面这一步的图示如下：</p>

<p><img src="/images/201404/exp1-f2.png" alt="image" /></p>

<p>算法按照上面的方式不断进行，最后满足条件的分支的过程是：</p>

<p>①不选择顶点2；②选择顶点3；③选择顶点1；④选择顶点5。</p>

<p>最后得到的满足条件的解是选择顶点1,3,5。</p>

<h4 id="section-5">(4)复杂度分析</h4>

<p>该算法优先队列使用的是最小堆实现的(O(nlgn))，对顶点按照边排序使用的是快速排序算法(O(nlgn))，解空间树的深度最多为顶点数目n，每层都要进行分支定界，所以每层的时间复杂度为O(nlgn)，所以算法总的时间复杂度为O(n^2 lgn)。但是，为了实现分支定界，每个节点保存的信息量较多，空间复杂度较大。(有木有分析错了，我不太会分析复杂度)</p>

<p>OJ系统的结果为：时间 156ms  空间 1.0MB</p>

]]></content>
  </entry>
  
</feed>
