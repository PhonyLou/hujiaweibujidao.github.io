<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: algorithm | Hujiawei Bujidao]]></title>
  <link href="http://hujiaweibujidao.github.io/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://hujiaweibujidao.github.io/"/>
  <updated>2014-05-17T20:25:40+08:00</updated>
  <id>http://hujiaweibujidao.github.io/</id>
  <author>
    <name><![CDATA[hujiawei]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Algorithms-PageRank]]></title>
    <link href="http://hujiaweibujidao.github.io/blog/2014/05/12/algorithms-pagerank/"/>
    <updated>2014-05-12T18:12:00+08:00</updated>
    <id>http://hujiaweibujidao.github.io/blog/2014/05/12/algorithms-pagerank</id>
    <content type="html"><![CDATA[<p>PageRank算法</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ML/DM/PR算法系列]]></title>
    <link href="http://hujiaweibujidao.github.io/blog/2014/05/12/Algorithms/"/>
    <updated>2014-05-12T11:00:00+08:00</updated>
    <id>http://hujiaweibujidao.github.io/blog/2014/05/12/Algorithms</id>
    <content type="html"><![CDATA[<p>战线拉得有点长，囫囵吞枣地看了写书写了些代码，时间久了可能就会忘了当时怎么想的，所以，总结是很有必要的一个过程，重新捋一捋思路，重新写写代码，势必对自己的知识储备有很大的好处，不求一语惊人，只求若有所获。</p>

<p>故有了此系列，主要记录些在数据挖掘、机器学习、模式识别等领域的相关算法，算法不求全，但求质量佳，肯定会附上实现的源码，可能是Matlab版本的，也可能是Java或者Python版本的，如果我比较熟悉的算法会结合一个实际的案例进行分析。</p>

<p>嗯，就唠叨这些，慢慢来，持续添加各个算法，需要的敬请期待。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Algorithms - Graphs]]></title>
    <link href="http://hujiaweibujidao.github.io/blog/2014/05/08/python-algorithms-Graphs/"/>
    <updated>2014-05-08T22:00:00+08:00</updated>
    <id>http://hujiaweibujidao.github.io/blog/2014/05/08/python-algorithms-Graphs</id>
    <content type="html"><![CDATA[<p>参考内容：</p>

<p>1.<a href="http://interactivepython.org/courselib/static/pythonds/index.html">Problem Solving with Python</a></p>

<p>Chapter 7 Graphs</p>

<p>2.<a href="http://link.springer.com/book/10.1007%2F978-1-4302-3238-4">Python Algorithms: Mastering Basic Algorithms in the Python Language</a></p>

<p>Matchings, Cuts, and Flows</p>

<p>3.<a href="http://en.wikipedia.org/wiki/Introduction_to_Algorithms">算法导论</a></p>

<h4 id="section">图的总结</h4>

<p>Todo List</p>

<p>1.邻接矩阵和邻接表</p>

<p>2.DFS和BFS</p>

<p>3.DFS的应用：拓扑排序和有向无环图的强连通分量</p>

<p>4.最短路径：Dijkstra，Bellman-Ford，Floyd-Warshall等</p>

<p>5.最小生成树：Prim，Kruskal</p>

<p>6.网络流：最大流，最小割，二分图等</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Algorithms - Trees]]></title>
    <link href="http://hujiaweibujidao.github.io/blog/2014/05/08/python-algorithms-Trees/"/>
    <updated>2014-05-08T20:00:00+08:00</updated>
    <id>http://hujiaweibujidao.github.io/blog/2014/05/08/python-algorithms-Trees</id>
    <content type="html"><![CDATA[<p>参考内容：</p>

<p>1.<a href="http://interactivepython.org/courselib/static/pythonds/index.html">Problem Solving with Python</a></p>

<p>Chapter 6 Trees and Tree Algorithms   </p>

<p>2.<a href="http://en.wikipedia.org/wiki/Introduction_to_Algorithms">算法导论</a></p>

<h4 id="section">树的总结</h4>

<p>1.二叉搜索树 <a href="http://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9">on_wiki</a>：一种特殊的二叉树，它满足下面的性质：任何一个节点的key值都比它左子树上的节点的key值要大，但是比它右子树上的节点的key值要小。节点查找，插入，删除等操作的时间复杂度都是$O(n)$</p>

<p>难点在于删除节点的操作(下面摘自wiki)：</p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/bst_del_wiki.png" alt="image" /></p>

<p><strong>引用开始</strong> [一份不错的讲解<a href="http://www.cnblogs.com/Anker/archive/2013/01/28/2880581.html">来自博客园</a>]</p>

<hr />

<p>1.在二叉查找树中找某个节点的前驱和后继节点</p>

<p>给定一个二叉查找树中的结点，找出在中序遍历顺序下某个节点的前驱和后继。如果树中所有关键字都不相同，则某一结点x的前驱就是小于key[x]的所有关键字中最大的那个结点，后继即是大于key[x]中的所有关键字中最小的那个结点。根据二叉查找树的结构和性质，不用对关键字做任何比较，就可以找到某个结点的前驱和后继。</p>

<p>查找前驱步骤：先判断x是否有左子树，如果有则在left[x]中查找关键字最大的结点，即是x的前驱。如果没有左子树，则从x继续向上执行此操作，直到遇到某个结点是其父节点的右孩子结点，<strong>此时该父节点就是前驱</strong>。例如下图查找结点7的前驱结点6过程：</p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/bst_pre.png" alt="image" /></p>

<p>伪代码</p>

<p><code>cpp
TREE_SUCCESSOR(x)
    if right[x] != NULL
        then return TREE_MINMUM(right(x))
    y=parent[x]
    while y!= NULL and x ==left[y]
           do x = y
              y=parent[y]
    return y
</code></p>

<p>查找后继步骤：先判断x是否有右子树，如果有则在right[x]中查找关键字最小的结点，即使x的后继。如果没有右子树，则从x的父节点开始向上查找，直到遇到某个结点是其父结点的左儿子的结点时为止，<strong>此时该父节点就是后继</strong>。例如下图查找结点13的后继结点15的过程：</p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/bst_later.png" alt="image" /></p>

<p>伪代码</p>

<p><code>cpp
TREE_PROCESSOR(x)
    if right[x] != NULL
        then return TREE_MINMUM(right(x))
    y=parent[x]
    while y!= NULL and x ==right[y]
           do x = y
              y=parent[y]
    return y
</code></p>

<p>2.删除节点操作</p>

<p>(1)结点z没有左右子树，则修改其父节点p[z]，<strong>删除父节点对它的链接</strong>。</p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/bst_del1.png" alt="image" /></p>

<p>(2)如果结点z只有一个子树（左子树或者右子树），通过在其子结点与父节点建立一条链接来删除z。</p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/bst_del2.png" alt="image" /></p>

<p>(3)如果z有两个子女，则先删除z的后继y(y没有左孩子)，再用y的内容来替代z的内容。</p>

<p><strong>[博主提示：这里找到z的后继就是利用上面的查找后继的方法，根据wiki也可以是用z的前驱来替换。另外，删除后继和替换内容的操作其实也可以反过来，保证数据不丢失就行了]</strong></p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/bst_del3.png" alt="image" /></p>

<hr />

<p><strong>引用结束</strong></p>

<p><a href="http://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9">wiki</a>上的python代码实现节点删除操作，比后面的python代码更加简洁易懂</p>

<p>代码采用了递归的形式处理，相当于只需要考虑了要删除的节点就在当前位置该如何处理，然后，对于只有左孩子节点或者只有右孩子结点或者没有孩子节点的情况直接进行节点覆盖就行了，但是，对于复杂的第三种情况，在左右孩子节点都存在的情况下，只需从它的右孩子结点中找到最小的那个元素即为要删除节点的后继(同理，可以找到左孩子结点中找到最大的那个元素，即为要删除节点的前驱)，然后复制后继节点中的内容到要删除的节点，最后删除后继节点即可。</p>

<p>```python
def find_min(self):   # Gets minimum node (leftmost leaf) in a subtree
    current_node = self
    while current_node.left_child:
        current_node = current_node.left_child
    return current_node</p>

<p>def replace_node_in_parent(self, new_value=None):
    if self.parent:
        if self == self.parent.left_child:
            self.parent.left_child = new_value
        else:
            self.parent.right_child = new_value
    if new_value:
        new_value.parent = self.parent</p>

<p>def binary_tree_delete(self, key):
    if key &lt; self.key:
        self.left_child.binary_tree_delete(key)
    elif key &gt; self.key:
        self.right_child.binary_tree_delete(key)
    else: # delete the key here
        if self.left_child and self.right_child: # if both children are present
            successor = self.right_child.find_min()
            self.key = successor.key
            successor.binary_tree_delete(successor.key)
        elif self.left_child:   # if the node has only a <em>left</em> child
            self.replace_node_in_parent(self.left_child)
        elif self.right_child:  # if the node has only a <em>right</em> child
            self.replace_node_in_parent(self.right_child)
        else: # this node has no children
            self.replace_node_in_parent(None)
```</p>

<p>参考内容1中在第三种情况下使用的是wiki中的第二种方案，并且是使用直接后继来代替要删除的节点。</p>

<p>二叉查找树的python完整实现见下面AVL树的完整实现(除去AVLTree即可)[参考内容1中的代码相当冗余，但是可读性蛮好，个人认为如果要实现删除节点操作的话建议参考wiki上python代码的实现，也可以查看参考内容1中对代码的详细解释加深理解]</p>

<p>如果原始的列表是基本有序的，那么得到的二叉树会变成一个扭曲的二叉树，性能就相当于一个链表了。</p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/bst_worst.png" alt="image" /></p>

<p>8.平衡二叉查找树：为了避免得到前面提到的扭曲的二叉查找树，于是就有了平衡二叉查找树的概念。</p>

<p>AVL树是最先发明的平衡二叉树，它得名于它的发明者G.M. Adelson-Velsky和E.M. Landis，他们在1962年的论文《An algorithm for the organization of information》中发表了它。</p>

<p><a href="http://zh.wikipedia.org/wiki/AVL%E6%A0%91">on_wiki</a></p>

<p>AVL树的基本操作的实现</p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/avl_operations.png" alt="image" /></p>

<p>如何进行旋转</p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/avl_rotate.png" alt="image" /></p>

<p>旋转的实现描述</p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/avl_rotatedetails.png" alt="image" /></p>

<p><a href="http://zhuyanfeng.com/archives/743">这篇文章对AVL树的讲解很好，并使用C++语言进行实现</a>以及<a href="http://zhuyanfeng.com/archives/716">另一篇文章</a></p>

<p><a href="http://interactivepython.org/courselib/static/pythonds/Trees/balanced.html">参考内容1关于AVL树的讲解</a> —&gt; <a href="http://hujiaweibujidao.github.io/files/avltree.pdf">如果访问较慢可以点击这里下载</a></p>

<p>(1)平衡因子：左子树与右子树的高度之差</p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/avl_bf.png" alt="image" /></p>

<p>(2)分析为什么AVL树能够对查找，插入，删除操作都达到$O(logn)$的效率</p>

<p>推理当中关于斐波那契数列在N很大的时候后项与前项之商接近黄金分割比的内容可参见<a href="http://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B8">斐波那契数列on_wiki</a></p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/avl1.png" alt="image" />
<img src="http://hujiaweibujidao.github.io/images/201405/avl2.png" alt="image" /></p>

<p>(3)左旋，右旋以及左右旋和右左旋</p>

<p>左旋：如果新的根节点有左孩子结点，那么左孩子结点就成为原来的根节点的右孩子结点</p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/avl_left.png" alt="image" /></p>

<p>右旋：如果新的根节点有右孩子结点，那么右孩子结点就成为原来的根节点的左孩子结点</p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/avl_right.png" alt="image" /></p>

<p>一种特殊的情况，单一的左旋和右旋都不行，不停地重复交替，所以需要左右旋(或者右左旋)</p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/avl_leftright.png" alt="image" />
<img src="http://hujiaweibujidao.github.io/images/201405/avl_leftright2.png" alt="image" /></p>

<p>(4)如何在不重新计算子树的高度情况下修改旋转前的根节点和旋转后的根节点的平衡因子值</p>

<p>下面是左旋的例子</p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/avl_rebal1.png" alt="image" />
<img src="http://hujiaweibujidao.github.io/images/201405/avl_rebal2.png" alt="image" /></p>

<p>python代码实现[参考内容1未给出完整代码，下面代码是我自己补充的，添加了测试，如果有误请回复我]</p>

<p>```
class TreeNode:
    def <strong>init</strong>(self,key,val,left=None,right=None,parent=None,balanceFactor=0):
        self.key = key
        self.payload = val
        self.leftChild = left
        self.rightChild = right
        self.parent = parent
        self.balanceFactor=balanceFactor; #default new node balance factor is 0</p>

<pre><code>def hasLeftChild(self):
    return self.leftChild

def hasRightChild(self):
    return self.rightChild

def isLeftChild(self):
    return self.parent and self.parent.leftChild == self

def isRightChild(self):
    return self.parent and self.parent.rightChild == self

def isRoot(self):
    return not self.parent

def isLeaf(self):
    return not (self.rightChild or self.leftChild)

def hasAnyChildren(self):
    return self.rightChild or self.leftChild

def hasBothChildren(self):
    return self.rightChild and self.leftChild

def replaceNodeData(self,key,value,lc,rc):
    self.key = key
    self.payload = value
    self.leftChild = lc
    self.rightChild = rc
    if self.hasLeftChild():
        self.leftChild.parent = self
    if self.hasRightChild():
        self.rightChild.parent = self
</code></pre>

<p>class BinarySearchTree:</p>

<pre><code>def __init__(self):
    self.root = None
    self.size = 0

def length(self):
    return self.size

def __len__(self):
    return self.size

def inorder(self,node):
    if node.leftChild:
        self.inorder(node.leftChild)
    self.print_node(node)
    if node.rightChild:
        self.inorder(node.rightChild)

def levelorder(self,node):
    nodes = []
    nodes.append(node)
    while len(nodes)&gt;0:
        current_node = nodes.pop(0)
        self.print_node(current_node)
        if current_node.leftChild:
            nodes.append(current_node.leftChild)
        if current_node.rightChild:
            nodes.append(current_node.rightChild)

def print_node(self,node):
    if node.parent:
        print([node.key,node.payload,node.parent.key])
    else:
        print([node.key,node.payload])

def put(self,key,val):
    if self.root:
        self._put(key,val,self.root)
    else:
        self.root = TreeNode(key,val)
    self.size = self.size + 1

def _put(self,key,val,currentNode):
    if key &lt; currentNode.key:
        if currentNode.hasLeftChild():
            self._put(key,val,currentNode.leftChild)
        else:
            currentNode.leftChild = TreeNode(key,val,parent=currentNode)
    else:
        if currentNode.hasRightChild():
            self._put(key,val,currentNode.rightChild)
        else:
            currentNode.rightChild = TreeNode(key,val,parent=currentNode)

def __setitem__(self,k,v):
    self.put(k,v)

def get(self,key):
    if self.root:
        res = self._get(key,self.root)
        if res:
            return res.payload
        else:
            return None
    else:
        return None

def _get(self,key,currentNode):
    if not currentNode:
        return None
    elif currentNode.key == key:
        return currentNode
    elif key &lt; currentNode.key:
        return self._get(key,currentNode.leftChild)
    else:
        return self._get(key,currentNode.rightChild)

def __getitem__(self,key):
    return self.get(key)

def __contains__(self,key):
    if self._get(key,self.root):
        return True
    else:
        return False

def delete(self,key):
    if self.size &gt; 1:
        nodeToRemove = self._get(key,self.root)
        if nodeToRemove:
            self.remove(nodeToRemove)
            self.size = self.size-1
        else:
            raise KeyError('Error, key not in tree')
    elif self.size == 1 and self.root.key == key:
        self.root = None
        self.size = self.size - 1
    else:
        raise KeyError('Error, key not in tree')

def __delitem__(self,key):
    self.delete(key)

def spliceOut(self):
    if self.isLeaf():
        if self.isLeftChild():
            self.parent.leftChild = None
        else:
            self.parent.rightChild = None
    elif self.hasAnyChildren():
        if self.hasLeftChild():
            if self.isLeftChild():
                self.parent.leftChild = self.leftChild
            else:
                self.parent.rightChild = self.leftChild
            self.leftChild.parent = self.parent
        else:
            if self.isLeftChild():
                self.parent.leftChild = self.rightChild
            else:
                self.parent.rightChild = self.rightChild
            self.rightChild.parent = self.parent

def findSuccessor(self):
    succ = None
    if self.hasRightChild():
        succ = self.rightChild.findMin()
    else:
        if self.parent:
            if self.isLeftChild():
                succ = self.parent
            else:
                self.parent.rightChild = None
                succ = self.parent.findSuccessor()
                self.parent.rightChild = self
    return succ

def findMin(self):
    current = self
    while current.hasLeftChild():
        current = current.leftChild
    return current

def remove(self,currentNode):
    if currentNode.isLeaf(): #leaf
        if currentNode == currentNode.parent.leftChild:
            currentNode.parent.leftChild = None
        else:
            currentNode.parent.rightChild = None
    elif currentNode.hasBothChildren(): #interior
        succ = currentNode.findSuccessor()
        succ.spliceOut()
        currentNode.key = succ.key
        currentNode.payload = succ.payload
    else: # this node has one child
        if currentNode.hasLeftChild():
            if currentNode.isLeftChild():
                currentNode.leftChild.parent = currentNode.parent
                currentNode.parent.leftChild = currentNode.leftChild
            elif currentNode.isRightChild():
                currentNode.leftChild.parent = currentNode.parent
                currentNode.parent.rightChild = currentNode.leftChild
            else:
                currentNode.replaceNodeData(currentNode.leftChild.key,
                                            currentNode.leftChild.payload,
                                            currentNode.leftChild.leftChild,
                                            currentNode.leftChild.rightChild)
        else:
            if currentNode.isLeftChild():
                currentNode.rightChild.parent = currentNode.parent
                currentNode.parent.leftChild = currentNode.rightChild
            elif currentNode.isRightChild():
                currentNode.rightChild.parent = currentNode.parent
                currentNode.parent.rightChild = currentNode.rightChild
            else:
                currentNode.replaceNodeData(currentNode.rightChild.key,
                                            currentNode.rightChild.payload,
                                            currentNode.rightChild.leftChild,
                                            currentNode.rightChild.rightChild)
</code></pre>

<p>class AVLTree(BinarySearchTree):</p>

<pre><code># def put(self,key,val):
#     if self.root:
#         self._put(key,val,self.root)
#     else:
#         self.root = TreeNode(key,val)
#         self.root.balanceFactor = 0
#     self.size = self.size + 1

def _put(self,key,val,currentNode):
    if key &lt; currentNode.key:
        if currentNode.hasLeftChild():
            self._put(key,val,currentNode.leftChild)
        else:
            currentNode.leftChild = TreeNode(key,val,parent=currentNode)
            self.updateBalance(currentNode.leftChild)
    else:
        if currentNode.hasRightChild():
            self._put(key,val,currentNode.rightChild)
        else:
            currentNode.rightChild = TreeNode(key,val,parent=currentNode)
            self.updateBalance(currentNode.rightChild)

def updateBalance(self,node):
    if node.balanceFactor &gt; 1 or node.balanceFactor &lt; -1:
        self.rebalance(node)
        return
    if node.parent != None:
        if node.isLeftChild():
            node.parent.balanceFactor += 1
        elif node.isRightChild():
            node.parent.balanceFactor -= 1
        if node.parent.balanceFactor != 0:
            self.updateBalance(node.parent)

def rotateLeft(self,rotRoot): #rotate left
    newRoot = rotRoot.rightChild
    rotRoot.rightChild = newRoot.leftChild
    if newRoot.leftChild != None:
        newRoot.leftChild.parent = rotRoot
    newRoot.parent = rotRoot.parent
    if rotRoot.isRoot():
        self.root = newRoot
    else:
        if rotRoot.isLeftChild():
            rotRoot.parent.leftChild = newRoot
        else:
            rotRoot.parent.rightChild = newRoot
    newRoot.leftChild = rotRoot
    rotRoot.parent = newRoot
    rotRoot.balanceFactor = rotRoot.balanceFactor + 1 - min(newRoot.balanceFactor, 0)
    newRoot.balanceFactor = newRoot.balanceFactor + 1 + max(rotRoot.balanceFactor, 0)

def rotateRight(self,rotRoot): #rotate right
    newRoot = rotRoot.leftChild
    rotRoot.leftChild = newRoot.rightChild # deal child
    if newRoot.rightChild != None:
        newRoot.rightChild.parent = rotRoot #deal child parent
    newRoot.parent = rotRoot.parent #deal root parent
    if rotRoot.isRoot():
        self.root = newRoot
    else:
        if rotRoot.isLeftChild():
            rotRoot.parent.leftChild = newRoot
        else:
            rotRoot.parent.rightChild = newRoot
    newRoot.rightChild = rotRoot #deal new root right child
    rotRoot.parent = newRoot #deal old root parent
    rotRoot.balanceFactor = rotRoot.balanceFactor - 1 - min(newRoot.balanceFactor, 0)
    newRoot.balanceFactor = newRoot.balanceFactor - 1 + max(rotRoot.balanceFactor, 0)

def rebalance(self,node):
    if node.balanceFactor &lt; 0:
        if node.rightChild.balanceFactor &gt; 0:
            self.rotateRight(node.rightChild)
            self.rotateLeft(node)
        else:
            self.rotateLeft(node)
    elif node.balanceFactor &gt; 0:
        if node.leftChild.balanceFactor &lt; 0:
            self.rotateLeft(node.leftChild)
            self.rotateRight(node)
        else:
            self.rotateRight(node)
</code></pre>

<h1 id="test-code">test code</h1>
<p># test avl tree
print(‘test avl’)
mytree = AVLTree()
mytree[3]=”red”
mytree[4]=”blue”
mytree[6]=”yellow”
mytree[2]=”at”
mytree[5]=’dog’
mytree[1]=’cat’
mytree.levelorder(mytree.root)</p>

<h1 id="test-bst">test bst</h1>
<p>print(‘test bst’)
mytree = BinarySearchTree()
mytree[3]=”red”
mytree[4]=”blue”
mytree[6]=”yellow”
mytree[2]=”at”
mytree[5]=’dog’
mytree[1]=’cat’
mytree.levelorder(mytree.root)</p>

<h1 id="test-avl">test avl</h1>
<p># [4, ‘blue’]
# [2, ‘at’, 4]
# [6, ‘yellow’, 4]
# [1, ‘cat’, 2]
# [3, ‘red’, 2]
# [5, ‘dog’, 6]
# test bst
# [3, ‘red’]
# [2, ‘at’, 3]
# [4, ‘blue’, 3]
# [1, ‘cat’, 2]
# [6, ‘yellow’, 4]
# [5, ‘dog’, 6]</p>

<p>```</p>

<p>对于我给定的测试数据，对应得到的二叉查找树和AVL树如下图所示，二叉查找树明显不平衡，AVL树中所有节点的平衡因子为0或者1，在构造的过程中，共发生了一次左旋和一次右旋。</p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/bst_avl.png" alt="images" /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Algorithms - Data Structures]]></title>
    <link href="http://hujiaweibujidao.github.io/blog/2014/05/08/python-algorithms-datastructures/"/>
    <updated>2014-05-08T10:00:00+08:00</updated>
    <id>http://hujiaweibujidao.github.io/blog/2014/05/08/python-algorithms-datastructures</id>
    <content type="html"><![CDATA[<p>参考内容：</p>

<p>1.<a href="http://interactivepython.org/courselib/static/pythonds/index.html">Problem Solving with Python</a></p>

<p>Chapter 2 Algorithm Analysis <br />
Chapter 3 Basic Data Structures <br />
Chapter 6 Trees and Tree Algorithms   </p>

<p>2.<a href="http://en.wikipedia.org/wiki/Introduction_to_Algorithms">算法导论</a></p>

<h4 id="section">数据结构总结</h4>

<p>1.Python内置数据结构的性能分析</p>

<p>(1)List</p>

<p>List的各个操作的时间复杂度</p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/listoptime.png" alt="image" /></p>

<p>同样是执行1000次创建一个包含1-1000的列表，四种方式使用的时间差距很大！使用append比逐次增加要快很多，另外，使用python的列表产生式比append要快，而第四种方式更加快！</p>

<p>```python
def test1():
   l = []
   for i in range(1000):
      l = l + [i]
def test2():
   l = []
   for i in range(1000):
      l.append(i)
def test3():
   l = [i for i in range(1000)]
def test4():
   l = list(range(1000))</p>

<h1 id="import-the-timeit-module---import-timeit">Import the timeit module -&gt; import timeit</h1>
<p># Import the Timer class defined in the module
from timeit import Timer
# If the above line is excluded, you need to replace Timer with
# timeit.Timer when defining a Timer object
t1 = Timer(“test1()”, “from <strong>main</strong> import test1”)
print(“concat “,t1.timeit(number=1000), “milliseconds”)
t2 = Timer(“test2()”, “from <strong>main</strong> import test2”)
print(“append “,t2.timeit(number=1000), “milliseconds”)
t3 = Timer(“test3()”, “from <strong>main</strong> import test3”)
print(“comprehension “,t3.timeit(number=1000), “milliseconds”)
t4 = Timer(“test4()”, “from <strong>main</strong> import test4”)
print(“list range “,t4.timeit(number=1000), “milliseconds”)</p>

<h1 id="concat--17890608310699463-milliseconds">(‘concat ‘, 1.7890608310699463, ‘milliseconds’)</h1>
<p># (‘append ‘, 0.13796091079711914, ‘milliseconds’)
# (‘comprehension ‘, 0.05671119689941406, ‘milliseconds’)
# (‘list range ‘, 0.014147043228149414, ‘milliseconds’)
```</p>

<p><code>timeit</code>模块的解释：</p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/timeit.png" alt="image" /></p>

<p>测试pop操作：从结果可以看出，pop最后一个元素的效率远远高于pop第一个元素</p>

<p>```
x = list(range(2000000))
pop_zero = Timer(“x.pop(0)”,”from <strong>main</strong> import x”)
print(“pop_zero “,pop_zero.timeit(number=1000), “milliseconds”)
x = list(range(2000000))
pop_end = Timer(“x.pop()”,”from <strong>main</strong> import x”)
print(“pop_end “,pop_end.timeit(number=1000), “milliseconds”)</p>

<h1 id="popzero--19101738929748535-milliseconds">(‘pop_zero ‘, 1.9101738929748535, ‘milliseconds’)</h1>
<p># (‘pop_end ‘, 0.00023603439331054688, ‘milliseconds’)
```</p>

<p>(2)Dictionary</p>

<p>Dictionary的各个操作的性能</p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/dictionary.png" alt="image" /></p>

<p>Dictionary和List的性能比较：list基本上随着其元素的数目呈线性增长，而dictionary一直维持在很短很短的时间内(我的机子测试的结果都是<code>0.001ms</code>)。</p>

<p>```
import timeit
import random</p>

<p>for i in range(10000,1000001,20000):
    t = timeit.Timer(“random.randrange(%d) in x”%i,”from <strong>main</strong> import random,x”)
    x = list(range(i))
    lst_time = t.timeit(number=1000)
    x = {j:None for j in range(i)}
    d_time = t.timeit(number=1000)
    print(“%d,%10.3f,%10.3f” % (i, lst_time, d_time))
```</p>

<p>结果图</p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/compare.png" alt="image" /></p>

<p>2.栈：LIFO结构，后进先出</p>

<p>栈能解决的问题很多，比如逆波兰表达式求值，得到一个十进制数的二进制表达，检查括号匹配问题以及图的深度搜索等等，都很简单，可查看参考内容1学习。</p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/stack.png" alt="image" /></p>

<p>```python
# Completed implementation of a stack ADT
class Stack:
    def <strong>init</strong>(self):
       self.items = []
    def is_empty(self):
       return self.items == []
    def push(self, item):
       self.items.append(item)
    def pop(self):
       return self.items.pop()
    def peek(self):
       return self.items[len(self.items)-1]
    def size(self):
       return len(self.items)</p>

<p>s = Stack()
print(s.is_empty())
s.push(4)
s.push(‘dog’)
print(s.peek())
s.push(True)
print(s.size())
print(s.is_empty())
s.push(8.4)
print(s.pop())
print(s.pop())
print(s.size())
```</p>

<p>3.队列：FIFO结构，先进先出</p>

<p>队列一般用于解决需要优先队列的问题或者进行广度优先搜索的问题，也很简单。</p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/queue.png" alt="image" /></p>

<p>```python
# Completed implementation of a queue ADT
class Queue:
   def <strong>init</strong>(self):
      self.items = []
   def is_empty(self):
      return self.items == []
   def enqueue(self, item):
      self.items.insert(0,item)
   def dequeue(self):
      return self.items.pop()
   def size(self):
      return len(self.items)</p>

<p>q = Queue()
q.enqueue(‘hello’)
q.enqueue(‘dog’)
print(q.items)
q.enqueue(3)
q.dequeue()
print(q.items)
```</p>

<p>4.双向队列：左右两边都可以插入和删除的队列</p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/deque.png" alt="image" /></p>

<p>下面的实现是以右端为front，左端为rear</p>

<p>```python
# Completed implementation of a deque ADT
class Deque:
   def <strong>init</strong>(self):
      self.items = []
   def is_empty(self):
      return self.items == []
   def add_front(self, item):
       self.items.append(item)
   def add_rear(self, item):
      self.items.insert(0,item)
   def remove_front(self):
      return self.items.pop()
   def remove_rear(self):
      return self.items.pop(0)
   def size(self):
      return len(self.items)</p>

<p>dq=Deque();
dq.add_front(‘dog’);
dq.add_rear(‘cat’);
print(dq.items)
dq.remove_front();
dq.add_front(‘pig’);
print(dq.items)
```</p>

<p>5.二叉树：一个节点最多有两个孩子节点的树。如果是从0索引开始存储，那么对应于节点p的孩子节点是2p+1和2p+2两个节点，相反，节点p的父亲节点是(p-1)/2位置上的点</p>

<p>二叉树的应用很多，比如对算术表达式建立一颗二叉树可以清楚看出表达式是如何计算的(详情请见参考内容1)，二叉树的变种可以得到其他的有一定特性的数据结构，例如后面的二叉堆。二叉树的三种遍历方法(前序，中序，后序)同样有很多的应用，比较简单，略过。</p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/bt2.png" alt="image" /></p>

<p>第一种，直接使用list来实现二叉树，可读性差</p>

<p>```python
def binary_tree(r):
    return [r, [], []]
def insert_left(root, new_branch):
    t = root.pop(1)
    if len(t) &gt; 1:
        #new_branch becomes the left node of root, and original left
        #node t becomes left node of new_branch, right node is none
        root.insert(1, [new_branch, t, []])
    else:
        root.insert(1, [new_branch, [], []])
    return root
def insert_right(root, new_branch):
    t = root.pop(2)
    if len(t) &gt; 1:
        root.insert(2, [new_branch, [], t])
    else:
        root.insert(2, [new_branch, [], []])
    return root
def get_root_val(root):
    return root[0]
def set_root_val(root, new_val):
    root[0] = new_val
def get_left_child(root):
    return root[1]
def get_right_child(root):
    return root[2]</p>

<p>r = binary_tree(3)
insert_left(r, 4)
insert_left(r, 5)
insert_right(r, 6)
insert_right(r, 7)
print(r)
l = get_left_child(r)
print(l)
set_root_val(l, 9)
print(r)
insert_left(l, 11)
print(r)
print(get_right_child(get_right_child(r)))
```</p>

<p>第二种，使用类的形式定义二叉树，可读性更好</p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/btclass.png" alt="image" /></p>

<p>```
class BinaryTree:
    def <strong>init</strong>(self, root):
        self.key = root
        self.left_child = None
        self.right_child = None
    def insert_left(self, new_node):
        if self.left_child == None:
            self.left_child = BinaryTree(new_node)
        else:
            t = BinaryTree(new_node)
            t.left_child = self.left_child
            self.left_child = t
    def insert_right(self, new_node):
        if self.right_child == None:
            self.right_child = BinaryTree(new_node)
        else:
            t = BinaryTree(new_node)
            t.right_child = self.right_child
            self.right_child = t
    def get_right_child(self):
        return self.right_child
    def get_left_child(self):
        return self.left_child
    def set_root_val(self, obj):
        self.key = obj
    def get_root_val(self):
        return self.key</p>

<p>r = BinaryTree(‘a’)
print(r.get_root_val())
print(r.get_left_child())
r.insert_left(‘b’)
print(r.get_left_child())
print(r.get_left_child().get_root_val())
r.insert_right(‘c’)
print(r.get_right_child())
print(r.get_right_child().get_root_val())
r.get_right_child().set_root_val(‘hello’)
print(r.get_right_child().get_root_val())
```</p>

<p>6.二叉堆：根据堆的性质又可以分为最小堆和最大堆，是一种非常好的优先队列。在最小堆中孩子节点一定大于等于其父亲节点，最大堆反之。二叉堆实际上一棵完全二叉树，并且满足堆的性质。对于插入和查找操作的时间复杂度度都是$O(nlogn)$。</p>

<p>它的插入操作图示：</p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/heapinsert.png" alt="image" /></p>

<p>去除根节点的操作图示：</p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/heapdel.png" alt="image" /></p>

<p>注意，下面的实现中默认在初始的堆列表中插入了一个元素0，这样做可以保证堆的真实有效的元素个数和current_size值对应，而且最后一个元素的索引就对应了current_size。</p>

<p>此外，从list中建堆的过程需要从最后一个非叶子节点开始到第一个非叶子节点(根节点)进行。这篇文章<a href="http://www.cnblogs.com/Anker/archive/2013/01/23/2873422.html">来自博客园</a>解释了这个问题。建堆的过程如下：[下图摘自原博客，版权归原作者，谢谢]</p>

<p><img src="http://hujiaweibujidao.github.io/images/201405/heapbuild.png" alt="image" /></p>

<p>```python
class BinHeap:
    def <strong>init</strong>(self):
        self.heap_list = [0]
        self.current_size = 0
    def perc_up(self, i):
        while i // 2 &gt; 0: # &gt;0 means this node is still available
            if self.heap_list[i] &lt; self.heap_list[i // 2]:
                tmp = self.heap_list[i // 2]
                self.heap_list[i // 2] = self.heap_list[i]
                self.heap_list[i] = tmp
            i = i // 2
    def insert(self, k):
        self.heap_list.append(k)
        self.current_size = self.current_size + 1
        self.perc_up(self.current_size)
    def perc_down(self, i):
        while (i * 2) &lt;= self.current_size:
            mc = self.min_child(i)
            if self.heap_list[i] &gt; self.heap_list[mc]:
                tmp = self.heap_list[i]
                self.heap_list[i] = self.heap_list[mc]
                self.heap_list[mc] = tmp
            i = mc
    def min_child(self, i):
        if i * 2 + 1 &gt; self.current_size:
            return i * 2
        else:
            if self.heap_list[i * 2] &lt; self.heap_list[i * 2 + 1]:
                return i * 2
            else:
                return i * 2 + 1
    def del_min(self):
        ret_val = self.heap_list[1]
        self.heap_list[1] = self.heap_list[self.current_size]
        self.current_size = self.current_size - 1
        self.heap_list.pop()
        self.perc_down(1)
        return ret_val</p>

<pre><code>def build_heap(self, a_list):
    i = len(a_list) // 2
    self.current_size = len(a_list)
    self.heap_list = [0] + a_list[:] #append original list
    while (i &gt; 0):
        #build the heap we only need to deal the first part!
        self.perc_down(i)
        i=i-1
</code></pre>

<p>a_list=[9, 6, 5, 2, 3];
bh=BinHeap();
bh.build_heap(a_list);
print(bh.heap_list)
print(bh.current_size)
bh.insert(10)
bh.insert(7)
print(bh.heap_list)
bh.del_min();
print(bh.heap_list)
print(bh.current_size)
```</p>

<p>关于二叉查找树等内容请见<a href="http://hujiaweibujidao.github.io/blog/2014/05/08/python-algorithms-Trees/">树的总结</a>。</p>

]]></content>
  </entry>
  
</feed>
