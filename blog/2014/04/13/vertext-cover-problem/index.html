
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Algorithms: Vertext Cover Problem - Hujiawei Bujidao</title>
  <meta name="author" content="hujiawei">

  
  <meta name="description" content="Algorithms: Vertext Cover Problem 1.问题描述 给定一个N个点M条边的无向图G（点的编号从1至N），问是否存在一个不超过K个点的集合S，使得G中的每条边都至少有一个点在集合S中。 例如，如下图所示的无向图G（报告中算法分析过程中一直使用下面的图G） (1) &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://hujiaweibujidao.github.io/blog/2014/04/13/vertext-cover-problem">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Hujiawei Bujidao" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">


  

</head>

<body   >

	<header role="banner">
		
<hgroup style="text-align: center">
	<h1><a href="/"><img src="/images/conan-paper-small.png"  />Hujiawei Bujidao<img src="/images/conan-hat-small.png"  /></a></h1>
	
	<h2>I will always be your savior! A secret makes a man man!</h2>
	
</hgroup>


	</header>
	<nav role="navigation">
		<ul class="subscription" data-subscription="rss">
  <!--<li><a href="https://github.com/hujiaweibujidao" rel="subscribe-rss" title="subscribe via RSS">View me on GitHub</a></li>-->
  <!--
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
  --> 
</ul>
<!--
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:hujiaweibujidao.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form> 
  
-->
<ul class="main-navigation">
  <li><a href="/blog/archives/">Blog</a></li>
  <li><a href="/aboutme/">AboutMe</a></li>
  <li><a href="/math/">Math</a></li>
  <li><a href="/python/">Python</a></li>
  <li><a href="/datamining/">ML-DM-PR</a></li>
  <li><a href="/blog/categories/mobiledev/">MobileDev</a></li>
  <li><a href="/blog/categories/music/">Music</a></li>
  <li><a href="/blog/categories/picture/">Picture</a></li>
  <!--
  <li><a href="/xjava/">XJava</a></li>
  -->
  <!-- <li><a href="/datamining/">Projects</a></li> -->
</ul>


	</nav>
	<div id="main">
		<div id="content">
			<div>

<article class="hentry" role="article">
		
  <header>
    
      <h1 class="entry-title">Algorithms: Vertext Cover Problem</h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-04-13T23:57:00+08:00" pubdate data-updated="true">Apr 13<span>th</span>, 2014</time>
        
      </p>
    
  </header>


<div class="entry-content"><h4 id="centeralgorithms-vertext-cover-problemcenter"><center>Algorithms: Vertext Cover Problem</center></h4>

<h4 id="section">1.问题描述</h4>

<p>给定一个N个点M条边的无向图G（点的编号从1至N），问是否存在一个不超过K个点的集合S，使得G中的每条边都至少有一个点在集合S中。</p>

<p>例如，如下图所示的无向图G（报告中算法分析过程中一直使用下面的图G）  </p>

<p>(1)如果选择包含点1,2,6这3个点的集合S不能满足条件，因为边(3,7)两个端点都不在S中。</p>

<p><img src="/images/201404/exp1-3.png" alt="image" /></p>

<p>(2)如果选择包含点1,2,6,7这4个点的集合S虽然满足条件，但是它使用了4个点，其实可以使用更少的点，如下面(3)所示</p>

<p><img src="/images/201404/exp1-2.png" alt="image" /></p>

<p>(3)如果选择包含点1,3,5这3个点的集合S便满足条件，使得G中的每条边都至少有一个点在集合S中。</p>

<p><img src="/images/201404/exp1-1.png" alt="image" /></p>

<h4 id="section-1">2.解题思路</h4>

<p>我的解题思路基于分支定界和贪心两个策略，用一个优先队列维护当前可行的节点，每个节点维护着该节点情况下还可以选择的顶点数目k、需要覆盖的剩余边数e、顶点的状态state、顶点的边数edge等信息，这些节点的排序遵循下面的贪心策略，节点的扩展遵循下面的分支定界策略。总体思路是：</p>

<p>①将原图数据构造成一个解空间树的节点，利用定界策略判断是否有解，如果无解直接退出，如果有可能有解则插入到优先队列中；</p>

<p>②若优先队列不为空，那么便从优先队列中取出第一个可行的节点，进入步骤③，如果优先队列为空则退出；</p>

<p>③判断当前节点是否满足解的条件，如果满足便输出解退出，如果不满足便进入步骤④；</p>

<p>④检查当前节点是否可以扩展，不能扩展的话便进入②继续循环，如果能扩展的话则扩展，然后验证扩展到左右节点是否有解，将有解的扩展节点插入到优先队列中，然后进入②继续循环。</p>

<p>下面分别介绍下分支定界和贪心这两个策略：</p>

<h5 id="section-2">(1)分支定界策略</h5>

<p>首先，界的选择。在一个确定的无向图G中，每个顶点的边即确定了，那么对于该无向图中k个顶点能够覆盖的最多的边数e也就可以确定了！只要对顶点按照边的数目降序排列，然后选择前k个顶点，将它们的边数相加即能得到一个边数上界！因为这k个顶点相互之间可能有边存在也可能没有，所以这是个上界，而且有可能达到。以图G为例，各个顶点的边数统计，并采用降序排列的结果如下：</p>

<p><img src="/images/201404/exp1-f3.png" alt="image" /></p>

<p>假设取k=3个点，那么有Up(e)=(3+3+2)=8 &gt; 7 条边（7为图G的总边数），也就是说，如果从图G中取3个点，要覆盖8条边是有可能的。但是，如果取k=2个点，那么有Up(e)=(3+3)=6 &lt; 7 条边，说明从图G中取2个点，是不可能覆盖G中的全部7条边的！基于这个上界，可以在分支树中扩展出来的节点进行验证，已知它还可以选择的顶点数目以及还需要覆盖的边的条数，加上顶点的状态（下面会分析说明）即可判断当前节点是否存在解！如果不存在即可进行剪枝了。</p>

<p>其次，顶点的状态。该策略中顶点有三种状态，分别为已经选择了的状态S1，不选择的状态S2，可以选择的状态S3。其中，不选择的状态S2对应解空间树中的右节点，不选择该节点，然后设置该节点为不选择状态S2。这点很重要，因为有了这个状态，可以使得上界的判断更为精确，因为只能从剩余顶点集中选择那些状态S3的顶点，状态S1和S2都不行，那么上界便会更小，也就更加精确，从而利于剪枝！</p>

<h5 id="section-3">(2)贪心策略</h5>

<p>贪心的策略是指可行的结点都是按照还需要覆盖的剩余边数的降序排列，即，每次选择的节点都是可行节点中还需要覆盖的边数最小的那个节点，因为它最接近结果了。</p>

<h5 id="section-4">(3)例子分析</h5>

<p>以图G为例，此时e=7（要覆盖的边数），取k=3，图G用邻接矩阵保存为全局数据，计算每个顶点的边数，然后降序排列。</p>

<p>步骤①判断是否可能有解，Up(e)=3+3+2=8&gt;7，可能有解，那么将图G构造成一个解空间树的节点，它包含了还能选择的点数k=3，还需要覆盖的边数e=7，每个顶点的边数以及按边数大小的降序排列（上表），每个顶点的状态（初始时都是可选择的状态S3）。然后，将该节点插入到优先队列中，该优先队列是用最小堆实现的，按照前面的贪心策略对队列中的节点进行降序排列。</p>

<p>步骤②取出了优先队列中的根节点，很显然，还需要覆盖的边数为7，不为0，所以还不满足条件。接下来要检查是否能够进行扩展，从顶点集合中选择状态为可以选择的顶点中边数最多的点，该点存在为顶点2，接着进行扩展，扩展左节点时将还能选择的点数k-1=2，然后计算选择了该点之后删除了几条未覆盖的边，得到还需要覆盖的边数e=4，然后更新所有其他顶点的边数，并重新排序，最后将顶点2的状态设置为已经选择了；扩展右节点时，只要将顶点2的状态设置为不能选择，还能选择的点数k(=3)，还需要覆盖的边数e(=7)保持不变。扩展完了之后，同样判断左右节点是否可能有解，如果有解，将该节点插入到优先队列中。这里左右节点都有解，那么将左右节点都插入到优先队列中，因为左节点还需要覆盖的边数e=4小于右节点的e=7，所以根据贪心策略，左节点在右节点的前面。上面两个步骤的图示如下，其中标明了顶点状态颜色。</p>

<p><img src="/images/201404/exp1-f1.png" alt="image" /></p>

<p>算法然后继续进入步骤②，此时取出的是节点是刚才插入的左节点，很显然，还需要覆盖的边数为4，不为0，所以还不满足条件。接下来要检查是否能够进行扩展，从顶点集合中选择状态为可以选择的顶点中边数最多的点，该点存在为顶点3，接着进行扩展，扩展左节点时将还能选择的点数k-1=1，然后计算选择了该点之后删除了几条未覆盖的边，得到还需要覆盖的边数e=2，然后更新所有其他顶点的边数，并重新排序，最后将顶点3的状态设置为已经选择了；扩展右节点时，只要将顶点3的状态设置为不能选择，还能选择的点数k(=3)，还需要覆盖的边数e(=7)保持不变。扩展完了之后，同样判断左右节点是否可能有解，如果有解，将该节点插入到优先队列中。这里左右节点都不可能有解，那么直接进入步骤②继续循环。上面这一步的图示如下：</p>

<p><img src="/images/201404/exp1-f2.png" alt="image" /></p>

<p>算法按照上面的方式不断进行，最后满足条件的分支的过程是：</p>

<p>①不选择顶点2；②选择顶点3；③选择顶点1；④选择顶点5。</p>

<p>最后得到的满足条件的解是选择顶点1,3,5。</p>

<h4 id="section-5">(4)复杂度分析</h4>

<p>该算法优先队列使用的是最小堆实现的(O(nlgn))，对顶点按照边排序使用的是快速排序算法(O(nlgn))，解空间树的深度最多为顶点数目n，每层都要进行分支定界，所以每层的时间复杂度为O(nlgn)，所以算法总的时间复杂度为O(n^2 lgn)。但是，为了实现分支定界，每个节点保存的信息量较多，空间复杂度较大。(有木有分析错了，我不太会分析复杂度)</p>

<p>OJ系统的结果为：时间 156ms  空间 1.0MB</p>

<p>本人对指针领悟能力有限，C++也是一知半解，OJ只能用C或者C++，所以下面的C++代码效率不高，仅供参考，:-)</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
<span class="line-number">62</span>
<span class="line-number">63</span>
<span class="line-number">64</span>
<span class="line-number">65</span>
<span class="line-number">66</span>
<span class="line-number">67</span>
<span class="line-number">68</span>
<span class="line-number">69</span>
<span class="line-number">70</span>
<span class="line-number">71</span>
<span class="line-number">72</span>
<span class="line-number">73</span>
<span class="line-number">74</span>
<span class="line-number">75</span>
<span class="line-number">76</span>
<span class="line-number">77</span>
<span class="line-number">78</span>
<span class="line-number">79</span>
<span class="line-number">80</span>
<span class="line-number">81</span>
<span class="line-number">82</span>
<span class="line-number">83</span>
<span class="line-number">84</span>
<span class="line-number">85</span>
<span class="line-number">86</span>
<span class="line-number">87</span>
<span class="line-number">88</span>
<span class="line-number">89</span>
<span class="line-number">90</span>
<span class="line-number">91</span>
<span class="line-number">92</span>
<span class="line-number">93</span>
<span class="line-number">94</span>
<span class="line-number">95</span>
<span class="line-number">96</span>
<span class="line-number">97</span>
<span class="line-number">98</span>
<span class="line-number">99</span>
<span class="line-number">100</span>
<span class="line-number">101</span>
<span class="line-number">102</span>
<span class="line-number">103</span>
<span class="line-number">104</span>
<span class="line-number">105</span>
<span class="line-number">106</span>
<span class="line-number">107</span>
<span class="line-number">108</span>
<span class="line-number">109</span>
<span class="line-number">110</span>
<span class="line-number">111</span>
<span class="line-number">112</span>
<span class="line-number">113</span>
<span class="line-number">114</span>
<span class="line-number">115</span>
<span class="line-number">116</span>
<span class="line-number">117</span>
<span class="line-number">118</span>
<span class="line-number">119</span>
<span class="line-number">120</span>
<span class="line-number">121</span>
<span class="line-number">122</span>
<span class="line-number">123</span>
<span class="line-number">124</span>
<span class="line-number">125</span>
<span class="line-number">126</span>
<span class="line-number">127</span>
<span class="line-number">128</span>
<span class="line-number">129</span>
<span class="line-number">130</span>
<span class="line-number">131</span>
<span class="line-number">132</span>
<span class="line-number">133</span>
<span class="line-number">134</span>
<span class="line-number">135</span>
<span class="line-number">136</span>
<span class="line-number">137</span>
<span class="line-number">138</span>
<span class="line-number">139</span>
<span class="line-number">140</span>
<span class="line-number">141</span>
<span class="line-number">142</span>
<span class="line-number">143</span>
<span class="line-number">144</span>
<span class="line-number">145</span>
<span class="line-number">146</span>
<span class="line-number">147</span>
<span class="line-number">148</span>
<span class="line-number">149</span>
<span class="line-number">150</span>
<span class="line-number">151</span>
<span class="line-number">152</span>
<span class="line-number">153</span>
<span class="line-number">154</span>
<span class="line-number">155</span>
<span class="line-number">156</span>
<span class="line-number">157</span>
<span class="line-number">158</span>
<span class="line-number">159</span>
<span class="line-number">160</span>
<span class="line-number">161</span>
<span class="line-number">162</span>
<span class="line-number">163</span>
<span class="line-number">164</span>
<span class="line-number">165</span>
<span class="line-number">166</span>
<span class="line-number">167</span>
<span class="line-number">168</span>
<span class="line-number">169</span>
<span class="line-number">170</span>
<span class="line-number">171</span>
<span class="line-number">172</span>
<span class="line-number">173</span>
<span class="line-number">174</span>
<span class="line-number">175</span>
<span class="line-number">176</span>
<span class="line-number">177</span>
<span class="line-number">178</span>
<span class="line-number">179</span>
<span class="line-number">180</span>
<span class="line-number">181</span>
<span class="line-number">182</span>
<span class="line-number">183</span>
<span class="line-number">184</span>
<span class="line-number">185</span>
<span class="line-number">186</span>
<span class="line-number">187</span>
<span class="line-number">188</span>
<span class="line-number">189</span>
<span class="line-number">190</span>
<span class="line-number">191</span>
<span class="line-number">192</span>
<span class="line-number">193</span>
<span class="line-number">194</span>
<span class="line-number">195</span>
<span class="line-number">196</span>
<span class="line-number">197</span>
<span class="line-number">198</span>
<span class="line-number">199</span>
<span class="line-number">200</span>
<span class="line-number">201</span>
<span class="line-number">202</span>
<span class="line-number">203</span>
<span class="line-number">204</span>
<span class="line-number">205</span>
<span class="line-number">206</span>
<span class="line-number">207</span>
<span class="line-number">208</span>
<span class="line-number">209</span>
<span class="line-number">210</span>
<span class="line-number">211</span>
<span class="line-number">212</span>
<span class="line-number">213</span>
<span class="line-number">214</span>
<span class="line-number">215</span>
<span class="line-number">216</span>
<span class="line-number">217</span>
<span class="line-number">218</span>
<span class="line-number">219</span>
<span class="line-number">220</span>
<span class="line-number">221</span>
<span class="line-number">222</span>
<span class="line-number">223</span>
<span class="line-number">224</span>
<span class="line-number">225</span>
<span class="line-number">226</span>
<span class="line-number">227</span>
<span class="line-number">228</span>
<span class="line-number">229</span>
<span class="line-number">230</span>
<span class="line-number">231</span>
<span class="line-number">232</span>
<span class="line-number">233</span>
<span class="line-number">234</span>
<span class="line-number">235</span>
<span class="line-number">236</span>
<span class="line-number">237</span>
<span class="line-number">238</span>
<span class="line-number">239</span>
<span class="line-number">240</span>
<span class="line-number">241</span>
<span class="line-number">242</span>
<span class="line-number">243</span>
<span class="line-number">244</span>
<span class="line-number">245</span>
<span class="line-number">246</span>
<span class="line-number">247</span>
<span class="line-number">248</span>
<span class="line-number">249</span>
<span class="line-number">250</span>
<span class="line-number">251</span>
<span class="line-number">252</span>
<span class="line-number">253</span>
<span class="line-number">254</span>
<span class="line-number">255</span>
<span class="line-number">256</span>
<span class="line-number">257</span>
<span class="line-number">258</span>
<span class="line-number">259</span>
<span class="line-number">260</span>
<span class="line-number">261</span>
<span class="line-number">262</span>
<span class="line-number">263</span>
<span class="line-number">264</span>
<span class="line-number">265</span>
<span class="line-number">266</span>
<span class="line-number">267</span>
<span class="line-number">268</span>
<span class="line-number">269</span>
<span class="line-number">270</span>
<span class="line-number">271</span>
<span class="line-number">272</span>
<span class="line-number">273</span>
<span class="line-number">274</span>
<span class="line-number">275</span>
<span class="line-number">276</span>
<span class="line-number">277</span>
<span class="line-number">278</span>
<span class="line-number">279</span>
<span class="line-number">280</span>
<span class="line-number">281</span>
<span class="line-number">282</span>
<span class="line-number">283</span>
<span class="line-number">284</span>
<span class="line-number">285</span>
<span class="line-number">286</span>
<span class="line-number">287</span>
<span class="line-number">288</span>
<span class="line-number">289</span>
<span class="line-number">290</span>
<span class="line-number">291</span>
<span class="line-number">292</span>
<span class="line-number">293</span>
<span class="line-number">294</span>
<span class="line-number">295</span>
<span class="line-number">296</span>
<span class="line-number">297</span>
<span class="line-number">298</span>
<span class="line-number">299</span>
<span class="line-number">300</span>
<span class="line-number">301</span>
<span class="line-number">302</span>
<span class="line-number">303</span>
<span class="line-number">304</span>
<span class="line-number">305</span>
<span class="line-number">306</span>
<span class="line-number">307</span>
<span class="line-number">308</span>
<span class="line-number">309</span>
<span class="line-number">310</span>
<span class="line-number">311</span>
<span class="line-number">312</span>
<span class="line-number">313</span>
<span class="line-number">314</span>
<span class="line-number">315</span>
<span class="line-number">316</span>
<span class="line-number">317</span>
<span class="line-number">318</span>
<span class="line-number">319</span>
<span class="line-number">320</span>
<span class="line-number">321</span>
<span class="line-number">322</span>
<span class="line-number">323</span>
<span class="line-number">324</span>
<span class="line-number">325</span>
<span class="line-number">326</span>
<span class="line-number">327</span>
<span class="line-number">328</span>
<span class="line-number">329</span>
<span class="line-number">330</span>
<span class="line-number">331</span>
<span class="line-number">332</span>
<span class="line-number">333</span>
<span class="line-number">334</span>
<span class="line-number">335</span>
<span class="line-number">336</span>
<span class="line-number">337</span>
<span class="line-number">338</span>
<span class="line-number">339</span>
<span class="line-number">340</span>
<span class="line-number">341</span>
<span class="line-number">342</span>
<span class="line-number">343</span>
<span class="line-number">344</span>
<span class="line-number">345</span>
<span class="line-number">346</span>
<span class="line-number">347</span>
<span class="line-number">348</span>
<span class="line-number">349</span>
<span class="line-number">350</span>
<span class="line-number">351</span>
<span class="line-number">352</span>
<span class="line-number">353</span>
<span class="line-number">354</span>
<span class="line-number">355</span>
<span class="line-number">356</span>
<span class="line-number">357</span>
<span class="line-number">358</span>
<span class="line-number">359</span>
<span class="line-number">360</span>
<span class="line-number">361</span>
<span class="line-number">362</span>
<span class="line-number">363</span>
<span class="line-number">364</span>
<span class="line-number">365</span>
<span class="line-number">366</span>
<span class="line-number">367</span>
<span class="line-number">368</span>
<span class="line-number">369</span>
<span class="line-number">370</span>
<span class="line-number">371</span>
<span class="line-number">372</span>
<span class="line-number">373</span>
<span class="line-number">374</span>
</pre></td><td class="code"><pre><code class=""><span class="line">#include &lt;iostream&gt;
</span><span class="line">#include &lt;vector&gt;
</span><span class="line">using namespace std;
</span><span class="line">#define MAX_NODE 101
</span><span class="line">#define INDEBUG 0
</span><span class="line">int8_t graph[MAX_NODE][MAX_NODE];//int -&gt; int8_t
</span><span class="line">//int edges[MAX_NODE];//0 is redudent
</span><span class="line">//int nodes[MAX_NODE];//the order of node
</span><span class="line">int t,m,n,k,a,b;
</span><span class="line">class VCNode {//Vertex Cover Node
</span><span class="line">public:
</span><span class="line">    int p;//points can be used
</span><span class="line">    int e;//edges to cover!!
</span><span class="line">    int index[MAX_NODE];//the index of each node in array [node], index[k]=i!!
</span><span class="line">    int edge[MAX_NODE];//MAX_NODE the edge number of each node, edge[i]=j!!
</span><span class="line">    int node[MAX_NODE];//the order of the node
</span><span class="line">    int state[MAX_NODE];//the state of each node ** 0 can be used / 1 used / -1 can not be used
</span><span class="line">//    int graph[MAX_NODE][MAX_NODE];//the graph on the node//no need,just use the global graph
</span><span class="line">    // node k is in index[k]=i position in array [node]
</span><span class="line">    // node i has number of edge[i]=j edges
</span><span class="line">};
</span><span class="line">class Minheap {//Min Heap
</span><span class="line">public:
</span><span class="line">    vector&lt;VCNode&gt; nodes;
</span><span class="line">    
</span><span class="line">    void insert(VCNode node);
</span><span class="line">    VCNode popmin();
</span><span class="line">//  void print();
</span><span class="line">};
</span><span class="line">void Minheap::insert(VCNode node) {
</span><span class="line">    nodes.push_back(node);
</span><span class="line">    //  cout &lt;&lt; "size is " &lt;&lt; nodes.size() &lt;&lt; endl;//
</span><span class="line">    int curpos = (int)nodes.size() - 1; // current position
</span><span class="line">    int parent = (curpos - 1) / 2; //parent position
</span><span class="line">    while (curpos != parent &amp;&amp; parent &gt;= 0) { //parent is still in heap
</span><span class="line">        if (nodes[parent].e &gt; nodes[curpos].e) { //swap parent and child
</span><span class="line">            VCNode temp = nodes[parent];
</span><span class="line">            nodes[parent] = nodes[curpos];
</span><span class="line">            nodes[curpos] = temp;
</span><span class="line">        } else {
</span><span class="line">            break; //no longer level up!!!
</span><span class="line">        }
</span><span class="line">        curpos = parent; //when curpos=parent=0, exit!!!
</span><span class="line">        parent = (curpos - 1) / 2; //relocate the parent position
</span><span class="line">    }
</span><span class="line">}
</span><span class="line">VCNode Minheap::popmin() {
</span><span class="line">    VCNode node;
</span><span class="line">    if (nodes.size() &gt; 0) { //have nodes left
</span><span class="line">        node = nodes[0]; //get the first element
</span><span class="line">        nodes.erase(nodes.begin()); //remove the first element
</span><span class="line">        if (nodes.size() &gt; 0) { //at least have one element more
</span><span class="line">            VCNode last = nodes[nodes.size() - 1]; //get the last element
</span><span class="line">            nodes.pop_back(); //pop the last element
</span><span class="line">            nodes.insert(nodes.begin(), last); //put it in the first place
</span><span class="line">            int csize = (int)nodes.size(); //current size
</span><span class="line">            int curpos = 0; //current position
</span><span class="line">            
</span><span class="line">            // rebuild the minheap
</span><span class="line">            while (curpos &lt; (csize / 2)) { //reach to the last parent node!!
</span><span class="line">                int left = 2 * curpos + 1; //left child
</span><span class="line">                int right = 2 * curpos + 2; //right child
</span><span class="line">                int min = left; //min store the min child
</span><span class="line">                if (right &lt; csize) { //have left and right childs
</span><span class="line">                    if (nodes[right].e &lt; nodes[left].e) {
</span><span class="line">                        min = right;
</span><span class="line">                    }
</span><span class="line">                }
</span><span class="line">                if (min &lt; csize) { //min child exist!!
</span><span class="line">                    if (nodes[min].e &lt; nodes[curpos].e) { //need to swap current position with child
</span><span class="line">                        VCNode temp = nodes[min];
</span><span class="line">                        nodes[min] = nodes[curpos];
</span><span class="line">                        nodes[curpos] = temp;
</span><span class="line">                    }else { //min child no exits!! exit!!
</span><span class="line">                        break; //can break now!!
</span><span class="line">                    }
</span><span class="line">                }
</span><span class="line">                curpos = min;
</span><span class="line">            }
</span><span class="line">        }
</span><span class="line">    }
</span><span class="line">    return node;
</span><span class="line">}
</span><span class="line">//void Minheap::print() {
</span><span class="line">//  cout &lt;&lt; "print heap" &lt;&lt; endl;
</span><span class="line">//  for (int i = 0; i &lt; (int)nodes.size(); i++) {
</span><span class="line">//      cout &lt;&lt; "edge: " &lt;&lt; nodes[i].e &lt;&lt; " node: " &lt;&lt; nodes[i].p &lt;&lt; endl;
</span><span class="line">//  }
</span><span class="line">//  cout &lt;&lt; "heap end" &lt;&lt; endl;
</span><span class="line">//}
</span><span class="line">// print array
</span><span class="line">void printArray(int a[], int start, int end){
</span><span class="line">    if (INDEBUG) {
</span><span class="line">        cout &lt;&lt; "print array form " &lt;&lt; start &lt;&lt; " to " &lt;&lt; end &lt;&lt; endl;
</span><span class="line">        for (int i=start; i&lt;=end; i++) {
</span><span class="line">            cout &lt;&lt; a[i] &lt;&lt; " ";
</span><span class="line">        }
</span><span class="line">        cout &lt;&lt; endl &lt;&lt; "print array end" &lt;&lt; endl;
</span><span class="line">    }
</span><span class="line">}
</span><span class="line">// print the graph
</span><span class="line">void printGraph(int graph[][MAX_NODE]){
</span><span class="line">    if (INDEBUG) {
</span><span class="line">        for(int i=1;i&lt;=n;i++){//0 no need
</span><span class="line">            for(int j=1;j&lt;=n;j++){
</span><span class="line">                cout &lt;&lt; graph[i][j] &lt;&lt; " ";
</span><span class="line">            }
</span><span class="line">            cout &lt;&lt; endl;
</span><span class="line">        }
</span><span class="line">    }
</span><span class="line">}
</span><span class="line">// partition function for quick sort
</span><span class="line">int partition2(int a[], int low, int high, int b[]){
</span><span class="line">    int key = a[high];
</span><span class="line">    int i=low-1;
</span><span class="line">    for (int j=low; j&lt;high; j++) {
</span><span class="line">        if (a[j]&gt;=key) {
</span><span class="line">            i++;
</span><span class="line">            swap(a[i], a[j]);
</span><span class="line">            swap(b[i], b[j]);
</span><span class="line">        }
</span><span class="line">    }
</span><span class="line">    swap(a[high], a[i+1]);
</span><span class="line">    swap(b[high], b[i+1]);
</span><span class="line">    return i+1;
</span><span class="line">}
</span><span class="line">// quick sort
</span><span class="line">void quicksort2(int a[], int low, int high, int b[]) {
</span><span class="line">    if (low &lt; high) {
</span><span class="line">        int p = partition2(a,low,high, b);
</span><span class="line">        quicksort2(a, low, p-1, b);
</span><span class="line">        quicksort2(a, p+1, high, b);
</span><span class="line">    }
</span><span class="line">}
</span><span class="line">// sum of the first k elements with state==0!!!
</span><span class="line">int sumofkmax(int edges[], int p, int nodes[], int state[]){
</span><span class="line">    quicksort2(edges, 1, n, nodes);
</span><span class="line">    int sum=0,count=0;
</span><span class="line">    // edges[i] corresponse to nodes[i], its state is state[nodes[i]]
</span><span class="line">    for(int i=1;i&lt;=n;i++){//attention to i range!!
</span><span class="line">        if (state[nodes[i]]==0) {
</span><span class="line">            sum+=edges[i];
</span><span class="line">            count++;
</span><span class="line">            if (count == p) {//enough!
</span><span class="line">                break;
</span><span class="line">            }
</span><span class="line">        }
</span><span class="line">    }
</span><span class="line">    return sum;
</span><span class="line">}
</span><span class="line">// verify the current node can be achievable
</span><span class="line">bool verify(int edges[], int p, int e, int nodes[], int state[]){
</span><span class="line">    //caculate the sum of the first p max elements in array edges!!
</span><span class="line">    int sum = sumofkmax(edges, p, nodes, state);
</span><span class="line">    // edge of nodes[i] is edges[i]!!!
</span><span class="line">    if(sum &gt;= e){// may be this can be achieved
</span><span class="line">        return true;
</span><span class="line">    }
</span><span class="line">    return false;
</span><span class="line">}
</span><span class="line">// build the index of node in array [index]
</span><span class="line">void buildIndex(int node[],int index[]){
</span><span class="line">    for (int i=1; i&lt;=n; i++) {
</span><span class="line">        index[node[i]] = i;
</span><span class="line">    }
</span><span class="line">}
</span><span class="line">// get the next node: state==0 &amp;&amp; order first!!!
</span><span class="line">int nextNode(int state[], int nodes[]){
</span><span class="line">    for (int i=1; i&lt;=n; i++) {
</span><span class="line">        if (state[nodes[i]]==0) {
</span><span class="line">            return nodes[i];
</span><span class="line">        }
</span><span class="line">    }
</span><span class="line">    return -1;
</span><span class="line">}
</span><span class="line">// generate the left child
</span><span class="line">VCNode genLeft(VCNode curnode, int label){
</span><span class="line">    VCNode left;//choose node label!
</span><span class="line">    left.p = curnode.p - 1;//remove one node
</span><span class="line">    left.e = curnode.e;
</span><span class="line">    for (int i=0; i&lt;=n; i++) {//first copy all infos
</span><span class="line">        left.index[i]=curnode.index[i];
</span><span class="line">        left.state[i]=curnode.state[i];//init node state
</span><span class="line">        left.edge[i]=curnode.edge[i];//copy edge info
</span><span class="line">        left.node[i]=curnode.node[i];//copy node info
</span><span class="line">//        for (int j=0; j&lt;=n; j++) {
</span><span class="line">//            left.graph[i][j] = curnode.graph[i][j];
</span><span class="line">//        }
</span><span class="line">    }
</span><span class="line">    // following code will not use curnode anymore!!
</span><span class="line">    
</span><span class="line">    
</span><span class="line">    ///
</span><span class="line">    int sum=0;//removed edge
</span><span class="line">    for (int j=1; j&lt;=n; j++) {
</span><span class="line">        //new
</span><span class="line">        if (label &lt; j &amp;&amp; left.state[j]!=1 &amp;&amp; graph[label][j]==1 ) {//row!
</span><span class="line">            sum++;
</span><span class="line">//            left.graph[label][j]=0;
</span><span class="line">            left.edge[left.index[j]]--;//how to cut it down
</span><span class="line">        }else if(label &gt; j &amp;&amp; left.state[j]!=1 &amp;&amp; graph[j][label]==1 ){ // col
</span><span class="line">            sum++;
</span><span class="line">//            left.graph[j][label]=0;
</span><span class="line">            left.edge[left.index[j]]--;//how to cut it down
</span><span class="line">        }
</span><span class="line">    }
</span><span class="line">    ///
</span><span class="line">    
</span><span class="line">    left.state[label] = 1;//use label directly!
</span><span class="line">    left.edge[left.index[label]] = 0;//only use index!!
</span><span class="line">//    cout &lt;&lt; "remove edge sum is " &lt;&lt; sum &lt;&lt; endl;
</span><span class="line">    quicksort2(left.edge, 1, n, left.node);
</span><span class="line">    left.e = left.e - sum;//remove some edges
</span><span class="line">    buildIndex(left.node, left.index);
</span><span class="line">    
</span><span class="line">    if (INDEBUG) {
</span><span class="line">        cout &lt;&lt; "======== " &lt;&lt; label &lt;&lt; " gen left begin===========" &lt;&lt; endl;
</span><span class="line">        cout &lt;&lt; "edge is " &lt;&lt; left.e &lt;&lt; " node is " &lt;&lt; left.p &lt;&lt; endl;
</span><span class="line">        cout &lt;&lt; "array edge:" &lt;&lt; endl;
</span><span class="line">        printArray(left.edge,1,n);
</span><span class="line">        cout &lt;&lt; "array node:" &lt;&lt; endl;
</span><span class="line">        printArray(left.node, 1, n);
</span><span class="line">        cout &lt;&lt; "array index:" &lt;&lt; endl;
</span><span class="line">        printArray(left.index, 1, n);
</span><span class="line">        cout &lt;&lt; "array state:" &lt;&lt; endl;
</span><span class="line">        printArray(left.state, 1, n);
</span><span class="line">//        printGraph(left.graph);
</span><span class="line">        cout &lt;&lt; "======== " &lt;&lt; label &lt;&lt; " gen left end===========" &lt;&lt; endl;
</span><span class="line">    }
</span><span class="line">    
</span><span class="line">    return left;
</span><span class="line">}
</span><span class="line">// generate the right child
</span><span class="line">VCNode genRight(VCNode curnode, int label){
</span><span class="line">    VCNode right;//choose node label!
</span><span class="line">    right.p = curnode.p;//remain
</span><span class="line">    right.e = curnode.e;
</span><span class="line">    for (int i=0; i&lt;=n; i++) {//first copy all infos
</span><span class="line">        right.index[i]=curnode.index[i];
</span><span class="line">        right.state[i]=curnode.state[i];//init node state
</span><span class="line">        right.edge[i]=curnode.edge[i];//copy edge info
</span><span class="line">        right.node[i]=curnode.node[i];//copy node info
</span><span class="line">//        for (int j=0; j&lt;=n; j++) {
</span><span class="line">//            right.graph[i][j] = curnode.graph[i][j];
</span><span class="line">//        }
</span><span class="line">    }
</span><span class="line">    // following code will not use curnode anymore!!
</span><span class="line">    right.state[label] = -1;//use label directly!
</span><span class="line">    
</span><span class="line">    if (INDEBUG) {
</span><span class="line">        cout &lt;&lt; "======== " &lt;&lt; label &lt;&lt; " gen right begin===========" &lt;&lt; endl;
</span><span class="line">        cout &lt;&lt; "edge is " &lt;&lt; right.e &lt;&lt; " node is " &lt;&lt; right.p &lt;&lt; endl;
</span><span class="line">//        cout &lt;&lt; "array edge:" &lt;&lt; endl;
</span><span class="line">//        printArray(right.edge,1,n);
</span><span class="line">//        cout &lt;&lt; "array node:" &lt;&lt; endl;
</span><span class="line">//        printArray(right.node, 1, n);
</span><span class="line">//        cout &lt;&lt; "array index:" &lt;&lt; endl;
</span><span class="line">//        printArray(right.index, 1, n);
</span><span class="line">//        cout &lt;&lt; "array state:" &lt;&lt; endl;
</span><span class="line">//        printArray(right.state, 1, n);
</span><span class="line">//        printGraph(right.graph);
</span><span class="line">        cout &lt;&lt; "======== " &lt;&lt; label &lt;&lt; " gen right end===========" &lt;&lt; endl;
</span><span class="line">    }
</span><span class="line">    
</span><span class="line">    return right;
</span><span class="line">}
</span><span class="line">// greedy find a way to solve VCP
</span><span class="line">void greedyFind(int edges[], int nodes[]/*, int graph[][MAX_NODE]*/){
</span><span class="line">    VCNode node;
</span><span class="line">    node.e = m;
</span><span class="line">    node.p = k;
</span><span class="line">    
</span><span class="line">    for (int i=0; i&lt;=n; i++) {
</span><span class="line">        node.index[i]=0;
</span><span class="line">        node.state[i]=0;//init node state
</span><span class="line">        node.edge[i]=edges[i];//copy edge info
</span><span class="line">        node.node[i]=nodes[i];//copy node info
</span><span class="line">//        for (int j=0; j&lt;=n; j++) {
</span><span class="line">//            node.graph[i][j] = graph[i][j];
</span><span class="line">//        }
</span><span class="line">    }
</span><span class="line">    buildIndex(node.node, node.index);
</span><span class="line">    
</span><span class="line">    Minheap minheap;
</span><span class="line">    minheap.insert(node);
</span><span class="line">    
</span><span class="line">    while (minheap.nodes.size() &gt; 0) {
</span><span class="line">        // get the heap top node to extend
</span><span class="line">        VCNode curnode = minheap.popmin();
</span><span class="line">        
</span><span class="line">//        if (INDEBUG) {
</span><span class="line">//            cout &lt;&lt; "...current graph..." &lt;&lt; endl;
</span><span class="line">//            printGraph(curnode.graph);
</span><span class="line">//        }
</span><span class="line">        
</span><span class="line">        // validate the current node
</span><span class="line">        if (curnode.e == 0) {
</span><span class="line">            int points = k - curnode.e;
</span><span class="line">            cout &lt;&lt; points &lt;&lt; endl;
</span><span class="line">            int count = 1;
</span><span class="line">            for (int i=1; i&lt;=n; i++) {
</span><span class="line">                if (curnode.state[i]==1) {
</span><span class="line">                    if(count == points){
</span><span class="line">                        cout &lt;&lt; i;
</span><span class="line">                    }else{
</span><span class="line">                        cout &lt;&lt; i &lt;&lt; " ";
</span><span class="line">                    }
</span><span class="line">                    count++;
</span><span class="line">                }
</span><span class="line">            }
</span><span class="line">            cout &lt;&lt; endl;
</span><span class="line">            return;
</span><span class="line">        }
</span><span class="line">        
</span><span class="line">        // generate child nodes
</span><span class="line">        int label = nextNode(curnode.state, curnode.node);//the label of the node
</span><span class="line">        if (label != -1) {
</span><span class="line">            // node i is in index[k] position in array [node]
</span><span class="line">            // node i has number of edge[i] edges
</span><span class="line">            VCNode left = genLeft(curnode, label);
</span><span class="line">            VCNode right = genRight(curnode, label);
</span><span class="line">            if (verify(left.edge, left.p, left.e, left.node, left.state)) {
</span><span class="line">//                cout &lt;&lt; "insert " &lt;&lt; label &lt;&lt; " left" &lt;&lt; endl;
</span><span class="line">                minheap.insert(left);
</span><span class="line">            }
</span><span class="line">            if (verify(right.edge, right.p, right.e, right.node, right.state)) {
</span><span class="line">//                cout &lt;&lt; "insert " &lt;&lt; label &lt;&lt; " right" &lt;&lt; endl;
</span><span class="line">                minheap.insert(right);
</span><span class="line">            }
</span><span class="line">        }
</span><span class="line">        
</span><span class="line">    }
</span><span class="line">    
</span><span class="line">    // if not find, then return -1
</span><span class="line">    cout &lt;&lt; -1 &lt;&lt; endl;
</span><span class="line">    
</span><span class="line">}
</span><span class="line">int main() {
</span><span class="line">//    freopen("/Volumes/hujiawei/Users/hujiawei/workspace/appleworkspace/algorithmworks/Exp1-2/Exp1-2/in3.txt", "rt", stdin);//
</span><span class="line">    cin &gt;&gt; t;
</span><span class="line">    while(t--&gt;0){
</span><span class="line">        cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
</span><span class="line">//        int graph[n+1][MAX_NODE];
</span><span class="line">        for (int i=0; i&lt;= n; i++) {
</span><span class="line">            for (int j=0; j&lt;= n; j++) {
</span><span class="line">                graph[i][j]=0;
</span><span class="line">            }
</span><span class="line">        }
</span><span class="line">        int edges[n+1], nodes[n+1], state[n+1];
</span><span class="line">        for (int i=0; i&lt;= n; i++) {
</span><span class="line">            edges[i]=0;
</span><span class="line">            state[i]=0;
</span><span class="line">            nodes[i]=i;
</span><span class="line">        }
</span><span class="line">        int temp = m;
</span><span class="line">        while(temp--&gt;0){
</span><span class="line">            cin &gt;&gt; a &gt;&gt; b;
</span><span class="line">            graph[min(a, b)][max(a,b)]=1;
</span><span class="line">//          graph[a][b]=1;
</span><span class="line">//          graph[b][a]=1;//just save half a&lt;=b
</span><span class="line">            edges[a]++;
</span><span class="line">            edges[b]++;
</span><span class="line">        }
</span><span class="line">        bool flag = verify(edges, k, m, nodes, state);
</span><span class="line">        
</span><span class="line">        if (!flag) {//must not be achieved!!!
</span><span class="line">            cout &lt;&lt; -1 &lt;&lt; endl;
</span><span class="line">        }else{
</span><span class="line">            greedyFind(edges,nodes/*,graph*/);
</span><span class="line">        }
</span><span class="line">    }
</span><span class="line">    
</span><span class="line">    return 0;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>
<p class="post-footer">
                        Original link:<a href="http://hujiaweibujidao.github.io/blog/2014/04/13/vertext-cover-problem/">http://hujiaweibujidao.github.io/blog/2014/04/13/vertext-cover-problem/</a><br />Written by <a href="http://hujiaweibujidao.github.io">hujiawei</a>&nbsp;Posted at <a href="http://hujiaweibujidao.github.io">http://hujiaweibujidao.github.io</a><br />Feel free to read or comment it, and if you want to copy it into your own site, please copy it with its Original Link showed above or you can see the license below for more details.<br />Thanks a lot. Hope you enjoy here! :-)</p>
</div>


		<footer>
			<p class="meta">
				
  

<span class="byline author vcard">Posted by <span class="fn">hujiawei</span></span>

				








  


<time datetime="2014-04-13T23:57:00+08:00" pubdate data-updated="true">Apr 13<span>th</span>, 2014</time>
				

<span class="categories">
  
    <a class='category' href='/blog/categories/algorithm/'>algorithm</a>
  
</span>


			</p>
			
			<div class="sharing">
  
  
  
</div>

			
			<p class="meta">
				
				<a class="basic-alignment left" href="/blog/2014/04/09/leetcode-oj-part1/" title="Previous Post: LeetCode OJ Part1">&laquo; LeetCode OJ Part1</a>
				
				
				<a class="basic-alignment right" href="/blog/2014/04/15/flying-on-mac/" title="Next Post: Mou and StackEdit and Mathjax">Mou and StackEdit and Mathjax &raquo;</a>
				
			</p>
		</footer>
	</article>
	

	
	<section>
		<h1>Comments</h1>
		<div id="comments" aria-live="polite">
			<!-- Duoshuo Comment BEGIN   data-title=""-->
<div class="ds-thread"></div>
<script type="text/javascript">
  var duoshuoQuery = {short_name:"hujiaweibujidao"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script>
<!-- Duoshuo Comment END -->

		</div>
	</section>
	
</div>

<aside class="sidebar">
  
	<section>
	<h1>关于博主</h1><br/>
  <a href="/aboutme/"><img src="/images/me-small.png" width="250px" height="210px" alt="protrait"/></a><br/>
  <p>Hi, I'm Hujiawei, from P.R.China. Now I'm a postgraduate student studying in <a href="http://www.tsinghua.edu.cn/publish/th/index.html">Tsinghua University</a>.
  Wanna know me? <a href="/aboutme/">See here.</a> 
  </p>
  
  <img src="/images/conan-mainperson.png" width="250px" height="210px" alt="conan"/>
  
  <br/>
  
    <a href="http://weibo.com/hujiaweiyinger"><img src="/images/sinaweibo.png" width="40px" height="40px"/></a> &nbsp;
  <a href="https://github.com/hujiaweibujidao"><img src="/images/github.png" width="40px" height="40px"/></a>&nbsp;
  <a href="http://hujiawei.tumblr.com"><img src="/images/tumblr.png" width="40px" height="40px"/></a> &nbsp;
  <a href="https://twitter.com/hujiaweiyinger"><img src="/images/twitter.png" width="40px" height="40px"/></a>&nbsp;
  <a href="http://www.douban.com/people/60272837/"><img src="/images/douban.png" width="40px" height="40px"/></a>
 
 <br/>
    
    <!--autoplay="autoplay" -->
    <!--
<audio width="200" height="32" 
style="margin: auto; top: 0; right: 0; bottom: 0; left: 0;" 
controls="controls" 
name="media" 
src="http://hujiaweibujidao.github.io/music/Wouldnt-It-Be-Nice.mp3">
</audio>
-->
  
  
  <!--baidu-->
  <!--
  <div class="bdsharebuttonbox"><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a><a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网"></a><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a><a href="#" class="bds_tqq" data-cmd="tqq" title="分享到腾讯微博"></a><a href="#" class="bds_renren" data-cmd="renren" title="分享到人人网"></a><a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a><a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a></div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"1","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>  
-->

</section>
<section>
 <h1>分类目录</h1>
 <ul id="categories">
	 <li class='category'><a href='/blog/categories/algorithm/'>algorithm (10)</a></li>
<li class='category'><a href='/blog/categories/android/'>android (5)</a></li>
<li class='category'><a href='/blog/categories/hadoop/'>hadoop (1)</a></li>
<li class='category'><a href='/blog/categories/ios/'>ios (1)</a></li>
<li class='category'><a href='/blog/categories/mac/'>mac (2)</a></li>
<li class='category'><a href='/blog/categories/math/'>math (17)</a></li>
<li class='category'><a href='/blog/categories/matlab/'>matlab (1)</a></li>
<li class='category'><a href='/blog/categories/mobiledev/'>mobiledev (5)</a></li>
<li class='category'><a href='/blog/categories/music/'>music (2)</a></li>
<li class='category'><a href='/blog/categories/octopress/'>octopress (4)</a></li>
<li class='category'><a href='/blog/categories/opencv/'>opencv (5)</a></li>
<li class='category'><a href='/blog/categories/picture/'>picture (1)</a></li>
<li class='category'><a href='/blog/categories/python/'>python (2)</a></li>

 </ul>
</section>
<section>
  <h1>近期文章</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/05/18/love-you/">Love You</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/05/16/python-tips2/">Python Advances</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/05/12/hadoop-installation/">Hadoop Installation - Single Node Setup</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/05/12/algorithms-pagerank/">Algorithms-PageRank</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/05/10/happy-mothers-day/">Happy Mother's Day</a>
      </li>
    
  </ul>
</section>
<section>
	<h1>好友博客</h1>
	<ul>
		<li>
			<a href="http://doufunao.github.io/">豆腐脑的幻想乡</a>
		</li>
		<li>
			<a href="http://c4fun.cn/">Code 4 Fun</a>
		</li>
		<li>
			<a href="http://www.tanglei.name/">TangLei blog</a>
		</li>
		<li>
			<a href="http://ontheroad.sinaapp.com/">Tian Jun-Find My Way</a>
		</li>
		
		<li>
			<a href="http://www.liaoxuefeng.com/">廖雪峰的官方网站</a>
		</li>
		<li>
			<a href="http://wufawei.com/">Ted's Homepage</a>
		</li>
		<li>
			<a href="http://www.renfei.org/blog/">Renfei Song</a>
		</li>
		<li>
			<a href="http://bluedavy.me">BlueDavy之技术blog</a>
		</li>
		
		<li>
			<a href="#">这里会是你吗?</a>
		</li>
	</ul>
</section>
	
</aside>


		</div>
	</div>
	
	<footer role="contentinfo">
		<p>
  	Copyright &copy; 2014 - hujiawei - <a href="http://hujiaweibujidao.github.io/happybirthday/">Happy birthday to MY QUEEN</a> - <span class="credit">Proudly Powered by <a href="http://octopress.org">Octopress</a></span>
  	
<!-- mathjax config similar to math.stackexchange  -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  jax: ["input/TeX", "output/HTML-CSS"],
  tex2jax: {
    inlineMath: [ ['$', '$'] ],
    displayMath: [ ['$$', '$$']],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  messageStyle: "none",
  "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
});
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>

<!-- the following line is incorrect! -->
<!--
<script type="text/javascript" src="https://stackedit.io/libs/MathJax/MathJax.js?config=TeX-AMS_HTML"></script>
-->

<!--baidu-->
<!--
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"1","bdPos":"left","bdTop":"250"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>
-->

	<!-- CNZZ -->
	&nbsp;&nbsp;
	<script type="text/javascript">
		var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
		document.write(unescape("%3Cspan id='cnzz_stat_icon_1000165127'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s22.cnzz.com/z_stat.php%3Fid%3D1000165127%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
	</script>
	
	<!--baidu share-->
	<!--
	<div class="bdsharebuttonbox" style="display: inline;"><a href="#" class="bds_more" data-cmd="more"></a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a><a href="#" class="bds_tqq" data-cmd="tqq" title="分享到腾讯微博"></a><a href="#" class="bds_renren" data-cmd="renren" title="分享到人人网"></a><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a></div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"1","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>
	-->
	<!-- license -->
	<a rel="license" href="http://creativecommons.org/licenses/by-nd/3.0/deed.zh"><img alt="知识共享许可协议" style="border-width:0" src="http://i.creativecommons.org/l/by-nd/3.0/88x31.png" /></a>
	本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nd/3.0/deed.zh">知识共享署名-禁止演绎 3.0 未本地化版本许可协议</a>进行许可。

</p>

<!--hujiawei custom blockquote-->
<!--for block quote
<style>
blockquote{
	font:inherit;
	font-size:60%;
	font-style:normal;
	line-height:1.0em;
	color:rgba(0,0,0,0.5);
}
</style>-->

<!-- gutter for code line-numbers!! -->
<!--for block quote-->
<!--
<style>
blockquote{
	font:inherit;
	font-size:60%;
	font-style:normal;
	line-height:1.0em;
	color:rgba(0,0,0,0.5);
}

.gutter{
	display: none;
}

.highlight, .gist-highlight {
margin-bottom: 1.8em;
background: #002b36;
overflow-y: hidden;
overflow-x: auto;
}
</style>
-->

<!--return to top-->
<style>
	.returnTop {
		position: fixed;
		_position: absolute;
		right: 10px;
		bottom: 200px;
		_bottom: auto;
		display: none;
		width: 40px;
		height: 40px;
		border: 1px solid #61b72e;
		border-radius: 4px;
		background: #fff;
		box-shadow: 0 0 5px #F5F5F5;
		text-indent: -9999px;
		cursor: pointer;
	}
	.returnTop .s {
		position: absolute;
		top: -2px;
		_top: -20px;
		left: 10px;
		width: 0;
		height: 0;
		border-width: 10px;
		border-color: transparent transparent #61b72e;
		border-style: dashed dashed solid;
	}
	.returnTop .b {
		position: absolute;
		top: 18px;
		left: 16px;
		height: 12px;
		width: 8px;
		background: #61b72e;
	}
</style>
<div class="returnTop" title="嗖的就上去了！">
	<span class="s"></span>
	<span class="b"></span>
	返回顶部
</div>
<script type="text/javascript">
$(function(){
$(window).bind("scroll", function(){

var scrollTopNum = $(document).scrollTop(),
winHeight = $(window).height(),
returnTop = $("div.returnTop");

(scrollTopNum > 0) ? returnTop.fadeIn("fast") : returnTop.fadeOut("fast");

if (!-[1,]&&!window.XMLHttpRequest) {
returnTop.css("top", scrollTopNum + winHeight - 200);
}

});

$("div.returnTop").click(function() {
$("html, body").animate({ scrollTop: 0 }, 100);
});

});
</script>

	</footer>
	
	













</body>
</html>
