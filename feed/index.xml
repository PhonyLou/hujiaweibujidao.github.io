<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Hujiawei Bujidao]]></title>
  <link href="http://hujiaweibujidao.github.io/feed" rel="self"/>
  <link href="http://hujiaweibujidao.github.io/"/>
  <updated>2014-04-24T18:43:59+08:00</updated>
  <id>http://hujiaweibujidao.github.io/</id>
  <author>
    <name><![CDATA[hujiawei]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Calculus Summary]]></title>
    <link href="http://hujiaweibujidao.github.io/blog/2014/04/24/calculus-summary/"/>
    <updated>2014-04-24T08:40:00+08:00</updated>
    <id>http://hujiaweibujidao.github.io/blog/2014/04/24/calculus-summary</id>
    <content type="html"><![CDATA[<script type="text/javascript" src="https://stackedit.io/libs/MathJax/MathJax.js?config=TeX-AMS_HTML"></script>


<h2><center>微积分总结</center></h2>

<p>[TOC]</p>

<h3><center>第零部分 碎碎念</center></h3>

<p>到了研究生阶段才意识到本科的数学原来作用这么大，不论是在数据挖掘，还是机器学习，亦或是模式识别，数学都是基础中的基础。于是乎，我在逸夫图书馆泡了几天看了些微积分、线代和数理统计的书籍，写下三份总结，记录下重要的知识，以备后忘。本人才疏学浅，若有错误之处还请指出，让我“增长”，若有不足也请指出，使我“完备”，谢谢！:&ndash;)</p>

<p><strong>[注：这些总结不会详细地讲解所有概念，只是挑选一些我个人感觉比较有用的知识点进行总结，很多时候可能只是列举知识点，并无解释，忘记了的可以自行Wiki或者翻书，另外，为了节省写作时间，我剪切粘贴了很多图片&hellip;嗯，就是这样&hellip;]</strong></p>

<p>参考书籍：</p>

<p>1.<a href="http://book.douban.com/subject/2112359/">同济大学 高等数学 高等教育出版社</a></p>

<p>2.<a href="http://product.dangdang.com/23311529.html">高等数学 中国环境出版社</a></p>

<h3><center>第一部分 函数与极限 </center></h3>

<h4>第一节 函数</h4>

<p>集合、区间与邻域，函数的概念与性质，反函数与复合函数，初等函数</p>

<p>关于<a href="http://zh.wikipedia.org/wiki/%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0">初等函数 on wiki</a>，初等函数在其定义域内都是连续的。</p>

<p><img src="http://hujiaweibujidao.github.io/images/math/elementalfuns.png" title="elementalfuns.png" alt="image" /></p>

<p>关于指数函数：
对于相等间隔的自变量x的取值，指数函数对应值的比例为常数。由指数运算法则可知，对任意的x，只要给定$x<em>{0}>0$，则$a^{x+x</em>{0}}/a^{x}=a^{x_{0}}$恒成立。此性质可以作为判断两个变量之间的关系是否为指数函数关系的主要依据。此外，这个性质导出了数理统计中的指数分布。</p>

<h4>第二节 函数的极限</h4>

<p>数列极限及性质，函数极限及性质，无穷小与无穷大，极限运算法则，极限存在准则和两个重要极限，无穷小的比较</p>

<p>关于收敛数列(极限存在)有两个性质：唯一性和有界性</p>

<p>关于函数极限，注意，$x \to x{0}$的极限是否存在与函数在$x_{0}$是否有定义无关。<a href="http://hujiaweibujidao.github.io/images/math/fun_limit.png" title="fun_limit.png">函数极限的定义</a></p>

<!--![image](http://hujiaweibujidao.github.io/images/math/elementalfuns.png)-->


<p>函数极限的几何意义是，当x在领域$(x<em>{0}&ndash;\delta,x</em>{0}+\delta)$内时，函数值y落在下图中$(A-\varepsilon,A+\varepsilon)$内。</p>

<p><img src="http://hujiaweibujidao.github.io/images/math/funlimit_meaning.png" title="funlimit_meaning.png" alt="function limit meaning" /></p>

<p>关于无穷小和无穷大：无穷小并不是指负无穷，而是函数在$x \to x{0}$时的极限为0，无穷小与有解变量的乘积还是无穷小，但是这个性质放在无穷大上面就不成立！例如，$\lim<em>{x \to +\infty} \frac{sinx}{x} = 0$是无穷小，但是$\lim</em>{x \to +\infty} xcosx$不是无穷小，它不符合无穷小的定义，<a href="http://www.guokr.com/post/469944/">关于这个问题的讨论</a>。</p>

<p>两个重要的极限：$\lim<em>{x \to 0} \frac{sinx}{x} = 1$ 和 $\lim</em>{x \to +\infty} (1+\frac{1}{x})^{x} = e$</p>

<p>关于极限$\lim_{x \to 0} \frac{sinx}{x} = 1$可用下图来解释，圆的边长是1，$BC=sinx, AD=tanx, \hat{AB}=x$，在$x \to 0$时，三者近似相等。</p>

<p><img src="http://hujiaweibujidao.github.io/images/math/sinxoverx.png" title="sinxoverx.png" alt="sinx over x" /></p>

<p>关于极限$\lim<em>{x \to \infty} (1+\frac{1}{x})^{x} = e$，注意，不论是$\lim</em>{x \to +\infty}$还是$\lim_{x \to &ndash;\infty}$都成立，它道出了自然对数$e$到底是什么！当然还有其他的方式表示出$e$，比如级数的方式，我认为$e$是数学界最美丽的符号！$e \approx 2.71828$</p>

<h4>第三节 函数的连续性与间断点</h4>

<p>函数的连续性，函数的间断点</p>

<p>函数的间断点分为两类：第一类是函数在$x=x_{0}$处间断，但是左右极限都存在，如果左右极限相等的话该间断点称为可去间断点，如果不相等称为跳跃间断点；其他情况下的间断点都属于第二类间断点。</p>

<h4>第四节 初等函数的连续性</h4>

<p>连续函数四则运算的连续性，反函数与复合函数的连续性，初等函数的连续性</p>

<h4>第五节 闭区间上连续函数的性质</h4>

<p>最大值和最小值定理，介值定理与零点定理</p>

<p>最大值和最小值定理就是说在闭区间上的连续函数f(x)一定是有上下界的；</p>

<p>介值定理就是说在闭区间上的连续函数f(x)，如果左右端点的取值不同，例如$f(a)=A,f(b)=B$，那么区间中肯定有一点的函数值能够取到$[A,B]$之间的任何一个值！</p>

<p>零点定理就是说在闭区间上的连续函数f(x)，如果左右端点的取值异号，例如$f(a)=A>0,f(b)=B&lt;0$，那么区间中肯定有一点的函数值为0！</p>

<h3><center>第二部分 导数与微分</center></h3>

<h4>第一节 导数概念</h4>

<p>引例，导数的定义，导数的几何意义，可导与连续的关系</p>

<p>导数的几何意义就是曲线在某点的切线的斜率，反应了变化的快慢，理解这个很重要，以及后面的偏导数的理解，它们最后都应用对一些算法的理解中，例如梯度下降算法，其实就是利用这个几何意义，让要优化的函数尽快地逼近局部最优解。</p>

<p><img src="http://hujiaweibujidao.github.io/images/math/deviration_meaning.png" title="deviration_meaning.png" alt="deviration_meaning.png" /></p>

<h4>第二节 函数的求导法则</h4>

<p>函数的和、差、积、商的求导法则，反函数的求导法则，复合函数的求导法则，基本求导法则与导数公式</p>

<p>关于反函数的求导法则：$\frac{dy}{dx}=\frac{1}{\frac{dx}{dy}}$</p>

<p>关于复合函数的求导法则：$\frac{dy}{dx}=\frac{dy}{du} \cdot \frac{du}{dx}$</p>

<p>关于基本初等函数求导法则</p>

<p><img src="http://hujiaweibujidao.github.io/images/math/deviration.png" alt="image" /></p>

<h4>第三节 高阶导数</h4>

<p>二阶及二阶以上的导数称为高阶导数</p>

<h4>第四节 隐函数及其参数方程所确定的函数的导数</h4>

<p>隐函数的导数，由参数方程所确定的函数的导数</p>

<p>如果方程$F(x,y)=0$确定了$y$是$x$的函数，那么这样的函数就叫做隐函数。一般它的求导分为两种方法：(1)如果能够解出$y=f(x)$关系式的话，就先解出然后求导；(2)如果不能解出，那么就利用复合函数求导方式进行求导。</p>

<h4>第五节 函数的微分</h4>

<p>微分的定义，微分的几何意义，基本微分公式与微分法则，微分形式的不变性，微分的应用</p>

<p>先看看微分是怎么引入的？</p>

<p><img src="http://hujiaweibujidao.github.io/images/math/weifen.png" alt="image" /></p>

<p>就是说，在实际应用中，常常需要知道当自变量x有细微变化的时候，函数y的变化量$\vartriangle y$是多少？为了方便计算，需要将增量表达式线性化处理，从而计算出$\vartriangle y$的近似值。如上面所示，我们只需要用$A \vartriangle x$来近似代替$\vartriangle y$。</p>

<p>微分的几何意义，这其实是数学中常用的非线性函数的局部线性化，这里是利用曲线的切线段来近似代替曲线段。</p>

<p><img src="http://hujiaweibujidao.github.io/images/math/weifen_meaning.png" alt="image" /></p>

<p>  <p class='post-footer'></p>

<pre><code>                    Original link:&lt;a href='http://hujiaweibujidao.github.io/blog/2014/04/24/calculus-summary/'&gt;http://hujiaweibujidao.github.io/blog/2014/04/24/calculus-summary/&lt;/a&gt;&lt;br/&gt;Written by &lt;a href='http://hujiaweibujidao.github.io'&gt;hujiawei&lt;/a&gt;&amp;nbsp;Posted at &lt;a href='http://hujiaweibujidao.github.io'&gt;http://hujiaweibujidao.github.io&lt;/a&gt;&lt;br/&gt;Feel free to read or comment it, and if you want to copy it into your own site, please copy it with its Original Link showed above or you can see the license below for more details.&lt;br /&gt;Thanks a lot. Hope you enjoy here! ^_^&lt;/p&gt;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Numerical Methods using Matlab]]></title>
    <link href="http://hujiaweibujidao.github.io/blog/2014/04/23/numerical-methods-using-matlab/"/>
    <updated>2014-04-23T22:13:00+08:00</updated>
    <id>http://hujiaweibujidao.github.io/blog/2014/04/23/numerical-methods-using-matlab</id>
    <content type="html"><![CDATA[<p>一本关于数值算法与应用的总结小书</p>

<p>目前写了四个章节：[点击章节标题可以直接查看并下载 (^o^)/~]</p>

<ul>
<li><a href="http://hujiaweibujidao.github.io/files/nm-chapter1.pdf">第一章 线性方程组求解</a></li>
</ul>


<p>内容包括：高斯消去法，LU分解，Cholesky分解，矩阵的逆矩阵求解</p>

<ul>
<li><a href="http://hujiaweibujidao.github.io/files/nm-chapter2.pdf">第二章 非线性方程求解</a></li>
</ul>


<p>内容包括：二分法，牛顿法，割线法，IQI法，Zeroin算法</p>

<ul>
<li><a href="http://hujiaweibujidao.github.io/files/nm-chapter3.pdf">第三章 矩阵特征值和奇异值求解</a></li>
</ul>


<p>内容包括：基本幂法，逆幂法和移位幂法，QR分解，Householder变换，实用QR分解技术，奇异值分解SVD</p>

<ul>
<li><a href="http://hujiaweibujidao.github.io/files/nm-chapter4.pdf">第四章 曲线拟合和多项式插值</a></li>
</ul>


<p>内容包括：曲线拟合，拉格朗日插值多项式，牛顿插值多项式，分段线性插值，保形分段三次插值，三次样条插值</p>

<p><img src="http://hujiaweibujidao.github.io/images/201311/nm-cover.png" width="600" height="600" title="" >
<img src="http://hujiaweibujidao.github.io/images/201311/nm-chapter.png" width="600" height="600" title="" >
<img src="http://hujiaweibujidao.github.io/images/201311/nm-math.png" width="600" height="600" title="" >
<img src="http://hujiaweibujidao.github.io/images/201311/nm-code.png" width="600" height="600" title="" ></p>

<p class='post-footer'>
                        Original link:<a href='http://hujiaweibujidao.github.io/blog/2014/04/23/numerical-methods-using-matlab/'>http://hujiaweibujidao.github.io/blog/2014/04/23/numerical-methods-using-matlab/</a><br/>Written by <a href='http://hujiaweibujidao.github.io'>hujiawei</a>&nbsp;Posted at <a href='http://hujiaweibujidao.github.io'>http://hujiaweibujidao.github.io</a><br/>Feel free to read or comment it, and if you want to copy it into your own site, please copy it with its Original Link showed above or you can see the license below for more details.<br />Thanks a lot. Hope you enjoy here! ^_^</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[probability and statistics summary]]></title>
    <link href="http://hujiaweibujidao.github.io/blog/2014/04/22/probability-and-statistics-summary/"/>
    <updated>2014-04-22T00:06:00+08:00</updated>
    <id>http://hujiaweibujidao.github.io/blog/2014/04/22/probability-and-statistics-summary</id>
    <content type="html"><![CDATA[<h3><center>概率与数理统计总结</center></h3>

<hr />

<p>[TOC]</p>

<h4><center><strong>第零部分 碎碎念</strong></center></h4>

<p>本文是对概率和数理统计中的重要内容的一个小总结，不会侧重很多众所周知的细节，所以有啥疑问还是需要Google或者Wikipedia。关于本文中出现的术语参照参考书籍中的定义，部分可能与大学教材中不同，请自行对应起来理解。小弟才疏学浅，若有错误请留言，欢迎指正。</p>

<p>主要参考书籍：</p>

<p>1.<a href="http://book.douban.com/subject/2985995/">《爱上统计学》</a></p>

<p>2.<a href="http://book.douban.com/subject/7056708/">《深入浅出统计学》</a></p>

<p>3.<a href="http://book.douban.com/subject/24381562/">《统计思维：程序员数学之概率统计》</a></p>

<h4><center><strong>第一部分 概率</strong></center></h4>

<p>1.事件：对立事件(complementary event)，互斥事件(exclusive event)，相交事件(intersecting event)，相关事件(dependent event)，独立事件(independent event)，可以使用韦恩图(Venn Diagram)方便分析事件之间的关系。</p>

<p>如果事件A和B会相互影响，那么它们是相关事件，否则是独立事件。
事件A和B独立：$P(A|B)=P(A) \quad P(A \cap B)=P(A)P(B)$</p>

<p>2.概率：条件概率(Conditional Probability)，全概率(Total Probability)，贝叶斯定理(Bayes&#8217; Theorem)</p>

<p>条件概率：$P(A|B)=\frac{P(A \cap B)}{P(B)}$</p>

<p>全概率：$P(B)=P(B|A)P(A)+P(B|A&#8217;)P(A&#8217;)$</p>

<p>贝叶斯定理(将条件概率和全概率整合到一起)：$P(A|B)=\frac{P(A \cap B)}{P(B|A)P(A)+P(B|A&#8217;)P(A&#8217;)}$</p>

<p>3.期望(Expectation)与方差(Variance)</p>

<p>$E(x)=\Sigma xP(X=x) \quad Var(x)=E(x-\mu)^{2}=\Sigma (x-\mu)<sup>2P</sup>(X=x)=E(x^{2})&ndash;(E(x))^{2}$</p>

<p>线性变换之后的期望与方差：</p>

<p>$E(ax+b)=aE(x)+b \quad Var(ax+b)=a^{2}Var(x)$
$E(ax+by)=aE(x)+bE(y) \quad Var(ax+by)=a^{2}Var(x)+b^{2}Var(y)$</p>

<p><strong>思考：为什么加上b方差并没有发生变化呢？因为在变量中增加常数b只是将概率分布移动了一下，分布的形状并没有发生改变，所以b并没有在方差中起到作用。</strong></p>

<p>相互独立事件X和Y：</p>

<p>$E(X+Y)=E(X)+E(Y) \quad Var(X+Y)=Var(X)+Var(Y)$
$E(X-Y)=E(X)-E(Y) \quad Var(X-Y)=Var(X)+Var(Y)$</p>

<p><strong>思考：为什么$Var(X-Y)=Var(X)+Var(Y)$？可以随便拿数据验证之。[TODO]
记住，一个随机变量减去另一个随机变量得到的概率分布的方差是两个随机变量的方差之和，方差只会增加！下面两个图示演示了其结果
</strong></p>

<p><img src="varxplusy.png" alt="image" /></p>

<p><img src="varxminusy.png" alt="image" /></p>

<p>相互独立的随机变量与独立观测值之间的区别：</p>

<p><img src="independentobservation.png" alt="image" /></p>

<h4><center><strong>第二部分 分布</strong></center></h4>

<p>1.概率质量函数PMF(Probability Mass Function)：数据集中数据值到它的概率的映射函数。直方图是各个值出现的频数，如果将频数除以样本总数，得到概率，归一化之后的直方图就是PMF。</p>

<p><img src="pmf.png" alt="image" /></p>

<p>2.累积分布函数CDF(Cumulative Distribution Function)：数据集中数据值到它在分布中概率的累积值的映射函数。例如，
CDF(0) = 0; CDF(1) = 0.2; CDF(2) = 0.6; CDF(3) = 0.8; CDF(4) = 0.8; CDF(5) = 1，它的CDF图为一个阶跃函数：</p>

<p><img src="cdf.png" alt="image" /></p>

<p>3.指数分布(exponential distribution)：一种连续分布。举例来说，观察一系列事件之间的间隔时间，若事件在每个时间点发生的概率相同，那么间隔时间的分布就近似指数分布。指数分布的CDF如下：</p>

<p>$$
CDF(x)=1-e^{&ndash;\lambda x}
$$</p>

<p>参数$\lambda$决定了指数分布的形状，通常，指数分布的均值是$\frac{1}{\lambda}$，中位数是$\frac{log(2)}{\lambda}$。下图为$\lambda=2$的指数分布图：</p>

<p><img src="edcdf.png" alt="image" /></p>

<p>如果判断一个分布是否是指数分布呢？一种办法是画出取对数之后的互补累积分布函数(CCDF=Complementary CDF=1-CDF(x))，CCDF是一条斜率为$&ndash;\lambda$的直线，原因如下：</p>

<p>$$
y=CCDF(x)=1-CDF(x)=e^{&ndash;\lambda x} \quad => \quad log(y)=&ndash;\lambda x
$$</p>

<p>4.正态分布(Normal Distribution)：又叫高斯分布，是最常用的分布。对于正态分布的CDF还没有一种准确的表达，最常用的一种形式是以误差函数(error function)来表示，它是一个特殊的函数，表示为erf(x)：</p>

<p>$$
CDF(x)=\frac{1}{2}[1+erf(\frac{x-\mu}{\sigma \sqrt{2}})] \quad erf(x)=\frac{2}{\sqrt{\pi}}\int_{0}^{x}e^{-r^{2}}dt
$$</p>

<p>其中，参数$\mu$和$\sigma$分别决定了正态分布的均值和标准差。下图为$\mu=2.0$和$\sigma=0.5$的正态分布的CDF图：</p>

<p><img src="ndcdf.png" alt="image" /></p>

<p>根据大数定理，当我们处理大样本数据集(超过30个数据)，并且重复地从总体中抽取样本时，得到的数值分布就接近正态分布曲线。正态分布以均值为中心完全对称。</p>

<p>关于正态分布有一个重要的结论，对任何数值分布来说(不论它的均值和标准差)，只要数值是正态分布，那么几乎100%的数值都分布在均值的-3到3个标准差之间。下面是正态曲线下数值的分布情况：</p>

<p><img src="nd.png" alt="image" /></p>

<p>从中可以看出，在均值与1个标准差之间大概有34%的数值分布，在1个标准差和2个标准差之间大概有13%的数值分布，在2个标准差和3个标准差之间大概有2.1%的数值分布。</p>

<p><a href="http://wikipedia.org/wiki/Log-normal_distribution">对数正态分布</a>：如果一组数据取对数之后服从正态分布，那么我们就称其服从对数正态分布。对数正态分布的 CDF 跟正态分布一样, 只是用 logx 代替原来的 x:</p>

<p>$$
CDF<em>{lognormal}(x) = CDF</em>{normal}(log x)
$$</p>

<p>对数正态分布的均值与标准差不再是是$\mu$和$\sigma$了。可以证明,成人体重的分布是近似对数正态的。</p>

<h4><center><strong>第三部分 描述性统计量</strong></center></h4>

<p>1.描述数据的集中趋势：均值(mean)，中位数(median)，众数(mode)，加权平均数</p>

<p>百分位点(percentile points)：中位数(Q2)就是50百分位点，Q1为25百分位点(lower quartile)，Q3为75百分位点(upper quartile)，经常使用Q3-Q1=IQR(interquartile range，四分差或四分位数)来检查分布是否对称。</p>

<p>[如果要计算一组数中的某个百分位数，一般比较好的排序方法是选择排序；当然，如果是计算该组数的特殊的百分位数，例如中位数，有其他更好地方法能够在线性时间内得到，之后我对做一些相关问题的研究，暂且说明一下]</p>

<p>2.描述数据的变异性：极差(range)，标准差(standard deviation,简称s或者SD)，方差(deviation)</p>

<p>标准差的计算公式：
$$
s=\sqrt{\frac{\Sigma(X-\bar{X})<sup>2</sup>}{n-1}}
$$</p>

<p><strong>s是总体标准差的无偏估计，如果根号内部分母改成了n则是有偏估计</strong>，详细证明参见：<a href="http://en.wikipedia.org/wiki/Bias_of_an_estimator">http://en.wikipedia.org/wiki/Bias_of_an_estimator</a></p>

<p>标准差和方差的异同：<strong>它们都是用来反映数据集中数据的变异性或者离散度的度量，但是标准差以原有的计算单位存在，然而方差以平方单位存在，前者在实际中更加具有意义</strong>。例如，某高校的男生的平均身高是170cm，标准差是5cm，那么说明该校男生的身高与均值的差异大概就是5cm，换成方差来解释的话就不好陈述了。</p>

<p>使用有偏估计其实也可，但是最好使用无偏估计，我记得Coursera Machine Learning课中Andrew Ng曾经提到过，实际编码中其实还是使用有偏估计，因为它们在样本数据很大的时候其实结果没多大影响。</p>

<p>3.数据集的图形化显示：直方图，饼图，线图，柱形图，条形图，茎叶图等</p>

<p>数据分布的差异性描述：平均值，变异性，峰度(kurtosis)，偏度(skewness)</p>

<p>峰值可能有多个，比如双峰或者多峰等。偏度有一个计算公式，由Pearson发明的，他同时也是相关系数的发明者，偏度虽有正负之分，但是绝对值越大说明图形越偏。</p>

<p>$$
SK=\frac{3(\bar{X}-M)}{s},\quad M=Median,\bar{X}=Mean,s=SD
$$</p>

<p>4.相关系数(correlation coefficient)是两个变量之间<strong>线性关系</strong>的数值型指标，取值范围是[-1,1]，大于0表示正相关，小于0表示负相关，可以用散点图来直接查看相关性。根据某些不成文的规则，一般高于0.6表示强相关，低于0.4表示弱相关，中间部分表示中度相关。</p>

<p>[<strong>Pearson相关系数考察的变量的属性是连续的，例如年龄，体重等，如果是离散型变量那么应该使用点二列相关系数</strong>]</p>

<p>注意两点：(1)<strong>相关系数反映的是只是线性关系！如果两个变量的相关系数为0，只能说明它们没有线性关系存在，但是可能存在其他的非线性关系！</strong>
(2)<strong>相关性和因果关系无关！</strong>例如，冰淇淋的消费量和犯罪率是正相关的，但是两者不存在任何因果关系！</p>

<p>相关系数的计算：</p>

<p>$$
r_{XY}=\frac{n\Sigma{XY}&ndash;\Sigma{X}\Sigma{Y}}{\sqrt{[n\Sigma{X<sup>2</sup>}&ndash;(\Sigma{X})<sup>2</sup>][n\Sigma{Y<sup>2</sup>}&ndash;(\Sigma{Y})<sup>2</sup>]}}
$$</p>

<p>决定系数：相关系数的平方，它表述一个变量的方差可以被另一个变量的方差来解释的百分比。</p>

<h4><center><strong>第四部分 假设检验</strong></center></h4>

<p>1.假设：一般假设就是一个“猜想”，它表述问题的一般陈述。假设检验是用于样本，然后才将结论一般化推广到总体中。</p>

<p>2.零假设(null hypothesis=$H_{0}$，或叫原假设)：它一般表示“正在研究的两个变量无关或者没有差异”这样的命题。例如，三年级学生的记忆力考试成绩与四年级学生记忆力考试成绩之间没有差异。</p>

<p><strong>(1)零假设是研究的起点，因为在没有信息的情况下，零假设就被看作是可以接受的真实状态。在这种假设下，我们认为观测到的效应是由偶然因素造成的。</strong>
<strong>(2)零假设也是研究的基准，也就是说在零假设成立的情况下，计算统计量，然后进行假设检验。这就类似反证法的思想。</strong></p>

<p>3.研究假设(research hypothesis=alternate hypothesis，或叫备择假设)：与零假设相对立的，认为变量之间有关系的假设。</p>

<p>研究假设分为有方向和无方向两种研究假设。无方向研究假设命题例子：三年级学生的记忆力考试成绩与四年级学生记忆力考试成绩之间有差异。有方向研究假设命题例子：三年级学生的记忆力考试成绩低于四年级学生记忆力考试成绩。</p>

<p>讨论有无方向的另一种形式是讨论单尾检验(one-tailed test)和双尾检验(two-tailed test)。</p>

<p>零假设与研究假设的区别：
(1)零假设表示两个变量没有差异或者没有关系，研究假设表示它们有关系或者有差异；
(2)零假设对应的是总体，而研究假设对应的是样本。我们是从总体中取出一部分样本进行检验，将得到的结论推广到总体中。
(3)因为总体不能直接检验(不现实，不经济或者不可能)，所以零假设只能间接检验，研究假设则可以直接检验。</p>

<!-- footnots -->




<!-- mathjax config similar to math.stackexchange -->


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  jax: ["input/TeX", "output/HTML-CSS"],
  tex2jax: {
    inlineMath: [ ['$', '$'] ],
    displayMath: [ ['$$', '$$']],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  messageStyle: "none",
  "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
});
</script>


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>




<p class='post-footer'>
                        Original link:<a href='http://hujiaweibujidao.github.io/blog/2014/04/22/probability-and-statistics-summary/'>http://hujiaweibujidao.github.io/blog/2014/04/22/probability-and-statistics-summary/</a><br/>Written by <a href='http://hujiaweibujidao.github.io'>hujiawei</a>&nbsp;Posted at <a href='http://hujiaweibujidao.github.io'>http://hujiaweibujidao.github.io</a><br/>Feel free to read or comment it, and if you want to copy it into your own site, please copy it with its Original Link showed above or you can see the license below for more details.<br />Thanks a lot. Hope you enjoy here! ^_^</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Flying on Mac]]></title>
    <link href="http://hujiaweibujidao.github.io/blog/2014/04/15/flying-on-mac/"/>
    <updated>2014-04-15T13:39:00+08:00</updated>
    <id>http://hujiaweibujidao.github.io/blog/2014/04/15/flying-on-mac</id>
    <content type="html"><![CDATA[<p>该博文记录Mac使用中出现的一些问题，包括Mac中的一些软件出现异常的解决方案，使我们能够<code>Flying on Mac</code>，一直更新中&hellip;</p>

<p>1.如果Mou渲染Math公式有问题的话，尝试在第一行加上如下js，其src为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;!-- import js for mathjax --&gt;
</span><span class='line'>&lt;script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"&gt;&lt;/script&gt;</span></code></pre></td></tr></table></div></figure>


<p>该链接指向的是Mathjax的js，用来渲染Math公式，Mou支持Mathjax。为了减轻Octopress加载的负担，可以只在需要使用Mathjax的博文中添加一行js即可，不需要将它放在自定义的<code>head.html</code>文件中。</p>

<p>不知为何，最近加上了这句Math公式还是没有显示出来，貌似Mou并没有去加载这个js的样子，于是我尝试在浏览器中直接访问，将这个js中的所有内容复制进来，这样Mou有显示正常了，数学公式都没有问题！ :&ndash;) 如果你不能访问，放心，我已经将这个js的源码放在<a href="https://gist.github.com/hujiaweibujidao/11146289">这个Gist中</a>。</p>

<p>如果还是不行的话，那么建议使用<a href="https://stackedit.io/">stackedit</a>，感谢@beader的建议！还有一个问题是stackedit是在线编辑的，图片要保存到Google Driver中(或者有个特定的网址)，另外，它和Mou中内置的MathJax的渲染解析工具略有不同，例如对于行内Math的插入上，这时候推荐按照<a href="http://blog-jfttt.herokuapp.com/blog/2013/12/26/add-latex/">这位博主的方式修改</a>，添加下面的代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;!-- mathjax config similar to math.stackexchange --&gt;
</span><span class='line'>&lt;script type="text/x-mathjax-config"&gt;
</span><span class='line'>MathJax.Hub.Config({
</span><span class='line'>  jax: ["input/TeX", "output/HTML-CSS"],
</span><span class='line'>  tex2jax: {
</span><span class='line'>    inlineMath: [ ['$', '$'] ],
</span><span class='line'>    displayMath: [ ['$$', '$$']],
</span><span class='line'>    processEscapes: true,
</span><span class='line'>    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
</span><span class='line'>  },
</span><span class='line'>  messageStyle: "none",
</span><span class='line'>  "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
</span><span class='line'>});
</span><span class='line'>&lt;/script&gt;
</span><span class='line'>&lt;script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"&gt;&lt;/script&gt;</span></code></pre></td></tr></table></div></figure>


<p>测试：The <em>Gamma function</em> satisfying $\Gamma(n) = (n-1)!\quad\forall
n\in\mathbb N$ is via the Euler integral</p>

<p>$$
\Gamma(z) = \int_0^\infty t^{z-1}e^{-t}dt\,.
$$</p>

<!-- mathjax config similar to math.stackexchange -->


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  jax: ["input/TeX", "output/HTML-CSS"],
  tex2jax: {
    inlineMath: [ ['$', '$'] ],
    displayMath: [ ['$$', '$$']],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  messageStyle: "none",
  "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
});
</script>


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>


<p class='post-footer'>
                        Original link:<a href='http://hujiaweibujidao.github.io/blog/2014/04/15/flying-on-mac/'>http://hujiaweibujidao.github.io/blog/2014/04/15/flying-on-mac/</a><br/>Written by <a href='http://hujiaweibujidao.github.io'>hujiawei</a>&nbsp;Posted at <a href='http://hujiaweibujidao.github.io'>http://hujiaweibujidao.github.io</a><br/>Feel free to read or comment it, and if you want to copy it into your own site, please copy it with its Original Link showed above or you can see the license below for more details.<br />Thanks a lot. Hope you enjoy here! ^_^</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vertext Cover Problem]]></title>
    <link href="http://hujiaweibujidao.github.io/blog/2014/04/13/vertext-cover-problem/"/>
    <updated>2014-04-13T23:57:00+08:00</updated>
    <id>http://hujiaweibujidao.github.io/blog/2014/04/13/vertext-cover-problem</id>
    <content type="html"><![CDATA[<h4>1.问题描述</h4>

<p>给定一个N个点M条边的无向图G（点的编号从1至N），问是否存在一个不超过K个点的集合S，使得G中的每条边都至少有一个点在集合S中。</p>

<p>例如，如下图所示的无向图G（报告中算法分析过程中一直使用下面的图G）</p>

<p>(1)如果选择包含点1,2,6这3个点的集合S不能满足条件，因为边(3,7)两个端点都不在S中。</p>

<p><img src="http://hujiaweibujidao.github.io/images/201404/exp1-3.png" alt="image" /></p>

<p>(2)如果选择包含点1,2,6,7这4个点的集合S虽然满足条件，但是它使用了4个点，其实可以使用更少的点，如下面(3)所示</p>

<p><img src="http://hujiaweibujidao.github.io/images/201404/exp1-2.png" alt="image" /></p>

<p>(3)如果选择包含点1,3,5这3个点的集合S便满足条件，使得G中的每条边都至少有一个点在集合S中。</p>

<p><img src="http://hujiaweibujidao.github.io/images/201404/exp1-1.png" alt="image" /></p>

<h4>2.解题思路</h4>

<p>我的解题思路基于分支定界和贪心两个策略，用一个优先队列维护当前可行的节点，每个节点维护着该节点情况下还可以选择的顶点数目k、需要覆盖的剩余边数e、顶点的状态state、顶点的边数edge等信息，这些节点的排序遵循下面的贪心策略，节点的扩展遵循下面的分支定界策略。总体思路是：</p>

<p>①将原图数据构造成一个解空间树的节点，利用定界策略判断是否有解，如果无解直接退出，如果有可能有解则插入到优先队列中；</p>

<p>②若优先队列不为空，那么便从优先队列中取出第一个可行的节点，进入步骤③，如果优先队列为空则退出；</p>

<p>③判断当前节点是否满足解的条件，如果满足便输出解退出，如果不满足便进入步骤④；</p>

<p>④检查当前节点是否可以扩展，不能扩展的话便进入②继续循环，如果能扩展的话则扩展，然后验证扩展到左右节点是否有解，将有解的扩展节点插入到优先队列中，然后进入②继续循环。</p>

<p>下面分别介绍下分支定界和贪心这两个策略：</p>

<h5>(1)分支定界策略</h5>

<p>首先，界的选择。在一个确定的无向图G中，每个顶点的边即确定了，那么对于该无向图中k个顶点能够覆盖的最多的边数e也就可以确定了！只要对顶点按照边的数目降序排列，然后选择前k个顶点，将它们的边数相加即能得到一个边数上界！因为这k个顶点相互之间可能有边存在也可能没有，所以这是个上界，而且有可能达到。以图G为例，各个顶点的边数统计，并采用降序排列的结果如下：</p>

<!--顶点 | 2 | 3 | 1| 5 | 6| 4| 7 
--| --| --|--|--|--|--|--
边数 | 3 | 3 | 2| 2| 2| 1| 1-->


<!--
顶点 | 边数
----| ---- 
2 | 3 
3 | 3
1 | 2 
5 | 2
6 | 2
4 | 1
7 | 1-->


<p><img src="http://hujiaweibujidao.github.io/images/201404/exp1-f3.png" alt="image" /></p>

<p>假设取k=3个点，那么有Up(e)=(3+3+2)=8 > 7 条边（7为图G的总边数），也就是说，如果从图G中取3个点，要覆盖8条边是有可能的。但是，如果取k=2个点，那么有Up(e)=(3+3)=6 &lt; 7 条边，说明从图G中取2个点，是不可能覆盖G中的全部7条边的！基于这个上界，可以在分支树中扩展出来的节点进行验证，已知它还可以选择的顶点数目以及还需要覆盖的边的条数，加上顶点的状态（下面会分析说明）即可判断当前节点是否存在解！如果不存在即可进行剪枝了。</p>

<p>其次，顶点的状态。该策略中顶点有三种状态，分别为已经选择了的状态S1，不选择的状态S2，可以选择的状态S3。其中，不选择的状态S2对应解空间树中的右节点，不选择该节点，然后设置该节点为不选择状态S2。这点很重要，因为有了这个状态，可以使得上界的判断更为精确，因为只能从剩余顶点集中选择那些状态S3的顶点，状态S1和S2都不行，那么上界便会更小，也就更加精确，从而利于剪枝！</p>

<h5>(2)贪心策略</h5>

<p>贪心的策略是指可行的结点都是按照还需要覆盖的剩余边数的降序排列，即，每次选择的节点都是可行节点中还需要覆盖的边数最小的那个节点，因为它最接近结果了。</p>

<h5>(3)例子分析</h5>

<p>以图G为例，此时e=7（要覆盖的边数），取k=3，图G用邻接矩阵保存为全局数据，计算每个顶点的边数，然后降序排列。</p>

<p>步骤①判断是否可能有解，Up(e)=3+3+2=8>7，可能有解，那么将图G构造成一个解空间树的节点，它包含了还能选择的点数k=3，还需要覆盖的边数e=7，每个顶点的边数以及按边数大小的降序排列（上表），每个顶点的状态（初始时都是可选择的状态S3）。然后，将该节点插入到优先队列中，该优先队列是用最小堆实现的，按照前面的贪心策略对队列中的节点进行降序排列。</p>

<p>步骤②取出了优先队列中的根节点，很显然，还需要覆盖的边数为7，不为0，所以还不满足条件。接下来要检查是否能够进行扩展，从顶点集合中选择状态为可以选择的顶点中边数最多的点，该点存在为顶点2，接着进行扩展，扩展左节点时将还能选择的点数k-1=2，然后计算选择了该点之后删除了几条未覆盖的边，得到还需要覆盖的边数e=4，然后更新所有其他顶点的边数，并重新排序，最后将顶点2的状态设置为已经选择了；扩展右节点时，只要将顶点2的状态设置为不能选择，还能选择的点数k(=3)，还需要覆盖的边数e(=7)保持不变。扩展完了之后，同样判断左右节点是否可能有解，如果有解，将该节点插入到优先队列中。这里左右节点都有解，那么将左右节点都插入到优先队列中，因为左节点还需要覆盖的边数e=4小于右节点的e=7，所以根据贪心策略，左节点在右节点的前面。上面两个步骤的图示如下，其中标明了顶点状态颜色。</p>

<p><img src="http://hujiaweibujidao.github.io/images/201404/exp1-f1.png" alt="image" /></p>

<p>算法然后继续进入步骤②，此时取出的是节点是刚才插入的左节点，很显然，还需要覆盖的边数为4，不为0，所以还不满足条件。接下来要检查是否能够进行扩展，从顶点集合中选择状态为可以选择的顶点中边数最多的点，该点存在为顶点3，接着进行扩展，扩展左节点时将还能选择的点数k-1=1，然后计算选择了该点之后删除了几条未覆盖的边，得到还需要覆盖的边数e=2，然后更新所有其他顶点的边数，并重新排序，最后将顶点3的状态设置为已经选择了；扩展右节点时，只要将顶点3的状态设置为不能选择，还能选择的点数k(=3)，还需要覆盖的边数e(=7)保持不变。扩展完了之后，同样判断左右节点是否可能有解，如果有解，将该节点插入到优先队列中。这里左右节点都不可能有解，那么直接进入步骤②继续循环。上面这一步的图示如下：</p>

<p><img src="http://hujiaweibujidao.github.io/images/201404/exp1-f2.png" alt="image" /></p>

<p>算法按照上面的方式不断进行，最后满足条件的分支的过程是：</p>

<p>①不选择顶点2；②选择顶点3；③选择顶点1；④选择顶点5。</p>

<p>最后得到的满足条件的解是选择顶点1,3,5。</p>

<h4>(4)复杂度分析</h4>

<p>该算法优先队列使用的是最小堆实现的(O(nlgn))，对顶点按照边排序使用的是快速排序算法(O(nlgn))，解空间树的深度最多为顶点数目n，每层都要进行分支定界，所以每层的时间复杂度为O(nlgn)，所以算法总的时间复杂度为O(n<sup>2</sup> lgn)。但是，为了实现分支定界，每个节点保存的信息量较多，空间复杂度较大。(有木有分析错了，我不太会分析复杂度)</p>

<p>OJ系统的结果为：时间 156ms  空间 1.0MB</p>

<p class='post-footer'>
                        Original link:<a href='http://hujiaweibujidao.github.io/blog/2014/04/13/vertext-cover-problem/'>http://hujiaweibujidao.github.io/blog/2014/04/13/vertext-cover-problem/</a><br/>Written by <a href='http://hujiaweibujidao.github.io'>hujiawei</a>&nbsp;Posted at <a href='http://hujiaweibujidao.github.io'>http://hujiaweibujidao.github.io</a><br/>Feel free to read or comment it, and if you want to copy it into your own site, please copy it with its Original Link showed above or you can see the license below for more details.<br />Thanks a lot. Hope you enjoy here! ^_^</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LeetCode OJ Part1]]></title>
    <link href="http://hujiaweibujidao.github.io/blog/2014/04/09/leetcode-oj-part1/"/>
    <updated>2014-04-09T18:18:00+08:00</updated>
    <id>http://hujiaweibujidao.github.io/blog/2014/04/09/leetcode-oj-part1</id>
    <content type="html"><![CDATA[<p>为了找以后工作嘛，挑战下LeetCode OJ，顺序可能与OJ上的顺序不同哟，慢慢增加&hellip;</p>

<p>注，我附上的代码都包含了测试代码，提交的代码中不需要测试部分，我保留是因为某些题中有些测试样例比较特殊，为了提醒自己不要再犯同样的错！</p>

<p>1.Reverse Words in a String</p>

<p>字符串题，字符串分割再反转</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Solution:
</span><span class='line'>    # @param s, a string
</span><span class='line'>    # @return a string
</span><span class='line'>    def reverseWords(self, s):
</span><span class='line'>        l = s.strip().split()
</span><span class='line'>        l.reverse()
</span><span class='line'>        return ' '.join(l)
</span><span class='line'>if __name__ == '__main__':
</span><span class='line'>    teststrs = ('helo world', ' hel hj ')
</span><span class='line'>    so = Solution()
</span><span class='line'>    for test in teststrs:
</span><span class='line'>        print so.reverseWords(test)    </span></code></pre></td></tr></table></div></figure>


<p>2.Evaluate Reverse Polish Notation</p>

<p>栈的利用，逆波兰表达式求值</p>

<p>注：在Java中<code>6/(-132)=0</code>但是在Python中<code>6/(-132)=-1</code>，OJ认为0是正解，所以Python中进行除法运算时使用<code>int(float(m)/float(n))</code>。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Solution:
</span><span class='line'>    # @param tokens, a list of string
</span><span class='line'>    # @return an integer
</span><span class='line'>    def evalRPN(self, tokens):
</span><span class='line'>        stack = []
</span><span class='line'>        result = 0
</span><span class='line'>        for token in tokens:
</span><span class='line'>            if (token in '+-*/'):
</span><span class='line'>                result = self.calculate(token, int(stack.pop()), int(stack.pop()))
</span><span class='line'>                stack.append(result)
</span><span class='line'>            else:
</span><span class='line'>                stack.append(int(token))
</span><span class='line'>        return stack.pop()
</span><span class='line'>    def calculate(self, token, n, m):
</span><span class='line'>        if token.__eq__('+'):
</span><span class='line'>            return n + m
</span><span class='line'>        elif token.__eq__('-'):
</span><span class='line'>            return m - n
</span><span class='line'>        elif token.__eq__('*'):
</span><span class='line'>            return n * m
</span><span class='line'>        elif token.__eq__('/'):
</span><span class='line'>            return int(float(m) / float(n))
</span><span class='line'>if __name__ == '__main__':
</span><span class='line'>    tests = [["18"],["10","6","9","3","+","-11","*","/","*","17","+","5","+"]];
</span><span class='line'>    so = Solution()
</span><span class='line'>    for test in tests:
</span><span class='line'>        print so.evalRPN(test)  </span></code></pre></td></tr></table></div></figure>


<p>3.Max Points on a Line</p>

<p>在平面上的点集合中找到在同一条线上最多的点集合的个数</p>

<p>注：相同的点重复计算点个数</p>

<p>To be continued&hellip;&hellip;</p>

<p class='post-footer'>
                        Original link:<a href='http://hujiaweibujidao.github.io/blog/2014/04/09/leetcode-oj-part1/'>http://hujiaweibujidao.github.io/blog/2014/04/09/leetcode-oj-part1/</a><br/>Written by <a href='http://hujiaweibujidao.github.io'>hujiawei</a>&nbsp;Posted at <a href='http://hujiaweibujidao.github.io'>http://hujiaweibujidao.github.io</a><br/>Feel free to read or comment it, and if you want to copy it into your own site, please copy it with its Original Link showed above or you can see the license below for more details.<br />Thanks a lot. Hope you enjoy here! ^_^</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setting Up Environments on New Mac]]></title>
    <link href="http://hujiaweibujidao.github.io/blog/2014/04/08/setting-up-environments-on-new-mac/"/>
    <updated>2014-04-08T11:13:00+08:00</updated>
    <id>http://hujiaweibujidao.github.io/blog/2014/04/08/setting-up-environments-on-new-mac</id>
    <content type="html"><![CDATA[<p>1.安装Java 7u51 ［直接在<a href="http://www.java.com/zh_CN/download/manual.jsp">官网</a>下载dmg点击安装即可]</p>

<p><code>JAVA_HOME=/Library/Java/JavaVirtualMachines/1.7.0_51.jdk/Contents/Home</code></p>

<p>为了保证Eclipse和Matlab等需要JRE 6的应用程序能够运行，还需要 ［<code>1.7.0.jdk</code>部分可能需要修改］</p>

<p>[个人猜测，因为Mac OS X早期系统和Mavericks中将JDK存放的位置不同，很多程序按照以前的位置去查找，所以找不到，不能正常启动]</p>

<p><code>sudo mkdir /System/Library/Java/JavaVirtualMachines</code></p>

<p><code>sudo ln -s /Library/Java/JavaVirtualMachines/1.7.0.jdk /System/Library/Java/JavaVirtualMachines/1.6.0.jdk</code></p>

<p>实际上上面的操作还是会导致系统存在两个JRE（6和7），不过已经算是很好的解决方案了</p>

<p>网址：<a href="http://apple.stackexchange.com/questions/58203/mountain-lion-with-java-7-only">http://apple.stackexchange.com/questions/58203/mountain-lion-with-java-7-only</a></p>

<p>2.安装HomeBrew</p>

<p>网址：<a href="https://raw.github.com/Homebrew/homebrew/go/install">https://raw.github.com/Homebrew/homebrew/go/install</a></p>

<p>网址：<a href="http://linfan.info/blog/2012/02/25/homebrew-installation-and-usage/">http://linfan.info/blog/2012/02/25/homebrew-installation-and-usage/</a> [Homebrew使用教程]</p>

<p>执行<code>ruby -e "$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)"</code>，如果还没有安装Xcode，则需要安装CLT(Command Line Tools) <code>"xcode-select --install"</code></p>

<p>Homebrew会将安装的软件包存放在<code>/usr/local/</code>目录下，例如<code>/usr/local/bin</code>存放一些可执行文件，<code>/usr/local/lib</code>存放一些公共库，通过homebrew安装的软件包存放在<code>/usr/local/Cellar</code>目录下。
通过<code>brew doctor</code>命令可以检查系统中软件包可能存在的一些问题。添加<code>export PATH=/usr/local/bin:$PATH</code>到<code>~/.bash_profile</code>文件中，这样默认先使用Homebrew安装的应用程序，而不是使用系统。[注：Homebrew不会破坏系统的一些软件或者环境变量，另外，Homebrew下载的安装包存放在<code>/Library/Caches/Homebrew</code>目录中，创建的Formula存放在<code>/usr/local/Library/Formula</code>目录中]</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>hujiawei-MacBook-Pro:~ hujiawei$ ruby -e "$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)"
</span><span class='line'>==&gt; This script will install:
</span><span class='line'>/usr/local/bin/brew
</span><span class='line'>/usr/local/Library/...
</span><span class='line'>/usr/local/share/man/man1/brew.1
</span><span class='line'>...
</span><span class='line'>==&gt; Installation successful!
</span><span class='line'>You should run `brew doctor' *before* you install anything.
</span><span class='line'>Now type: brew help</span></code></pre></td></tr></table></div></figure>


<p>3.安装git</p>

<p>网址：<a href="https://help.github.com/articles/generating-ssh-keys">https://help.github.com/articles/generating-ssh-keys</a></p>

<p><code>brew install git</code>，然后按照网址提示添加<code>ssh－key</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>hujiawei-MacBook-Pro:.ssh hujiawei$ ssh-add ~/.ssh/id_rsa
</span><span class='line'>Identity added: /Users/hujiawei/.ssh/id_rsa (/Users/hujiawei/.ssh/id_rsa)
</span><span class='line'>hujiawei-MacBook-Pro:.ssh hujiawei$ pbcopy &lt; ~/.ssh/id_rsa.pub
</span><span class='line'>hujiawei-MacBook-Pro:.ssh hujiawei$ pbcopy &lt; ~/.ssh/id_rsa.pub
</span><span class='line'>hujiawei-MacBook-Pro:.ssh hujiawei$ ssh -T git@github.com
</span><span class='line'>Warning: Permanently added the RSA host key for IP address '192.30.252.128' to the list of known hosts.
</span><span class='line'>Hi hujiaweibujidao! You've successfully authenticated, but GitHub does not provide shell access.</span></code></pre></td></tr></table></div></figure>


<p>4.配置python环境</p>

<p>网址：<a href="http://penandpants.com/2012/02/24/install-python/">http://penandpants.com/2012/02/24/install-python/</a></p>

<p>使用Homebrew安装了python之后，python路径修改为 <code>/usr/local/bin/python</code> [原来在 <code>/usr/bin/python</code>]，<code>pip install &lt;package&gt;</code>命令会将模块安装到<code>/usr/local/lib/python2.7/site-packages</code>中。<code>pip list</code>命令查看已经安装的Python模块。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>hujiawei-MacBook-Pro:~ hujiawei$ brew install python
</span><span class='line'>Warning: A newer Command Line Tools release is available
</span><span class='line'>Update them from Software Update in the App Store.
</span><span class='line'>==&gt; Installing dependencies for python: readline, sqlite, gdbm
</span><span class='line'>==&gt; Installing python dependency: readline
</span><span class='line'>==&gt; Downloading https://downloads.sf.net/project/machomebrew/Bottles/readline-6.
</span><span class='line'>==&gt; Pouring readline-6.2.4.mavericks.bottle.2.tar.gz
</span><span class='line'>==&gt; Caveats
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<p>如果把<code>/usr/local/share/python</code>（参考网站提示用来存放Python脚本）也添加到<code>$PATH</code>中的话，<code>brew doctor</code>会给出一个警告，暂时不添加。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Warning: /usr/local/share/python is not needed in PATH.
</span><span class='line'>Formerly homebrew put Python scripts you installed via `pip` or `pip3`
</span><span class='line'>(or `easy_install`) into that directory above but now it can be removed
</span><span class='line'>from your PATH variable.
</span><span class='line'>Python scripts will now install into /usr/local/bin.
</span><span class='line'>You can delete anything, except 'Extras', from the /usr/local/share/python
</span><span class='line'>(and /usr/local/share/python3) dir and install affected Python packages
</span><span class='line'>anew with `pip install --upgrade`.</span></code></pre></td></tr></table></div></figure>


<p>安装好了python之后，按照网址上的内容继续安装pip，然后安装<code>virtualenv, virtualenvwrapper, numpy, gfortran, scipy, matplotlib</code>等模块。[注，一般软件包使用brew安装和管理，对于python的模块使用pip安装和管理]</p>

<p>5.配置Ruby环境 ［为了正常使用原有的Octopress］</p>

<p>网址：<a href="http://hujiaweibujidao.github.io/blog/2013/11/17/hello-octopress/">http://hujiaweibujidao.github.io/blog/2013/11/17/hello-octopress/</a></p>

<p>网址：<a href="http://blog.zerosharp.com/clone-your-octopress-to-blog-from-two-places/">http://blog.zerosharp.com/clone-your-octopress-to-blog-from-two-places/</a></p>

<p>网址：<a href="http://octopress.org/docs/setup/">http://octopress.org/docs/setup/</a> <a href="http://octopress.org/docs/deploying/github/">http://octopress.org/docs/deploying/github/</a></p>

<p>执行<code>rbenv install 1.9.3-p0</code> 时需要<code>apple-gcc42</code>，执行 <code>brew tap homebrew/dupes ; brew install apple-gcc42</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>hujiawei-MacBook-Pro:eclipse_cp hujiawei$ brew install rbenv
</span><span class='line'>Warning: A newer Command Line Tools release is available
</span><span class='line'>Update them from Software Update in the App Store.
</span><span class='line'>==&gt; Downloading https://github.com/sstephenson/rbenv/archive/v0.4.0.tar.gz
</span><span class='line'>==&gt; Caveats
</span><span class='line'>To use Homebrew's directories rather than ~/.rbenv add to your profile:
</span><span class='line'>  export RBENV_ROOT=/usr/local/var/rbenv
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<p>rbenv是一个管理ruby环境的工具，gem相当于管理ruby模块的工具。(<code>gem list</code>查看已安装的模块)</p>

<p>如果想要使用以前的Octopress的话，执行下面的命令，之后就可以像以前一样使用Octopress了</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>brew update
</span><span class='line'>brew install rbenv
</span><span class='line'>brew install ruby-build
</span><span class='line'>rbenv install 1.9.3-p0
</span><span class='line'>rbenv rehash
</span><span class='line'>rbenv global 1.9.3-p0  #建议增加这句修改系统全局的ruby版本
</span><span class='line'>ruby --version  #查看系统ruby版本
</span><span class='line'>cd &lt;path-to-octopress&gt;
</span><span class='line'>gem install bundler
</span><span class='line'>rbenv rehash    # If you use rbenv, rehash to be able to run the bundle command
</span><span class='line'>bundle install</span></code></pre></td></tr></table></div></figure>


<p>6.配置OpenCV环境</p>

<p>网址：<a href="http://hujiaweibujidao.github.io/blog/2014/03/13/develop-with-opencv-on-mac-os-x/">http://hujiaweibujidao.github.io/blog/2014/03/13/develop-with-opencv-on-mac-os-x/</a></p>

<p><strong>注意！如果是进行OpenCV源码编译的话，因为会产生很多的文件保存到<code>/usr/local</code>下的各个子目录中，这会导致<code>brew doctor</code>报出很多错误，例如<code>/usr/local/lib</code>下很多OpenCV的库Homebrew不能识别，甚至涉及到了权限问题，所以建议不要再前面进行OpenCV环境的配置！</strong></p>

<p>正常情况下的OpenCV配置：安装CMake，编译OpenCV源码，花的时间比较长</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo brew install cmake //homebrew
</span><span class='line'>cd &lt;path-to-opencv-source&gt;
</span><span class='line'>mkdir release
</span><span class='line'>cd release
</span><span class='line'>cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local ..
</span><span class='line'>make
</span><span class='line'>sudo make install</span></code></pre></td></tr></table></div></figure>


<p>如果导致前面出现Python环境配置出现问题，可以尝试卸载OpenCV，还要手动删除一些<code>/usr/local</code>下的OpenCV目录。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>hujiawei-MacBook-Pro:hujiawei hujiawei$ cd Android/opencv-2.4.6.1/
</span><span class='line'>hujiawei-MacBook-Pro:opencv-2.4.6.1 hujiawei$ cd release
</span><span class='line'>hujiawei-MacBook-Pro:release hujiawei$ sudo make uninstall
</span><span class='line'>Password:
</span><span class='line'>Scanning dependencies of target uninstall
</span><span class='line'>-- Uninstalling "/usr/local/include/opencv2/opencv_modules.hpp"
</span><span class='line'>-- Uninstalling "/usr/local/lib/pkgconfig/opencv.pc"
</span><span class='line'>-- Uninstalling "/usr/local/share/OpenCV/OpenCVConfig.cmake"
</span><span class='line'>-- Uninstalling "/usr/local/share/OpenCV/OpenCVConfig-version.cmake"
</span><span class='line'>-- Uninstalling "/usr/local/include/opencv/cv.h"
</span><span class='line'>-- Uninstalling "/usr/local/include/opencv/cv.hpp"
</span><span class='line'>...
</span><span class='line'>-- Uninstalling "/usr/local/share/OpenCV/haarcascades/haarcascade_smile.xml"
</span><span class='line'>-- Uninstalling "/usr/local/share/OpenCV/haarcascades/haarcascade_upperbody.xml"
</span><span class='line'>-- Uninstalling "/usr/local/share/OpenCV/lbpcascades/lbpcascade_frontalface.xml"
</span><span class='line'>-- Uninstalling "/usr/local/share/OpenCV/lbpcascades/lbpcascade_profileface.xml"
</span><span class='line'>-- Uninstalling "/usr/local/share/OpenCV/lbpcascades/lbpcascade_silverware.xml"
</span><span class='line'>-- Uninstalling "/usr/local/bin/opencv_haartraining"
</span><span class='line'>-- Uninstalling "/usr/local/bin/opencv_createsamples"
</span><span class='line'>-- Uninstalling "/usr/local/bin/opencv_performance"
</span><span class='line'>-- Uninstalling "/usr/local/bin/opencv_traincascade"
</span><span class='line'>Built target uninstall</span></code></pre></td></tr></table></div></figure>


<p>如果可以的话，使用Homebrew安装OpenCV</p>

<p>参考网址：<a href="http://www.jeffreythompson.org/blog/2013/08/22/update-installing-opencv-on-mac-mountain-lion/">http://www.jeffreythompson.org/blog/2013/08/22/update-installing-opencv-on-mac-mountain-lion/</a>  支持Mavericks</p>

<p>其他关于搭建OpenCV环境的文章 <a href="http://blog.sciencenet.cn/blog-702148-657754.html">http://blog.sciencenet.cn/blog-702148-657754.html</a></p>

<p>我的系统在执行<code>brew install jasper</code>时不知何原因不能继续，一直停留在<code>make install</code>状态，所以<code>brew install opencv</code>不能成功，即使我修改japser或者opencv的Formula文件也无济于事，最终尝试还是进行OpenCV源码编译，但是不安装到<code>/usr/local/</code>目录中，方法是修改下面的<code>CMAKE_INSTALL_PREFIX</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd &lt;path-to-opencv-source&gt;
</span><span class='line'>mkdir release
</span><span class='line'>cd release
</span><span class='line'>cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/opencv .. 
</span><span class='line'>make
</span><span class='line'>sudo make install</span></code></pre></td></tr></table></div></figure>


<p>但是，还有一个问题，无论在Xcode还是Eclipse中创建OpenCV项目都一样会报一个错，如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dyld: Library not loaded: lib/libopencv_core.2.4.dylib
</span><span class='line'>  Referenced from: /Users/hujiawei/Library/Developer/Xcode/DerivedData/PRWorks-gmeabxnfaunwiqbrvvjpxjlfkymu/Build/Products/Debug/PRWorks
</span><span class='line'>  Reason: image not found</span></code></pre></td></tr></table></div></figure>


<p>即使你的路径都没错也还是不能加载到，不知道何原因，但是如果你直接将编译之后的所有dylib复制到<code>/usr/local/lib</code>中即可，不能是该目录下的某个文件夹！复制了之后，自然<code>brew doctor</code>会对此进行警告，无视吧。</p>

<p>一个常用来测试OpenCV环境的项目代码如下，需要opencv_core和opencv_highgui两个库</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;opencv2/opencv.hpp&gt;
</span><span class='line'>using namespace cv;
</span><span class='line'>int main(int argc, char** argv) {
</span><span class='line'>  Mat image;
</span><span class='line'>  image = imread(
</span><span class='line'>          "/Users/hujiawei/Pictures/webimages/clone-your-octopress-001.png",
</span><span class='line'>          1);
</span><span class='line'>  namedWindow("Display Image", WINDOW_AUTOSIZE);
</span><span class='line'>  imshow("Display Image", image);
</span><span class='line'>  waitKey(0);
</span><span class='line'>  return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>7.最后执行<code>brew linkapps</code>会将brew安装的python中的app链接到Applications中</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>hujiawei-MacBook-Pro:~ hujiawei$ brew linkapps
</span><span class='line'>Linking /usr/local/Cellar/python/2.7.6/IDLE.app
</span><span class='line'>Linking /usr/local/Cellar/python/2.7.6/Python Launcher.app
</span><span class='line'>Finished linking. Find the links under /Applications.</span></code></pre></td></tr></table></div></figure>


<p>使用<code>brew doctor</code>检查，修复问题。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>hujiawei-MacBook-Pro:~ hujiawei$ brew doctor
</span><span class='line'>Warning: You have unlinked kegs in your Cellar
</span><span class='line'>Leaving kegs unlinked can lead to build-trouble and cause brews that depend on
</span><span class='line'>those kegs to fail to run properly once built. Run `brew link` on these:
</span><span class='line'>    cloog
</span><span class='line'>    isl
</span><span class='line'>Warning: A newer Command Line Tools release is available
</span><span class='line'>Update them from Software Update in the App Store.
</span><span class='line'>^C
</span><span class='line'>hujiawei-MacBook-Pro:~ hujiawei$ brew link cloog
</span><span class='line'>Linking /usr/local/Cellar/cloog/0.18.1... 8 symlinks created
</span><span class='line'>hujiawei-MacBook-Pro:~ hujiawei$ brew link isl
</span><span class='line'>Linking /usr/local/Cellar/isl/0.12.1... 6 symlinks created</span></code></pre></td></tr></table></div></figure>


<p class='post-footer'>
                        Original link:<a href='http://hujiaweibujidao.github.io/blog/2014/04/08/setting-up-environments-on-new-mac/'>http://hujiaweibujidao.github.io/blog/2014/04/08/setting-up-environments-on-new-mac/</a><br/>Written by <a href='http://hujiaweibujidao.github.io'>hujiawei</a>&nbsp;Posted at <a href='http://hujiaweibujidao.github.io'>http://hujiaweibujidao.github.io</a><br/>Feel free to read or comment it, and if you want to copy it into your own site, please copy it with its Original Link showed above or you can see the license below for more details.<br />Thanks a lot. Hope you enjoy here! ^_^</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Principal Component Analysis]]></title>
    <link href="http://hujiaweibujidao.github.io/blog/2014/04/05/principal-component-analysis/"/>
    <updated>2014-04-05T22:53:00+08:00</updated>
    <id>http://hujiaweibujidao.github.io/blog/2014/04/05/principal-component-analysis</id>
    <content type="html"><![CDATA[<p>Materials on PCA</p>

<p>参考资料:</p>

<p>1.<a href="http://www.doc.ic.ac.uk/~dfg/ProbabilisticInference/IDAPILecture15.pdf">Lecture 15: Principal Component Analysis</a>  <br/>
介绍了PCA基本原理，也介绍了PCA在人脸识别中的应用   <br/>
2.<a href="http://bytefish.de/blog/pca_lda_with_gnu_octave/">Bytefish&rsquo;s Blog about Principal Component and Linear Discriminant Analysis</a>    <br/>
Bytefish的博客中介绍了PCA和LDA，以及如何将它们应用到人脸识别中。他是OpenCV内置人脸识别算法的作者，他的博客中有算法的详细讲解。</p>

<p class='post-footer'>
                        Original link:<a href='http://hujiaweibujidao.github.io/blog/2014/04/05/principal-component-analysis/'>http://hujiaweibujidao.github.io/blog/2014/04/05/principal-component-analysis/</a><br/>Written by <a href='http://hujiaweibujidao.github.io'>hujiawei</a>&nbsp;Posted at <a href='http://hujiaweibujidao.github.io'>http://hujiaweibujidao.github.io</a><br/>Feel free to read or comment it, and if you want to copy it into your own site, please copy it with its Original Link showed above or you can see the license below for more details.<br />Thanks a lot. Hope you enjoy here! ^_^</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Matlab Image Segmentation]]></title>
    <link href="http://hujiaweibujidao.github.io/blog/2014/03/30/matlab-image-segmentation/"/>
    <updated>2014-03-30T16:13:00+08:00</updated>
    <id>http://hujiaweibujidao.github.io/blog/2014/03/30/matlab-image-segmentation</id>
    <content type="html"><![CDATA[<p>1.基于迭代的自动阈值图像分割方法</p>

<p>参考文献: <a href="http://hujiaweibujidao.github.io/files/image_segmentation.pdf">基于迭代(自动阈值)算法的医学图像增强方法</a></p>

<p>该文献实现了全局和局部的图像分割代码，使用的都是迭代算法，对比下面的结果可以看出，在灰度差异特别大的图像中，局部阈值分割要比全局阈值分割表现更好。[注:我对源码略有修改]</p>

<p>1.1 全局阈值分割程序</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>original_image=imread('test1.png');
</span><span class='line'>gray_image=rgb2gray(original_image);
</span><span class='line'>gray_image=double(gray_image);
</span><span class='line'>t=mean(gray_image(:));
</span><span class='line'>is_done=false;
</span><span class='line'>count=0;%迭代次数
</span><span class='line'>block=gray_image(1:end,1:end);%不分块
</span><span class='line'>while ~is_done
</span><span class='line'>    r1=find(gray_image&lt;=t);
</span><span class='line'>    r2=find(gray_image&gt;t);
</span><span class='line'>    temp1=mean(block(r1));
</span><span class='line'>    if isnan(temp1);
</span><span class='line'>        temp1=0;
</span><span class='line'>    end
</span><span class='line'>    temp2=mean(block(r2));
</span><span class='line'>    if isnan(temp2)
</span><span class='line'>        temp2=0;
</span><span class='line'>    end
</span><span class='line'>    t_new=(temp1+temp2)/2;
</span><span class='line'>    is_done=abs(t_new-t)&lt;1;%差异阈值是1
</span><span class='line'>    t=t_new;
</span><span class='line'>    count=count+1;
</span><span class='line'>    if count&gt;=1000
</span><span class='line'>        Error='Error:Cannot find the ideal threshold.'
</span><span class='line'>        return
</span><span class='line'>    end
</span><span class='line'>end
</span><span class='line'>[m,n]=size(gray_image);
</span><span class='line'>result=zeros(m,n)+255;
</span><span class='line'>result(r1)=0;
</span><span class='line'>% resule(r2)=255;
</span><span class='line'>result=uint8(result);
</span><span class='line'>figure
</span><span class='line'>imshow(result);</span></code></pre></td></tr></table></div></figure>


<p>1.2 局部阈值分割程序</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>original_image=imread('test1.png');
</span><span class='line'>gray_image=rgb2gray(original_image);
</span><span class='line'>gray_image=double(gray_image);
</span><span class='line'>[m,n]=size(gray_image);
</span><span class='line'>result=zeros(m,n);
</span><span class='line'>block_size=70;%分块大小
</span><span class='line'>for i=1:block_size:m
</span><span class='line'>    for j=1:block_size:n
</span><span class='line'>        if ((i+block_size)&gt;m)&&((j+block_size)&gt;n)
</span><span class='line'>            block=gray_image(i:end,j:end);
</span><span class='line'>        elseif ((i+block_size)&gt;m)&&((j+block_size)&lt;=n)
</span><span class='line'>            block=gray_image(i:end,j:j+block_size-1);
</span><span class='line'>        elseif ((i+block_size)&lt;=m)&&((j+block_size)&gt;n)
</span><span class='line'>            block=gray_image(i:i+block_size-1,j:end);
</span><span class='line'>        else
</span><span class='line'>            block=gray_image(i:i+block_size-1,j:j+block_size-1);
</span><span class='line'>        end
</span><span class='line'>        t=mean(block(:)); t_org=t; is_done=false; count=0;
</span><span class='line'>        while ~is_done
</span><span class='line'>            r1=find(block&lt;=t); r2=find(block&gt;t); temp1=mean(block(r1));
</span><span class='line'>            if isnan(temp1);
</span><span class='line'>                temp1=0;
</span><span class='line'>            end
</span><span class='line'>            temp2=mean(block(r2));
</span><span class='line'>            if isnan(temp2)
</span><span class='line'>                temp2=0;
</span><span class='line'>            end
</span><span class='line'>            t_new=(temp1+temp2)/2; is_done=abs(t_new-t)&lt;1; t=t_new;
</span><span class='line'>            count=count+1;
</span><span class='line'>            if count&gt;=1000
</span><span class='line'>                Error='Error:Cannot find the ideal threshold.'
</span><span class='line'>                return
</span><span class='line'>            end
</span><span class='line'>        end
</span><span class='line'>        block(r1)=0;
</span><span class='line'>        block(r2)=255;
</span><span class='line'>        if ((i+block_size)&gt;m)&&((j+block_size)&gt;n)
</span><span class='line'>            result(i:end,j:end)=block;
</span><span class='line'>        elseif ((i+block_size)&gt;m)&&((j+block_size)&lt;=n)
</span><span class='line'>            result(i:end,j:j+block_size-1)=block;
</span><span class='line'>        elseif ((i+block_size)&lt;=m)&&((j+block_size)&gt;n)
</span><span class='line'>            result(i:i+block_size-1,j:end)=block;
</span><span class='line'>        else
</span><span class='line'>            result(i:i+block_size-1,j:j+block_size-1)=block;
</span><span class='line'>        end
</span><span class='line'>    end
</span><span class='line'>end
</span><span class='line'>resule=uint8(result);
</span><span class='line'>figure
</span><span class='line'>imshow(result);</span></code></pre></td></tr></table></div></figure>


<p>对比结果：</p>

<p><img src="http://hujiaweibujidao.github.io/images/201403/whole.png" width="320" height="210"> <img src="http://hujiaweibujidao.github.io/images/201403/partial.png" width="320" height="210"></p>

<p>2.基于OSTU算法的自动阈值图像分割</p>

<p>[这块我还没有细究&hellip;To be continued&hellip;&hellip;]</p>

<p>Matlab内置的<code>graythresh</code>使用的便是OSTU算法，使得白色像素和黑色像素的类间方差最大。</p>

<p>因为上面测试图像的亮度存在明显的水平差异，所以我写了一个将图像沿水平方向分成几部分分别进行OSTU算法，效果明显又比上面两种方式要好些。</p>

<p><img src="http://hujiaweibujidao.github.io/images/201403/postu.png"></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function [ result ] = partialostu( image,part,isrgb )
</span><span class='line'>%PARTIALOSTU partial image ostu
</span><span class='line'>if isrgb
</span><span class='line'>    image=rgb2gray(image);
</span><span class='line'>end
</span><span class='line'>cols=size(image,2);
</span><span class='line'>result=zeros(size(image));
</span><span class='line'>for i=1:part
</span><span class='line'>    fstart=floor((i-1)*cols/part)+1;
</span><span class='line'>    fend=floor(i*cols/part);
</span><span class='line'>    f=image(:,fstart:fend);
</span><span class='line'>    t=graythresh(f);
</span><span class='line'>    f=im2bw(f,t);
</span><span class='line'>    result(:,fstart:fend)=f;
</span><span class='line'>end
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<p class='post-footer'>
                        Original link:<a href='http://hujiaweibujidao.github.io/blog/2014/03/30/matlab-image-segmentation/'>http://hujiaweibujidao.github.io/blog/2014/03/30/matlab-image-segmentation/</a><br/>Written by <a href='http://hujiaweibujidao.github.io'>hujiawei</a>&nbsp;Posted at <a href='http://hujiaweibujidao.github.io'>http://hujiaweibujidao.github.io</a><br/>Feel free to read or comment it, and if you want to copy it into your own site, please copy it with its Original Link showed above or you can see the license below for more details.<br />Thanks a lot. Hope you enjoy here! ^_^</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Material on Mobile Development]]></title>
    <link href="http://hujiaweibujidao.github.io/blog/2014/03/13/mobile-development-materials/"/>
    <updated>2014-03-13T20:28:00+08:00</updated>
    <id>http://hujiaweibujidao.github.io/blog/2014/03/13/mobile-development-materials</id>
    <content type="html"><![CDATA[<h3>Android部分</h3>

<h5>(1)网站类</h5>

<p>1.Android开发者：<a href="http://developer.android.com/index.html">http://developer.android.com/index.html</a></p>

<p>Google官方Android开发者网站，发布关于Android的最新信息，有最权威的<a href="http://developer.android.com/training/index.html">开发教程</a>和<a href="http://developer.android.com/guide/components/index.html">API手册</a>以及<a href="http://developer.android.com/design/index.html">应用设计教程</a>，还提供最新最强大的<a href="http://developer.android.com/tools/index.html">开发工具以及SDK</a>下载！</p>

<p>2.开源中国 Android开发专区：<a href="http://www.oschina.net/android">http://www.oschina.net/android</a></p>

<p>这里有关于Android开发的各种知识，小到环境搭建，大到细节实现，很多开发者在这里分享了自己的开发经验，所以如果在某个方面遇到了问题，没准可以在这里找到答案。</p>

<p>3.eoe移动开发者社区：<a href="http://android.eoe.cn/">http://android.eoe.cn/</a></p>

<p>国内最好的android开发社区，这里有类似开源中国中的<a href="http://www.eoe.cn/wiki/android.html">各类开发教程</a>，还有<a href="http://www.eoeandroid.com/portal.php?mod=topic&amp;topicid=7">eoe Android特刊</a>，不过后者已经很久没有更新了，社区比较好的是如果遇到什么实在解决不了的问题不妨试试在论坛中发帖询问下高手。</p>

<p>4.其他资源</p>

<p><a href="http://stackoverflow.com/">StackOverflow</a> 嘿嘿，没有它解决不了的问题！</p>

<p><a href="http://blog.daimajia.com/?page_id=60">Android 开源资料库</a>  开源资料不少，大部分都在Github上</p>

<h5>(2)书籍类</h5>

<p>1.<a href="http://book.douban.com/subject/6515839/">《疯狂Android讲义》</a></p>

<p>作者李刚，国内的Java领域大牛之一，著有多本疯狂系列的书籍，包括<a href="http://book.douban.com/subject/3246499/">《疯狂Java讲义》</a>、<a href="http://book.douban.com/subject/3333726/">《轻量级Java EE企业应用实战(第3版):Struts 2＋Spring 3＋Hibernate整合开发》</a>等等。
《疯狂Android讲义》这本书很厚，基本上覆盖了Android开发的所有内容，作者凭借丰富的教学经验对Android开发进行讲解，对于初学者可能遇到的各种问题和各种疑惑都意义进行了分析，内容足够深入，另外，此书还有几个实例项目进行实践，可以说，学习Android开发有这一本书足够了！如果感觉Java基础不足了，推荐看他的另一本Java巨著<a href="http://book.douban.com/subject/6515839/">《疯狂Java讲义》</a>，同样，学习Java只要看这本书就足够了！当然，最好还是看下<a href="http://book.douban.com/subject/2130190/">《Java编程思想》</a></p>

<p>2.其他书籍</p>

<p>[入门篇]人民邮电出版社：
<a href="http://book.douban.com/subject/3770255/">《Google Android开发入门与实战》</a>
<a href="http://book.douban.com/subject/3788013/">《Google Android SDK开发范例大全》</a></p>

<p>两本都是入门级别的书籍，而且两本时间有点早了，如果有新版本建议看新版本</p>

<p>[提高篇]电子工业出版社：
<a href="http://book.douban.com/subject/4251755/">《Android系统原理及开发要点详解》</a>
<a href="http://book.douban.com/subject/5907455/">《Android系统级深入开发》</a></p>

<p>两本书是同样两位作者写的，写的时间比较早了，内容不是很新鲜，但是还是很有参考价值，因为内容涉及到系统原理，所以并不简单，适合想了解系统原理，但是又不想精读系统原理</p>

<p>[深入篇]机械工业出版社：<a href="http://book.douban.com/subject/6802440/">《深入理解Android(卷一)》</a><a href="http://book.douban.com/subject/11542973/">《深入理解Android(卷二)》</a></p>

<p>作者邓凡平，深入理解Android姊妹篇，经典中的经典，对于深入理解Android很有帮助，两本书以源码分析的方式介绍Android了各个子系统，灰常深入，适合想精通系统原理 [这两本书我还没看]</p>

<p>如果真的想要深入Android系统原理的话不妨看下<a href="http://blog.csdn.net/luoshengyang/article/details/8923485">老罗是怎么做到的</a>，嘿嘿</p>

<p>其他的好书：<a href="http://book.douban.com/subject/20556210/">《Android软件安全与逆向分析》</a>
<a href="http://book.douban.com/subject/6047744/">《Android技术内幕》</a> 等等</p>

<p><a href="http://www.amazon.cn/s/ref=nb_sb_noss?__mk_zh_CN=%E4%BA%9A%E9%A9%AC%E9%80%8A%E7%BD%91%E7%AB%99&amp;url=search-alias%3Dstripbooks&amp;field-keywords=%E5%9B%BE%E7%81%B5%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%9B%E4%B9%A6%E2%80%A2%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97+android&amp;rh=n%3A658390051%2Ck%3A%E5%9B%BE%E7%81%B5%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%9B%E4%B9%A6%E2%80%A2%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97+android">图灵程序设计丛书•移动开发系列 Android</a></p>

<p>图灵系列的书籍都是灰常的经典，一本本都是好书，但是一个人时间精力有限，难以都看完，再加上这些书籍中的很多内容是重叠了的，所以要根据自己实际的开发需求来读相应的书籍</p>

<p>如果是进行Android NDK开发的话，推荐两本书籍：</p>

<p><a href="http://book.douban.com/subject/20285069/">《Pro Android C++ with the NDK》</a> <a href="http://book.douban.com/subject/20469441/">《Mastering OpenCV with Practical Computer Vision Projects》</a></p>

<h4>Android学习总结：先专注于某本入门书籍，细读它，理解大部分内容，如果原书有源码，建议实际运行看下结果，如果原书有项目实践，建议跟着作者的步骤一步步完成。另外，读书建议先粗略读，然后细读，这样前面不懂的小知识马上就解决了，不用花时间纠缠于某个小问题，要提高读书效率。读完了入门级书之后建议自己找个项目做做，可以是小游戏，也可以是小应用，然后开始看提高篇或者深入篇的书籍。</h4>

<hr />

<h3>iOS部分</h3>

<h5>(1)网站类</h5>

<p>1.Apple iOS Dev Center：<a href="https://developer.apple.com/devcenter/ios/index.actions">https://developer.apple.com/devcenter/ios/index.action</a></p>

<p>苹果官方iOS开发网址，最新的资讯、教程、开发工具</p>

<p>2.开源中国 iOS专区：<a href="http://www.oschina.net/ios/home">http://www.oschina.net/ios/home</a></p>

<p>丰富的开发教程和开发资源，遇到什么问题可以在这里找找教程</p>

<p>3.Cocoa China：<a href="http://www.cocoachina.com/">http://www.cocoachina.com/</a></p>

<p>中国最大的iOS开发网站，这里真的是什么都有哟，亲！</p>

<p>4.其他资源</p>

<p><a href="http://code4app.com/">找代码？看这里->Code4App</a></p>

<p><a href="http://ui4app.com/">找资源？看这里->UI4App</a></p>

<h5>(2)书籍类</h5>

<p><a href="http://book.douban.com/subject/4813265/">《Head First iPhone and iPad Development》</a></p>

<p>iOS开发不仅开发的成本很高，入门的门槛也比较高，如果喜欢Head First系列书籍的话不妨先看下这本</p>

<p><a href="http://book.douban.com/subject/19953782/">《iOS 6 Programming Cookbook》</a></p>

<p>这本书介绍的是iOS6编程，虽然现在最新的是iOS7了，但是变化不大，大多数iOS开发书籍是介绍iOS4或者iOS5开发，但是不同版本差异还是比较大，所以推荐看iOS6及以上版本的iOS编程的书籍</p>

<p><a href="http://book.douban.com/subject/24846574/">《iOS开发指南：从零基础到App Store上架》</a></p>

<p>今年出的新书，内容非常详细，作者是关东升，国内知名的iOS开发专家，可以搜到他的新浪微博，他专注于iOS开发，录制过一些iOS开发视频  [这本书我没读过，还没看到过]</p>

<p><a href="http://book.douban.com/subject/25767591/">《疯狂iOS 讲义（上） Objective-C 2.0与iPhone/iPad应用开发基础》</a></p>

<p>李刚老师估计闲不下来，嘿嘿，这是他的新书，貌似要出版了，自然要赞！</p>

<p>其他书籍： [我没怎么读过]</p>

<p><a href="http://book.douban.com/subject_search?search_text=iOS&amp;cat=1001">豆瓣书籍：iOS开发</a></p>

<h4>iOS学习总结：对于iOS开发我还没有完整入门，只是看了英文原汁原味的《iOS 6 Programming Cookbook》，这本书还是很不错的，分不同的开发内容进行讲解，但对于入门还是不够的，我自己读的时候写了些<a href="http://hujiaweiyinger.diandian.com/post/2013-06-04/ios6_list">读书笔记</a>，不嫌难看不妨参考下，嘿嘿。建议先搞懂Objective-C，然后再开始学习iOS开发，不要直接就学习iOS开发，没打好地基是建不了摩天大厦的！另外，开发成本略高，需要苹果机，装黑苹果麻烦，速度还慢，量力而行 O(∩_∩)O</h4>

<hr />

<h3>Windows Phone部分</h3>

<p>需要熟悉微软的.NET平台，语言主要是C#，目前Windows Phone资料不算多，图书馆里也就几本书籍，很容易找到那些常见的资源，我没有研究过，在此就不详细提了</p>

<p><a href="http://developer.windowsphone.com/zh-cn">Microsoft Windows Phone Developer 开发者网站</a></p>

<p><a href="http://book.douban.com/subject_search?search_text=Windows+Phone&amp;cat=1001">豆瓣书籍：Windows Phone开发</a></p>

<p>OK！差不多就这些了，有什么问题请<a href="mailto:hujiawei090807@gmail.com">通过邮件联系我</a>，谢谢！</p>

<p>[附上两周的Android入门课件和演示应用魔力8号球的源码]</p>

<p><a href="http://hujiaweibujidao.github.io/files/android01.pdf">Android入门课程(上)</a></p>

<p><a href="http://hujiaweibujidao.github.io/files/android02.pdf">Android入门课程(下)</a></p>

<p><a href="http://hujiaweibujidao.github.io/files/magic8.zip">魔力8号球源码</a></p>

<p class='post-footer'>
                        Original link:<a href='http://hujiaweibujidao.github.io/blog/2014/03/13/mobile-development-materials/'>http://hujiaweibujidao.github.io/blog/2014/03/13/mobile-development-materials/</a><br/>Written by <a href='http://hujiaweibujidao.github.io'>hujiawei</a>&nbsp;Posted at <a href='http://hujiaweibujidao.github.io'>http://hujiaweibujidao.github.io</a><br/>Feel free to read or comment it, and if you want to copy it into your own site, please copy it with its Original Link showed above or you can see the license below for more details.<br />Thanks a lot. Hope you enjoy here! ^_^</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Develop with OpenCV on Mac]]></title>
    <link href="http://hujiaweibujidao.github.io/blog/2014/03/13/develop-with-opencv-on-mac-os-x/"/>
    <updated>2014-03-13T19:23:00+08:00</updated>
    <id>http://hujiaweibujidao.github.io/blog/2014/03/13/develop-with-opencv-on-mac-os-x</id>
    <content type="html"><![CDATA[<p>今天大部分时间都是在琢磨如何在Mac OS X上进行OpenCV项目的开发，尝试的开发工具有Xcode(版本是4.6.1)和Eclipse，使用的OpenCV版本是2.4.6。</p>

<p>如果只是需要OpenCV的相关头文件以及动态库，请直接执行<code>brew install opencv</code>（如果安装了Homebrew的话），如果不行，请看下面的OpenCV源码编译安装过程。</p>

<h4>1.安装CMake</h4>

<p>安装CMake可以使用MacPorts，也可以使用Homebrew，如果以前安装过两者中的任何一个就用那个进行安装吧，我用的是Homebrew，推荐使用Homebrew，真正的“佳酿”，命令如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo port install cmake //macports
</span><span class='line'>sudo brew install cmake //homebrew</span></code></pre></td></tr></table></div></figure>


<h4>2.编译OpenCV</h4>

<p>OpenCV下载地址：<a href="http://sourceforge.net/projects/opencvlibrary/">http://sourceforge.net/projects/opencvlibrary/</a></p>

<p>目前最新版本是2.4.8，我使用的是2.4.6，下载后解压，执行下面代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd &lt;path-to-opencv-source&gt;
</span><span class='line'>mkdir release
</span><span class='line'>cd release
</span><span class='line'>cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local .. 
</span><span class='line'>make
</span><span class='line'>sudo make install</span></code></pre></td></tr></table></div></figure>


<p>[完成之后在<code>/usr/local/include</code>目录下便有了<code>opencv</code>和<code>opencv2</code>两个目录，在<code>/usr/local/lib</code>目录下有很多的<code>opencv</code>相关的动态库，例如<code>libopencv_core.dylib</code>等等，还有几个其他的文件，它们都存放在<code>/usr/local</code>目录下]</p>

<p>[注1:如果不需要了，想要卸载 OpenCV的话，可以回到<code>release</code>目录，执行<code>sudo make uninstall</code>，然后手动删除一些<code>/usr/local</code>下与OpenCV有关的目录和文件]</p>

<p>[注2:如果不想把OpenCV安装在默认的<code>/usr/local/</code>目录下的话，例如为了防止Homebrew中对opencv部分的报错，而又无法使用Homebrew正常安装opencv的情况下，可以考虑将opencv安装到其他的位置，修改<code>CMAKE_INSTALL_PREFIX=/usr/local</code>即可，但是在Eclipse中的项目中可能会出现问题，详情看后面]</p>

<p>其他参考内容：</p>

<p><a href="http://docs.opencv.org/trunk/doc/tutorials/introduction/linux_install/linux_install.html#linux-installation">Building OpenCV from Source Using CMake, Using the Command Line</a></p>

<p><a href="https://sites.google.com/site/learningopencv1/installing-opencv">Installing OpenCV</a></p>

<h4>3.使用Xcode进行OpenCV项目开发</h4>

<p>1.Open Xcode, choose <code>New  -&gt; New Project -&gt; Command Line Tool</code></p>

<p>2.Name it and select <code>C++</code> for type</p>

<p>3.Click on your project from the left menu. Click the <code>build settings</code> tab from the top. Filter all. Scroll to <code>Search Paths</code>. Under <code>header search paths</code>, for debug and release, set the path to <code>/usr/local/include</code>. Under <code>library search paths</code>, set the path to <code>$(PROJECT_DIR)</code>. Finally, check if <code>C++ standard library</code> is <code>libstdc++</code> or not, if not, change it to this!</p>

<p>4.Click on your project from the left menu. <code>File-&gt;New-&gt;New Group</code>, Name the group <code>OpenCV Frameworks</code>.</p>

<p>5.Select the folder (group) you just labeled, <code>OpenCV Frameworks</code> in the left menu. Go to <code>File -&gt; add Files</code>, Type <code>/</code>, which will allow you to manually go to a folder. Go to &ndash;> <code>/usr/local/lib</code></p>

<p>6.Select both of these files, <code>libopencv_core.dylib</code>, <code>libopencv_highgui.dylib</code>, and click <code>Add</code>. (you may need to add other library files from this folder to run other code.)</p>

<p>7.You must include this line of code in the beginning of your main.cpp file:
<code>#include &lt;opencv2/opencv.hpp&gt;</code></p>

<p>可以修改main.cpp，代码如下，运行结果就是显示一张指定的图片。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;opencv2/opencv.hpp&gt;
</span><span class='line'>using namespace cv;
</span><span class='line'>int main(int argc, char** argv) {
</span><span class='line'>  Mat image;
</span><span class='line'>  image = imread("/Users/hujiawei/Pictures/others/other_naicha/naicha.jpg", 1);
</span><span class='line'>    namedWindow("Display Image", WINDOW_AUTOSIZE);
</span><span class='line'>  imshow("Display Image", image);
</span><span class='line'>  waitKey(0);
</span><span class='line'>  return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>其他参考内容：</p>

<p><a href="http://stackoverflow.com/questions/19637164/c-linking-error-after-upgrading-to-mac-os-x-10-9-xcode-5-0-1">C++ linking error after upgrading to Mac OS X 10.9 / Xcode 5.0.1</a></p>

<p><a href="http://mathematica.stackexchange.com/questions/34692/mathlink-linking-error-after-os-x-10-9-mavericks-upgrade">MathLink linking error after OS X 10.9 (Mavericks) upgrade</a></p>

<h4>4.使用Eclipse进行OpenCV项目开发</h4>

<p>如果使用Eclipse开发的话按照下面的步骤进行：</p>

<p>1.按照正常的步骤，使用Eclipse建立一个<code>Mac C++</code>工程，包含一个cpp文件</p>

<p>2.右击工程名, 选择<code>Properties</code>，在属性配置页中选择，点击<code>C/C++ Build</code>, 在下拉选项中选择 <code>Settings</code>. 在右边的选项卡中选择 <code>Tool Settings</code>。</p>

<p>3.在<code>GCC C++ Compiler</code>选项列表中选择<code>Includes</code>，在<code>Include paths(-l)</code>中添加安装好的opencv的头文件存放目录：<code>/usr/local/include/</code> [存放opencv头文件的目录，自行看情况而定]</p>

<p>4.在<code>MacOS X C++Linker</code>选项列表中选择<code>Library</code>，在<code>Library search path (-L)</code>中添加安装好的opencv dylib文件存放目录：<code>/usr/local/lib/</code> [<strong><em>经过我的测试只能是这个目录！其他目录甚至是它的子目录都不行！如果在其他路径中，复制过来也行！</em></strong>]</p>

<p>5.在<code>MacOS X C++Linker</code>选项列表中选择<code>Library</code>, 在<code>Libraries(-l)</code> 中依次点击<code>＋</code>号，添加需要使用的lib文件(通常情况下，使用前三个，注意不要包括前缀<code>lib</code>，可以添加版本号)：</p>

<p>opencv_core opencv_imgproc opencv_highgui opencv_ml opencv_video opencv_features2d opencv_calib3d opencv_objdetect opencv_contrib opencv_legacy opencv_flann</p>

<p>6.重新build项目即可。</p>

<p>如果遇到问题<code>ld: symbol(s) not found for architecture x86_64</code>，先检查代码中是否需要包含还没有添加的库文件，再检查是否是其他问题。如果是Mac平台，下面还有一个关于问题<code>ld: symbol(s) not found for architecture x86_64</code>的解释可供参考：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>There are two implementations of the standard C++ library available on OS X: libstdc++ and libc++. They are not binary compatible and libMLi3 requires libstdc++.
</span><span class='line'>On 10.8 and earlier libstdc++ is chosen by default, on 10.9 libc++ is chosen by default. To ensure compatibility with libMLi3, we need to choose libstdc++ manually.
</span><span class='line'>To do this, add -stdlib=libstdc++ to the linking command.</span></code></pre></td></tr></table></div></figure>


<p>更多相关内容参考：</p>

<p><a href="http://blog.sciencenet.cn/blog-702148-657754.html">http://blog.sciencenet.cn/blog-702148-657754.html</a></p>

<h5>5.阅读开源项目</h5>

<p>阅读开源项目<a href="https://github.com/MasteringOpenCV/code">Mastering OpenCV with Practical Computer Vision Projects</a>中的代码，以第8章Face Recognition using Eigenfaces or Fisherfaces为例</p>

<p>编写一个shell，内容如下(修改自<code>README.txt</code>)，其中的<code>OpenCV_DIR</code>为OpenCV源码编译后得到的文件夹(如上面的release目录)，执行这个shell便可以得到Xcode项目，当然打开这个项目之后还要修改相应的配置。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>export OpenCV_DIR="/Volumes/hujiawei/Users/hujiawei/Android/opencv-2.4.6.1/build"
</span><span class='line'>mkdir build
</span><span class='line'>cd build
</span><span class='line'>cp $OpenCV_DIR/../data/lbpcascades/lbpcascade_frontalface.xml .
</span><span class='line'>cp $OpenCV_DIR/../data/haarcascades/haarcascade_eye.xml .
</span><span class='line'>cp $OpenCV_DIR/../data/haarcascades/haarcascade_eye_tree_eyeglasses.xml .
</span><span class='line'>cmake -G Xcode -D OpenCV_DIR=$OpenCV_DIR ..</span></code></pre></td></tr></table></div></figure>


<p class='post-footer'>
                        Original link:<a href='http://hujiaweibujidao.github.io/blog/2014/03/13/develop-with-opencv-on-mac-os-x/'>http://hujiaweibujidao.github.io/blog/2014/03/13/develop-with-opencv-on-mac-os-x/</a><br/>Written by <a href='http://hujiaweibujidao.github.io'>hujiawei</a>&nbsp;Posted at <a href='http://hujiaweibujidao.github.io'>http://hujiaweibujidao.github.io</a><br/>Feel free to read or comment it, and if you want to copy it into your own site, please copy it with its Original Link showed above or you can see the license below for more details.<br />Thanks a lot. Hope you enjoy here! ^_^</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[android ndk and opencv development 4]]></title>
    <link href="http://hujiaweibujidao.github.io/blog/2014/02/21/android-ndk-and-opencv-development-4/"/>
    <updated>2014-02-21T10:15:00+08:00</updated>
    <id>http://hujiaweibujidao.github.io/blog/2014/02/21/android-ndk-and-opencv-development-4</id>
    <content type="html"><![CDATA[<h4>Android NDK与OpenCV的整合开发环境搭建</h4>

<p>以XFace项目为例，虚拟机的操作系统为64位的Ubuntu 12.04，用户名和密码都是xface</p>

<p>为便于开始进行XFace人脸识别系统研发，提供了已配置好安卓开发环境的Linux系统（64位的Ubuntu 12.04）虚拟机，在安装好VMware（版本在VMware 8以上）之后，打开Ubuntu 64 xface.vmwarevm目录中Ubuntu 64 xface.vmx，以用户名<code>xface</code>及密码<code>xface</code>登录后，直接打开桌面上的<code>Link to eclipse</code>，便可按本文档第二部分第3步运行XFace工程。如果想要自己搭建开发环境，请从第一部分开始做起。</p>

<h5>第一部分 搭建环境</h5>

<hr />

<p><strong><em>[注：以下所有下载的sdk都保存在虚拟机的<code>/home/xface/tools</code>目录下，也可以到百度网盘下载，地址是<a href="http://pan.baidu.com/s/1mg2Wdx2">http://pan.baidu.com/s/1mg2Wdx2</a>，不同版本的配置方式可能有些变化，如果不是很清楚版本问题的话，推荐使用虚拟机中使用的版本]</em></strong></p>

<p><img src="http://hujiaweibujidao.github.io/images/201402/tools.png"></p>

<p>1.配置Java环境</p>

<p>①下载<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">Oracle JDK</a>，虚拟机中下载的版本是JDK1.7.0_40</p>

<p>②下载之后解压即可，解压路径为<code>/home/xface/android/jdk1.7.0</code></p>

<p>③打开终端，输入<code>sudo gedit /etc/profile</code>，在文件末尾添加下面内容</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>JAVA_HOME=/home/xface/android/jdk1.7.0
</span><span class='line'>export PATH=$JAVA_HOME/bin:$PATH</span></code></pre></td></tr></table></div></figure>


<p>如下图所示，后面环境配置中添加内容也是如此</p>

<p><img src="http://hujiaweibujidao.github.io/images/201402/etcprofile.png"></p>

<p>④重启虚拟机，打开终端输入<code>java -version</code>进行测试（重启虚拟机也可以等待下面的Android SDK和Android NDK环境都配置好了之后再重启也行）</p>

<p><img src="http://hujiaweibujidao.github.io/images/201402/javaversion.png"></p>

<p>2.配置Android SDK环境</p>

<p>①下载<a href="https://developer.android.com/sdk/index.html">Android Developer Tools</a>，虚拟机中下载的是20130729版本</p>

<p>②下载之后解压即可，解压路径为<code>/home/xface/android/adt-bundle</code></p>

<p>③打开终端，输入<code>sudo gedit /etc/profile</code>，在文件末尾添加下面内容</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ANDROID_SDK_ROOT=/home/xface/android/adt-bundle/sdk
</span><span class='line'>export PATH=${PATH}:${ANDROID_SDK_ROOT}/platform-tools:${ANDROID_SDK_ROOT}/tools</span></code></pre></td></tr></table></div></figure>


<p>④因为Android SDK是32位的，而虚拟机中Ubuntu系统是64位的，所以需要添加ia32-libs库，在终端中执行下面命令（需要耗费漫长的时间等待）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo apt-get update
</span><span class='line'>sudo apt-get install ia32-libs</span></code></pre></td></tr></table></div></figure>


<p>⑤重启虚拟机，打开终端输入<code>adb version</code>进行测试</p>

<p><img src="http://hujiaweibujidao.github.io/images/201402/adbversion.png"></p>

<p>3.配置Android NDK环境</p>

<p>①下载<a href="https://developer.android.com/tools/sdk/ndk/index.html">Android NDK</a>，虚拟机中下载的是r9c版本</p>

<p>②下载之后解压即可，解压路径为<code>/home/xface/android/adt-bundle/ndk</code></p>

<p>③打开终端，输入<code>sudo gedit /etc/profile</code>，在文件末尾添加下面内容</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ANDROID_NDK_ROOT=/home/xface/android/adt-bundle/ndk
</span><span class='line'>export PATH=${PATH}:${ANDROID_NDK_ROOT}</span></code></pre></td></tr></table></div></figure>


<p>④重启虚拟机，打开终端输入<code>ndk-build -v</code>进行测试</p>

<p><img src="http://hujiaweibujidao.github.io/images/201402/ndkversion.png"></p>

<p>4.配置OpenCV环境</p>

<p>①下载<a href="http://sourceforge.net/projects/opencvlibrary/files/opencv-android/">OpenCV for Android</a>，虚拟机中使用的是2.4.4版本</p>

<p>②下载之后解压即可，解压路径为<code>/home/xface/android/opencv_sdk</code></p>

<p>5.配置ADT开发环境</p>

<p>①运行<code>/home/xface/android/adt-bundle/eclipse</code>目录中的eclipse程序，设置默认的工作空间的路径，虚拟机中设置的路径为<code>/home/xface/android/workspace</code></p>

<p>②打开<code>window-&gt;preferences</code>，查看Android SDK和NDK的配置，如果路径有问题则需要修改过来</p>

<p>Android SDK路径的设置</p>

<p><img src="http://hujiaweibujidao.github.io/images/201402/androidsdk.png"></p>

<p>Android NDK路径的设置</p>

<p><img src="http://hujiaweibujidao.github.io/images/201402/androidndk.png"></p>

<p>③打开<code>window-&gt;preferences</code>，找到左侧的<code>C/C++ Build-&gt;Environment</code>添加下面两个环境变量：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NDKROOT=/home/xface/android/adt-bundle/ndk
</span><span class='line'>OPENCVROOT=/home/xface/android/opencv_sdk</span></code></pre></td></tr></table></div></figure>


<p><img src="http://hujiaweibujidao.github.io/images/201402/environment.png"></p>

<p>④按如下步骤配置<strong>万能的javah工具</strong>的方法（这里javah工具的用途是根据Java类生成C++头文件）</p>

<p>(1)在菜单<code>Run</code>&ndash;><code>External Tools</code>&ndash;><code>External Tools Configurations</code>中新建<code>Program</code>，命名为<code>javah</code></p>

<p>(2)<code>Location</code>设置为<code>/usr/bin/javah</code> [如果javah命令不是在这个位置，可以试试<code>${system_path:javah}</code>]</p>

<p>(3)<code>Working Directory</code>设置为<code>${project_loc}/bin/classes</code> [适用于Android项目开发]</p>

<p>(4)<code>Arguments</code>设置为<code>-jni -verbose -d "${project_loc}${system_property:file.separator}jni" ${java_type_name}</code></p>

<p>(5)OK，以后只要选中要进行&#8221;反编译&#8221;的Java Class，然后运行这个External Tool就可以了！</p>

<p><img src="http://hujiaweibujidao.github.io/images/201402/javah.png"></p>

<p>⑤为了提高编写代码的速度，打开<code>window-&gt;preferences</code>，找到左侧<code>Java-&gt;Editor-&gt;Content Assist</code>，在<code>Auto activation triggers for Java</code>中添加26个英文字母，这样，在编写Java代码时任何一个字母被按下的话都会出现智能代码提示。</p>

<p><img src="http://hujiaweibujidao.github.io/images/201402/codeassist.png"></p>

<p>⑥为了验证环境没有问题，可以尝试新建一个Android Project并运行于移动设备上，虚拟机中eclipse下的项目xfacetest便是用来测试环境是否配置成功的默认Android应用程序，可以尝试插上手机，选中项目xfacetest点击右键，选择<code>Run As</code> &ndash;> <code>Android Application</code>，如果都没问题了，说明开发环境搭建成功了。</p>

<h5>第二部分 运行XFace</h5>

<hr />

<p><strong><em>[注：实验使用的XFace项目源代码是稍微精简的版本，可以到百度网盘下载，地址是<a href="http://pan.baidu.com/s/1mg2Wdx2">http://pan.baidu.com/s/1mg2Wdx2</a>，下载之后解压即可，原始的XFace项目托管于Github，地址是<a href="http://github.com/hujiaweibujidao/XFace.git">http://github.com/hujiaweibujidao/XFace.git</a>]</em></strong></p>

<p>XFace是一个小型的人脸识别程序，主要功能就是注册和识别人脸，界面分为3个，首先是主界面，使用者选择要进行的操作，sign up是注册，输入用户名然后保存头像即可；sign in是登录，其实就是人脸识别的过程。</p>

<p><img src="http://hujiaweibujidao.github.io/images/201402/xface.png"></p>

<p>XFace的源码保存在虚拟机中<code>/home/xface/android/xface</code>目录下，包括两个项目，一个是<code>OpenCV Library - 2.4.4</code>，这是XFace所需的OpenCV库项目，另一个是<code>XFace</code>，这个XFace核心的Android应用程序。下面介绍如何将这两个项目导入到Eclipse开发环境中，并在手机上运行。</p>

<p>1.运行Eclipse，选择<code>File-&gt;Import...</code>，在导入窗口中，选择<code>General</code>下面的<code>Existing Projects into Workspace</code>，然后点击<code>Next-&gt;</code>，在之后的窗口中，点击<code>Browser...</code>，选中<code>/home/xface/android/xface/</code>下的<code>OpenCV Library - 2.4.4</code>文件夹，建议勾选<code>Copy projects into workspace</code>（可以防止意外操作导致项目出现问题无法修复时可以删除该项目重新将其导入进来），点击<code>Finish</code>即可，如下图所示：</p>

<p><img src="http://hujiaweibujidao.github.io/images/201402/import.png"></p>

<p>2.按照步骤1中的导入操作导入<code>/home/xface/android/xface/</code>下的<code>XFace</code>项目，导入之后，如果报出问题，可以尝试以下步骤：选中项目<code>XFace</code>，点击右键，选择<code>Properties</code>，在属性配置窗口中，选择左侧的<code>Android</code>项，查看下面的<code>Library</code>的配置，如果有错误，则选中错误的项，点击<code>Remove</code>；如果内容为空则点击<code>Add...</code>，在弹出的窗口中选中步骤1中添加的<code>OpenCV Library - 2.4.4</code>项目即可，效果如下图所示：</p>

<p><img src="http://hujiaweibujidao.github.io/images/201402/library.png"></p>

<p>3.至此，开发环境搭建和项目导入部分都完成了，下面可以进行XFace程序了。首先插入设备（手机），如果是在虚拟机中运行，要确保手机是和虚拟机连接的，而不是和主机连接的（可以通过虚拟机右下角状态栏中<code>USB设备按钮</code>或者菜单<code>虚拟机</code>中的<code>USB和Bluetooth</code>进行设置）；然后，选中<code>XFace</code>项目，点击右键，选择<code>Run As -&gt; Android Application</code>，然后选中插入的手机，点击<code>OK</code>即可。有些情况下可能在列表中没有出现设备，可以尝试以下步骤：首先要确保手机开启了USB调试功能(一般是<code>设置</code>&ndash;><code>开发人员选项</code>&ndash;>选中<code>USB调试</code>)；其次可以尝试重新插入手机或者重启Eclipse；若还是不行尝试在终端输入<code>adb kill-server</code>和<code>adb devices</code>命令；若还是不行的话尝试重启电脑。实在是不行的话，将编译好的apk文件（保存在项目的<code>bin</code>目录下）拷贝到手机中直接运行。</p>

<h5>第三部分 XFace分析</h5>

<hr />

<p>1.项目结构和主要文件功能大致介绍</p>

<p><img src="http://hujiaweibujidao.github.io/images/201402/xfacecode.png"></p>

<p>2.关键部分介绍</p>

<p>(1)<code>jni</code>下的<code>edu_thu_xface_libs_XFaceLibrary.h</code>文件是由Java类<code>XFaceLibrary.java</code>通过javah工具生成的（现在要想重新生成需要将非native方法注释起来），Java类只是定义了三个重要的<code>native</code>方法，实际调用的是实现了头文件<code>edu_thu_xface_libs_XFaceLibrary.h</code>的另一个C++文件<code>xface.cpp</code>。</p>

<p>三个<code>native</code>方法如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static native long nativeInitFacerec(String datapath, String modelpath, int component, double threshold,
</span><span class='line'>      int facerec);
</span><span class='line'>public static native int nativeFacerec(long xfacerec, String modelpath, long addr, int width, int height);
</span><span class='line'>public static native int nativeDestoryFacerec(long xfacerec);</span></code></pre></td></tr></table></div></figure>


<p>对应得到的头文件中的三个方法（注意：这里方法的名称和参数类型都是严格遵守JNI规范的，不能随便修改）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*
</span><span class='line'> * Class:     edu_thu_xface_libs_XFaceLibrary
</span><span class='line'> * Method:    nativeInitFacerec
</span><span class='line'> * Signature: (Ljava/lang/String;Ljava/lang/String;IDI)J
</span><span class='line'> */
</span><span class='line'>JNIEXPORT jlong JNICALL Java_edu_thu_xface_libs_XFaceLibrary_nativeInitFacerec
</span><span class='line'>  (JNIEnv *, jclass, jstring, jstring, jint, jdouble, jint);
</span><span class='line'>/*
</span><span class='line'> * Class:     edu_thu_xface_libs_XFaceLibrary
</span><span class='line'> * Method:    nativeFacerec
</span><span class='line'> * Signature: (JLjava/lang/String;JII)I
</span><span class='line'> */
</span><span class='line'>JNIEXPORT jint JNICALL Java_edu_thu_xface_libs_XFaceLibrary_nativeFacerec
</span><span class='line'>  (JNIEnv *, jclass, jlong, jstring, jlong, jint, jint);
</span><span class='line'>/*
</span><span class='line'> * Class:     edu_thu_xface_libs_XFaceLibrary
</span><span class='line'> * Method:    nativeDestoryFacerec
</span><span class='line'> * Signature: (J)I
</span><span class='line'> */
</span><span class='line'>JNIEXPORT jint JNICALL Java_edu_thu_xface_libs_XFaceLibrary_nativeDestoryFacerec
</span><span class='line'>  (JNIEnv *, jclass, jlong);</span></code></pre></td></tr></table></div></figure>


<p>第一个方法是初始化人脸识别模块，参数分别是：datapath是已有的人脸数据保存的文件路径；modelpath是已生成的人脸识别模块保存的文件路径；component是人脸识别算法中使用的一个参数，表示主成分数；threshold也是人脸识别算法中使用的一个参数，表示阈值。后面两个参数目前都是使用默认值，分别是10和0.0。</p>

<p>第二个方法是人脸识别算法，参数分别是：xfacerec人脸识别算法模块对象的内存地址，之前的尝试，目前没有用了，可以忽视；modelpath是创建的人脸识别模块数据的文件保存的路径；addr是当前摄像头得到的一帧图片的灰度图像的内存地址；width和height分别是要进行识别的人脸图片压缩之后的大小，目前是240*360。</p>

<p>第三个方法是销毁人脸识别对象的方法，主要用于释放JNI层中开辟的内存空间。</p>

<p>(2)分析<code>FacerecCameraActivity</code>类</p>

<p>①人脸检测模块</p>

<p>这部分最重要的是<code>private CascadeClassifier mJavaDetector;</code>字段，它的初始化过程在方法<code>onCreate(Bundle savedInstanceState)</code>中，这里使用了重要的<code>lbpcascade_frontalface.yml</code>文件，该文件原本存放在<code>res/raw</code>目录下，初始化过程中将其拷贝到了SD卡中，并使用这个文件创建了<code>CascadeClassifier</code>。代码片段：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>try {
</span><span class='line'>  // File cascadeDir = getDir("cascade", Context.MODE_PRIVATE);
</span><span class='line'>  mCascadeFile = new File(CommonUtil.LBPCASCADE_FILEPATH);
</span><span class='line'>  if (!mCascadeFile.exists()) {// if file not exist, load from raw, otherwise, just use it!
</span><span class='line'>      // load cascade file from application resources
</span><span class='line'>      InputStream is = getResources().openRawResource(R.raw.lbpcascade_frontalface);
</span><span class='line'>      // mCascadeFile = new File(cascadeDir, "lbpcascade_frontalface.xml");
</span><span class='line'>      FileOutputStream os = new FileOutputStream(mCascadeFile);
</span><span class='line'>      byte[] buffer = new byte[4096];
</span><span class='line'>      int bytesRead;
</span><span class='line'>      while ((bytesRead = is.read(buffer)) != -1) {
</span><span class='line'>          os.write(buffer, 0, bytesRead);
</span><span class='line'>      }
</span><span class='line'>      is.close();
</span><span class='line'>      os.close();
</span><span class='line'>  }
</span><span class='line'>  mJavaDetector = new CascadeClassifier(mCascadeFile.getAbsolutePath());
</span><span class='line'>  if (mJavaDetector.empty()) {
</span><span class='line'>      Log.e(TAG, "Failed to load cascade classifier");
</span><span class='line'>      mJavaDetector = null;
</span><span class='line'>  } else
</span><span class='line'>      Log.i(TAG, "Loaded cascade classifier from " + mCascadeFile.getAbsolutePath());
</span><span class='line'>  // mNativeDetector = new DetectionBasedTracker(mCascadeFile.getAbsolutePath(), 0);// hujiawei
</span><span class='line'>  // cascadeDir.delete();//
</span><span class='line'>} catch (IOException e) {
</span><span class='line'>  e.printStackTrace();
</span><span class='line'>  Log.e(TAG, "Failed to load cascade. Exception thrown: " + e);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>最后在摄像头的回调方法<code>onCameraFrame(CvCameraViewFrame inputFrame)</code>中对摄像头得到的图片帧进行人脸检测，将检测出来的人脸方框直接绘制在图片帧上立刻显示出来（该方法会在每次摄像头有新的一帧）。代码片段如下，其中mRgba是每次得到的图片的RGBA格式，mGray是每次得到的图片的灰度格式</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public Mat onCameraFrame(CvCameraViewFrame inputFrame) {
</span><span class='line'>  // Log.i(TAG, inputFrame.gray().width() + "" + inputFrame.gray().height());
</span><span class='line'>  // landscape 640*480 || portrait [320*240]-&gt; 240*320!
</span><span class='line'>  // when portrait mode, inputframe is 320*240, so pic is rotated!
</span><span class='line'>  mRgba = inputFrame.rgba();
</span><span class='line'>  mGray = inputFrame.gray();
</span><span class='line'>  Core.flip(mRgba.t(), mRgba, 0);//counter-clock wise 90
</span><span class='line'>  Core.flip(mGray.t(), mGray, 0);
</span><span class='line'>  if (mAbsoluteFaceSize == 0) {
</span><span class='line'>      int height = mGray.rows();
</span><span class='line'>      if (Math.round(height * mRelativeFaceSize) &gt; 0) {
</span><span class='line'>          mAbsoluteFaceSize = Math.round(height * mRelativeFaceSize);
</span><span class='line'>      }
</span><span class='line'>      // mNativeDetector.setMinFaceSize(mAbsoluteFaceSize);//
</span><span class='line'>  }
</span><span class='line'>  MatOfRect faces = new MatOfRect();
</span><span class='line'>  if (mJavaDetector != null) {// use only java detector
</span><span class='line'>      mJavaDetector.detectMultiScale(mGray, faces, 1.1, 2, 2, // TODO: objdetect.CV_HAAR_SCALE_IMAGE
</span><span class='line'>              new Size(mAbsoluteFaceSize, mAbsoluteFaceSize), new Size());
</span><span class='line'>  }
</span><span class='line'>  Rect[] facesArray = faces.toArray();
</span><span class='line'>  for (int i = 0; i &lt; facesArray.length; i++) {
</span><span class='line'>      Core.rectangle(mRgba, facesArray[i].tl(), facesArray[i].br(), FACE_RECT_COLOR, 3);
</span><span class='line'>  }
</span><span class='line'>  Core.flip(mRgba.t(), mRgba, 1);//counter-clock wise 90
</span><span class='line'>  Core.flip(mGray.t(), mGray, 1);
</span><span class='line'>  return mRgba;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>②人脸识别模块</p>

<p>因为人脸识别过程需要耗费一定的时间，如果每次图片帧传入的时候便进行处理，处理完了之后再显示的话会导致界面卡死，所以人脸识别过程是在另开辟的一个线程中执行的，线程代码如下，只要摄像头还在工作，也就是还会传回图像的话，那么这个线程便会取出其灰度图像传入到JNI层进行人脸识别操作，并将结果显示出来，此处消息的传递方式使用的是Android中的Handler机制。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>new Thread(new Runnable() {
</span><span class='line'>  public void run() {
</span><span class='line'>      Log.i(TAG, "bInitFacerec= " + bInitFacerec + " $$ bExitRecognition= " + bExitRecognition
</span><span class='line'>              + " $$ frameprocessing=" + bFrameProcessing);
</span><span class='line'>      if (!bInitFacerec) {// facerec init?
</span><span class='line'>          long result = XFaceLibrary.initFacerec();// it will take a lot of time!
</span><span class='line'>          Message message = new Message();
</span><span class='line'>          message.arg1 = (int) result;// 1/-1/-2
</span><span class='line'>          message.arg2 = 0;
</span><span class='line'>          handler.sendMessage(message);
</span><span class='line'>          bInitFacerec = true;// no longer init!
</span><span class='line'>      }
</span><span class='line'>      while (!bExitRecognition) {// is recognition exits?
</span><span class='line'>          if (!bFrameProcessing) {// is frame being processing?
</span><span class='line'>              if (null == mGray || mGray.empty()) {//it's hard to say when it is called!
</span><span class='line'>                  Log.i(TAG, "gray mat is null");
</span><span class='line'>                  // return;// return when no data//can not return
</span><span class='line'>              } else {
</span><span class='line'>                  bFrameProcessing = true;
</span><span class='line'>                  Log.i(TAG, "runFacerec! addr = " + mGray.getNativeObjAddr());// 2103032
</span><span class='line'>                  // Log.i(TAG, "data addr=" + mGray.dataAddr() + " $$ native addr=" +
</span><span class='line'>                  // mGray.getNativeObjAddr()
</span><span class='line'>                  // + " $$ native object=" + mGray.nativeObj);// $1 not equal $2,but $2=$3
</span><span class='line'>                  int result = XFaceLibrary.facerec(mGray);
</span><span class='line'>                  Message message = new Message();
</span><span class='line'>                  message.arg1 = result;
</span><span class='line'>                  message.arg2 = 1;
</span><span class='line'>                  handler.sendMessage(message);
</span><span class='line'>                  bFrameProcessing = false;
</span><span class='line'>              }
</span><span class='line'>          }
</span><span class='line'>          try {
</span><span class='line'>              Thread.currentThread().sleep(1000);
</span><span class='line'>          } catch (InterruptedException e) {
</span><span class='line'>              e.printStackTrace();
</span><span class='line'>          }
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>}).start();</span></code></pre></td></tr></table></div></figure>


<p>3.XFace应用程序在手机SD卡中的相关文件</p>

<p>XFace应用程序的使用过程中会产生一些文件夹和文件，全部存放在SD卡的<code>xface</code>文件夹下。这部分内容可以参看文件<code>CommonUtil.java</code>文件，在包<code>edu.thu.xface.util</code>下。</p>

<p><code>camera</code>文件夹存放摄像头拍照得到的头像；</p>

<p><code>user</code>文件夹存放灰度化和压缩处理之后的头像；</p>

<p><code>demo</code>文件夹存放测试或者示例程序的数据，目前为空；</p>

<p><code>facedata.txt</code>文件存放人脸图片路径和人物的对应关系，文件中<code>图片路径;数字</code>表示该数字编号的人物的头像图片所在的路径；</p>

<p><code>users.properties</code>文件用来保存用户的配置和注册用户的信息，文件中<code>total</code>代表总共注册的人数；后面的<code>数字=用户名</code>表示人物编号与人物名称的对应关系，<code>1=hujiawei</code>表示1号人物代表用户<code>hujiawei</code>，再根据<code>facedata.txt</code>文件中的内容便可以知道<code>hujiawei</code>用户头像图片存储的路径；最后的<code>facerecognizer=?</code>保存当前使用的人脸识别算法，例如<code>facerecognizer=eigenface</code>表示使用的是特征脸算法，XFace虽然内置了OpenCV中的三种人脸识别算法，但是目前只有<code>eigenface</code>和<code>fisherface</code>两种算法可行，第三种<code>lbphface</code>算法暂时不可行。</p>

<p><code>facerec.yml</code>文件是OpenCV中人脸识别算法用来保存创建的识别模块数据的文件；</p>

<p><code>lbpcascade_frontalface.yml</code>文件是OpenCV中进行人脸检测所需要的数据文件；</p>

<h5>第四部分 其他参考内容</h5>

<hr />

<p>其他的参考内容：</p>

<p>①<a href="http://hujiaweibujidao.github.io/blog/2013/12/14/yi-dong-kai-fa-zi-liao-hui-ji/">关于Android开发的书籍和资料</a></p>

<p>文章最后附有两份Android开发入门课程PPT，以及一个Android小程序魔力8号球，百度网盘同样可以下载</p>

<p>②<a href="http://bujingyun23.blog.163.com/blog/static/181310243201210293950303/?suggestedreading&amp;wumii">关于在Ubuntu12.04下搭建android开发环境的教程</a></p>

<p>③<a href="http://hujiaweiyinger.diandian.com/post/2013-10-30/setup_android_ndk_environment_and_solve_some_problems">关于在windows平台搭建android开发环境的教程</a></p>

<p>不推荐使用Windows进行开发，因为不仅要安装Cygwin，还要进行很多其他的配置，如果实在是不得已，可以尝试参考<a href="http://blog.csdn.net/pwh0996/article/details/8957764">这位博主的环境搭建过程</a></p>

<p>④<a href="http://hujiaweibujidao.github.io/blog/2013/11/18/android-ndk-and-opencv-developement/">关于android ndk和opencv整合开发以及实例项目运行的教程</a></p>

<p>介绍Android NDK和OpenCV整合开发的环境搭建过程和实例项目测试，重点可以参考的是其中的人脸检测和眼镜检测的两个项目，XFace中的人脸检测便来源于此。</p>

<p>⑤<a href="http://hujiaweibujidao.github.io/blog/2013/11/18/android-ndk-and-opencv-development-2/">关于android ndk开发中的各种细节和问题的总结</a></p>

<p>理解javah工具和Android.mk以及Application.mk文件的配置，如果是在Windows平台搭建环境的话，需要查看这部分关于<code>C/C++ Genernal -&gt; Paths and Symbols</code>的配置</p>

<p>⑥<a href="http://bytefish.de/blog/opencv_facerecognizer_documentation/">关于OpenCV中的人脸识别算法 &ndash; OpenCV FaceRecognizer documentation</a></p>

<p>该博客作者是OpenCV2.4之后内置的人脸识别模块的原作者，他在他的博客中详细介绍了FaceRecognizer的API以及他使用的人脸识别算法，算法讲解部分可以参考<a href="http://bytefish.de/blog/face_recognition_with_opencv2/">Face Recognition with Python/GNU Octave/Matlab</a>。</p>

<p class='post-footer'>
                        Original link:<a href='http://hujiaweibujidao.github.io/blog/2014/02/21/android-ndk-and-opencv-development-4/'>http://hujiaweibujidao.github.io/blog/2014/02/21/android-ndk-and-opencv-development-4/</a><br/>Written by <a href='http://hujiaweibujidao.github.io'>hujiawei</a>&nbsp;Posted at <a href='http://hujiaweibujidao.github.io'>http://hujiaweibujidao.github.io</a><br/>Feel free to read or comment it, and if you want to copy it into your own site, please copy it with its Original Link showed above or you can see the license below for more details.<br />Thanks a lot. Hope you enjoy here! ^_^</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[android ndk and opencv development 3]]></title>
    <link href="http://hujiaweibujidao.github.io/blog/2013/11/18/android-ndk-and-opencv-development-3/"/>
    <updated>2013-11-18T21:35:00+08:00</updated>
    <id>http://hujiaweibujidao.github.io/blog/2013/11/18/android-ndk-and-opencv-development-3</id>
    <content type="html"><![CDATA[<h3>Android NDK 和 OpenCV 整合开发总结(3)</h3>

<p>终于写到第三节啦，虽然很累，但是还是要坚持，坚持写完这3篇文章。</p>

<p>这一节的主要内容是OpenCV在Android NDK开发中的应用，包括下面几个方面的内容：</p>

<ul>
<li>如何实现Static Initialization从而不需要安装OpenCV Manager运行含OpenCV library的app</li>
<li>对十份论文和报告中的关于OpenCV和Android NDK开发的总结</li>
<li>如何使用Android中的摄像头，常见的问题有哪些?</li>
<li>OpenCV 和 Android NDK 整合开发的一般途径</li>
</ul>


<h4>1.实现Static Initialization</h4>

<p>实现Static Initialization就是指将OpenCV Library添加到app package中，不需要安装OpenCV Manager这个app就能运行，<a href="http://docs.OpenCV.org/trunk/doc/tutorials/introduction/Android_binary_package/dev_with_OCV_on_Android.html">官方文档有介绍</a>，但是不详细，尤其是最后那句代码到底要放在什么地方很多人都不清楚，其实并不需要像官方文档中介绍的那样配置，我想在这里介绍下如何修改FaceDetection项目的源码来做到这点。(最好是找一个包含jni代码的项目进行修改)</p>

<ul>
<li>[1]打开jni下的Android.mk文件，修改OpenCV的那一部分，将<code>off</code>设置为<code>on</code>，并设置<code>OpenCV_LIB_TYPE</code>为<code>SHARED</code>，结果如下：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>OpenCV_CAMERA_MODULES:=on
</span><span class='line'>OpenCV_INSTALL_MODULES:=on
</span><span class='line'>OpenCV_LIB_TYPE:=SHARED
</span><span class='line'>include ${OpenCVROOT}/sdk/native/jni/OpenCV.mk</span></code></pre></td></tr></table></div></figure>


<ul>
<li>[2]打开FdActivity.java文件，在其中添加一个静态初始化块代码，它是用来加载<code>OpenCV_java</code>库的，由于FaceDetection中还用了另一个库detection_based_tracker(用于人脸跟踪)，所以要在<code>else</code>子句中加载进来：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static {
</span><span class='line'>  Log.i(TAG, "OpenCV library load!");
</span><span class='line'>  if (!OpenCVLoader.initDebug()) {
</span><span class='line'>      Log.i(TAG, "OpenCV load not successfully");
</span><span class='line'>  } else {
</span><span class='line'>      System.loadLibrary("detection_based_tracker");// load other libraries
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>[3]删除FdActivity.java的OnResume()方法的最后那句，不让它去访问OpenCV Manager。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Override
</span><span class='line'>public void onResume() {
</span><span class='line'>  super.onResume();
</span><span class='line'>//OpenCVLoader.initAsync(OpenCVLoader.OpenCV_VERSION_2_4_3, this, mLoaderCallback);//
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>[4]修改FdActivity.java的OnCreate()方法，从上面的<code>private BaseLoaderCallback mLoaderCallback = new BaseLoaderCallback(this)</code>代码块中拷贝<code>try-catch</code>块放到OnCreate的<code>setContentView()</code>之后，然后拷贝<code>mOpenCVCameraView.enableView();</code>放到<code>mOpenCVCameraView = (CameraBridgeViewBase) findViewById(R.id.fd_activity_surface_view);</code>之后，修改后的OnCreate()方法如下：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void onCreate(Bundle savedInstanceState) {
</span><span class='line'>  Log.i(TAG, "called onCreate");
</span><span class='line'>  super.onCreate(savedInstanceState);
</span><span class='line'>  getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
</span><span class='line'>
</span><span class='line'>  setContentView(R.layout.face_detect_surface_view);
</span><span class='line'>
</span><span class='line'>  //
</span><span class='line'>  try {
</span><span class='line'>      // load cascade file from application resources
</span><span class='line'>      InputStream is = getResources().openRawResource(R.raw.lbpcascade_frontalface);
</span><span class='line'>      File cascadeDir = getDir("cascade", Context.MODE_PRIVATE);
</span><span class='line'>      mCascadeFile = new File(cascadeDir, "lbpcascade_frontalface.xml");
</span><span class='line'>      FileOutputStream os = new FileOutputStream(mCascadeFile);
</span><span class='line'>
</span><span class='line'>      byte[] buffer = new byte[4096];
</span><span class='line'>      int bytesRead;
</span><span class='line'>      while ((bytesRead = is.read(buffer)) != -1) {
</span><span class='line'>          os.write(buffer, 0, bytesRead);
</span><span class='line'>      }
</span><span class='line'>      is.close();
</span><span class='line'>      os.close();
</span><span class='line'>
</span><span class='line'>      mJavaDetector = new CascadeClassifier(mCascadeFile.getAbsolutePath());
</span><span class='line'>      if (mJavaDetector.empty()) {
</span><span class='line'>          Log.e(TAG, "Failed to load cascade classifier");
</span><span class='line'>          mJavaDetector = null;
</span><span class='line'>      } else
</span><span class='line'>          Log.i(TAG, "Loaded cascade classifier from " + mCascadeFile.getAbsolutePath());
</span><span class='line'>
</span><span class='line'>      mNativeDetector = new DetectionBasedTracker(mCascadeFile.getAbsolutePath(), 0);// hujiawei
</span><span class='line'>
</span><span class='line'>      cascadeDir.delete();
</span><span class='line'>
</span><span class='line'>  } catch (IOException e) {
</span><span class='line'>      e.printStackTrace();
</span><span class='line'>      Log.e(TAG, "Failed to load cascade. Exception thrown: " + e);
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  //
</span><span class='line'>
</span><span class='line'>  mOpenCVCameraView = (CameraBridgeViewBase) findViewById(R.id.fd_activity_surface_view);
</span><span class='line'>  mOpenCVCameraView.enableView();//
</span><span class='line'>  mOpenCVCameraView.setCvCameraViewListener(this);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>[5]OK，卸载安装好的OpenCV Manager，然后重新调试运行FaceDetection试试，它已经可以自行运行了！</li>
</ul>


<h4>2.对十份论文和报告中的关于OpenCV和Android NDK开发的总结</h4>

<p>这10篇文献大部分[<a href="http://pan.baidu.com/s/19WOVq">百度网盘下载地址</a>]都还是停留如何在Android开发中使用OpenCV library，没有牵涉到具体的实现领域。具体总结如下：</p>

<ul>
<li>_利用OpenCV实现在Android系统下的人脸检测</li>
</ul>


<p>本文主要介绍了如何在底层通过OpenCV来对人脸部分进行检测，得到的人脸位置数据通过JNI传递给Java层，详细介绍了其中的JNI代码和共享库的构建过程，对图片是通过图片的路径来进行传递的，因为这里的检测只是对单张静态的图片进行检测。</p>

<ul>
<li>_Tutorial-2-OpenCV-for-Android-Setup-Macintosh-API11</li>
</ul>


<p>本文主要是介绍了OpenCV和Android NDK开发环境的搭建，以及基于示例程序Face-Detection的演示。使用的方式是将OpenCV Library Project作为库，然后调用OpenCV Android API。</p>

<ul>
<li>_Android application for Face Recognition</li>
</ul>


<p>这是一份详细的项目介绍，实现了几种基于Android平台的人脸检测和识别，包括Google API和OpenCV的，但是OpenCV的由于需要Library Project，而且算法过于复杂，作者便自行开发了人脸检测库，有6大特性，其中包括了眼镜和嘴巴的检测。</p>

<ul>
<li>_ECCV-2012-OpenCV4Android</li>
</ul>


<p>这份报告写得精简但是内容丰富，有几个重要点：<br/>
(1) 使用OpenCV的Android应用开发方式，对应不同的开发人群：Java developer / Native developer <br/>
(2) OpenCV4Android目前的局限性，以及开发过程中对于提高性能和开发效率需要注意的事项</p>

<ul>
<li>_Introduction to OpenCV for Android devices</li>
</ul>


<p>本文设计的内容都很基础，涉及到OpenCV和Android开发的环境搭建，亮点是最后的Using C++ OpenCV code，这里是在Android ndk中使用OpenCV本地代码的重要配置项。</p>

<ul>
<li>_OpenCV-facedetection</li>
</ul>


<p>这份报告讲述了很多OpenCV的相关知识，另外还详细讲述了一个人脸检测的算法</p>

<ul>
<li>_OpenCV on Android Platforms</li>
</ul>


<p>这份报告内容也比较多，但是都很基础。</p>

<ul>
<li>_BDTI_ARMTechCon_2012_OpenCV_Android</li>
</ul>


<p>这份报告讲的是OpenCV在嵌入式设备中的应用，其中介绍了OpenCV在Android上的开发，需要注意的是OpenCV2.4开始提供了native Android camera support！</p>

<ul>
<li>_OpenCV Based Real-Time Video Processing  Using Android Smartphone</li>
</ul>


<p>这篇论文介绍了利用OpenCV对实时的视频进行处理和纯Android library进行处理的比较，发现利用OpenCV处理的结果更加准确，效率更快，而且更加省电。比较时使用的都是基本图像处理操作，例如灰度化，高斯模糊，Sobel边缘检测等等。</p>

<ul>
<li>_Realtime Computer Vision  with OpenCV</li>
</ul>


<p>这篇文章比较有意思，大致看了下，介绍了OpenCV在移动终端的应用。</p>

<h4>3.Android的摄像头</h4>

<ul>
<li><p>关于如何使用Android的摄像头：Android设备一般有两个摄像头，前置摄像头和后置摄像头，在进行和摄像头相关的应用开发的时候很容易遇到各种问题，推荐以下几篇文章：<br/>
<a href="https://developer.Android.com/guide/topics/media/camera.html">Android Developer中有对应的文档:Camera</a><br/>
<a href="http://blog.csdn.net/yinyuan1987/article/details/6969225">这位作者的总结：Android相机</a><br/>
<a href="http://stackoverflow.com/questions/2779002/how-to-open-front-camera-on-Android-platform">StackOverflow上关于如何调用前置摄像头</a><br/>
<a href="http://blog.csdn.net/yangzl2008/article/details/9262505">如何在Android中后台开启摄像头默默拍照</a><br/>
<a href="http://blog.csdn.net/ocean20/article/details/8772196">关于Camera的三种Callback</a></p></li>
<li><p>关于保存预览图片：Android中的<code>BitmapFactory.decodeByteArray</code>只支持一定的格式，Camara默认的previewformat格式为<code>NV21</code>(对于大多数的Android设备，即使修改CameraParameters的设置也还是不行)，所以在获得bitmap时，需要进行转换，通过YuvImage类来转换成JPEG格式，然后再保存到文件中。<br/>
<a href="http://www.cnblogs.com/liuan/archive/2012/01/10/2318300.html">Google Group上的讨论</a></p></li>
<li><p>关于如何在预览界面上添加一个矩形框，类似二维码扫描那样，原理很简单，一个使用SurfaceView，另一个使用ImageVIew(或者SurfaceView也行)，推荐文章：<br/>
<a href="http://blog.csdn.net/yanzi1225627/article/details/8580034">Android摄像头中预览界面添加矩形框</a></p></li>
<li><p>关于如何进行和OpenCV有关的摄像头开发：有了OpenCV的library之后，关于摄像头的开发可谓是简单了很多，可以参见OpenCV for Android中的三个Tutorial(CameraPreview, MixingProcessing和CameraControl)，源码都在OpenCV-Android sdk的samples目录下，这里简单介绍下： <br/>
OpenCV Library中提供了两种摄像头，一种是Java摄像头-<code>org.OpenCV.Android.JavaCameraView</code>，另一种是Native摄像头-<code>org.OpenCV.Android.NativeCameraView</code> (可以运行CameraPreview这个项目来体验下两者的不同，其实差不多)。两者都继承自<code>CameraBridgeViewBase</code>这个抽象类，但是JavaCamera使用的就是Android SDK中的<code>Camera</code>，而NativeCamera使用的是OpenCV中的<code>VideoCapture</code>。</p></li>
<li><p>关于OpenCV的Camera在Layout文件中的配置：<code>OpenCV:show_fps</code>在layout中如果设置为<code>true</code>的话显示界面中会出现当前摄像头帧率的信息以及图片的大小，<code>OpenCV:camera_id</code>的配置有三种<code>front</code>,<code>back</code>,<code>any</code>分别对应前置摄像头，后置摄像头和默认的摄像头(其实也就是后置摄像头)。</p></li>
<li><p>关于<code>CvCameraViewListener2</code>接口：它可以方便的处理和摄像头的交互，该接口只有三个函数，分别在Camera打开(<code>onCameraViewStarted</code>)，关闭(<code>onCameraViewStopped</code>)和预览的图片帧到了的时候(<code>onCameraFrame</code>)调用。其中<code>OnCameraFrame</code>这个方法很重要，如果要对图片进行处理的话一般都是在这里面处理的，这个函数的输入参数是<code>CvCameraViewFrame</code>，需要注意的是，不要在这个方法的外面使用这个变量，因为这个对象没有它自己的状态，在回调方法的外面它的行为是不可预测的！它提供了两个有用的方法<code>rgba()</code>和<code>gray()</code>分别得到图像帧的RGBA格式和灰度图，<code>OnCameraFrame</code>的返回值是<strong>RGBA格式</strong>的图像，这个很重要！一定要保证处理了之后的图像是RGBA格式的Android系统才能正常显示！<a href="http://docs.OpenCV.org/trunk/doc/tutorials/introduction/Android_binary_package/dev_with_OCV_on_Android.html">来自OpenCV文档:Android Development with Android</a></p></li>
</ul>


<p><code>Note Do not save or use CvCameraViewFrame object out of onCameraFrame callback. This object does not have its own state and its behavior out of callback is unpredictable!</code></p>

<ul>
<li>关于如何传递摄像头预览的图像数据给Native代码：这个很重要！我曾经试过很多的方式，大致思路有：</li>
</ul>


<p>①传递图片路径：这是最差的方式，我使用过，速度很慢，主要用于前期开发的时候进行测试，测试Java层和Native层的互调是否正常。</p>

<p>②传递预览图像的字节数组到Native层，然后将字节数组处理成RGB或者RGBA的格式[具体哪种格式要看你的图像处理函数能否处理RGBA格式的，如果可以的话推荐转换成RGBA格式，因为返回的也是RGBA格式的。网上有很多的文章讨论如何转换：一种方式是使用一个自定义的函数进行编码转换(可以搜索到这个函数)，另一个种方式是使用OpenCV中的Mat和cvtColor函数进行转换，接着调用图像处理函数，处理完成之后，将处理的结果保存在一个整形数组中(实际上就是RGB或者RGBA格式的图像数据)，最后调用Bitmap的方法将其转换成bitmap返回。这种方法速度也比较慢，但是比第一种方案要快了不少，具体实现过程可以看下面的推荐书籍。</p>

<p>③使用OpenCV的摄像头：JavaCamera或者NativeCamera都行，好处是它进行了很多的封装，可以直接将预览图像的Mat结构传递给Native层，这种传递是使用Mat的内存地址(long型)，Native层只要根据这个地址将其封装成Mat就可以进行处理了，另外，它的回调函数的返回值也是Mat，非常方便！这种方式速度较快。详细过程可以查看OpenCV-Android sdk的samples项目中的Tutorial2-MixedProcessing。</p>

<ul>
<li>关于摄像头预览界面倒置的问题：很多时候(一般是将应用设置为<code>portrait</code>模式之后)在调用了OpenCV的Camera之后，出现预览内容倒置了90度的现象，原因是OpenCV的Camera默认情况下是以<code>landscape</code>模式运行的，一个可行但是不是很好的解决方案是修改OpenCV库中的<code>org.opencv.camera.CameraBridgeViewBase</code>类中的<code>deliverandDraw</code>方法，<a href="http://stackoverflow.com/questions/19190921/always-open-in-landscape-mode-orientation-for-front-camera-in-opencv-javacv">问题参考链接</a></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protected void deliverAndDrawFrame(CvCameraViewFrame frame) {
</span><span class='line'>        Mat modified;
</span><span class='line'>
</span><span class='line'>        if (mListener != null) {
</span><span class='line'>            modified = mListener.onCameraFrame(frame);
</span><span class='line'>        } else {
</span><span class='line'>            modified = frame.rgba();
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        boolean bmpValid = true;
</span><span class='line'>        if (modified != null) {
</span><span class='line'>            try {
</span><span class='line'>                Utils.matToBitmap(modified, mCacheBitmap);
</span><span class='line'>            } catch(Exception e) {
</span><span class='line'>                Log.e(TAG, "Mat type: " + modified);
</span><span class='line'>                Log.e(TAG, "Bitmap type: " + mCacheBitmap.getWidth() + "*" + mCacheBitmap.getHeight());
</span><span class='line'>                Log.e(TAG, "Utils.matToBitmap() throws an exception: " + e.getMessage());
</span><span class='line'>                bmpValid = false;
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        if (bmpValid && mCacheBitmap != null) {
</span><span class='line'>            Canvas canvas = getHolder().lockCanvas();
</span><span class='line'>            if (canvas != null) {
</span><span class='line'>//                canvas.drawColor(0, android.graphics.PorterDuff.Mode.CLEAR);
</span><span class='line'>//                Log.d(TAG, "mStretch value: " + mScale);
</span><span class='line'>//
</span><span class='line'>//                if (mScale != 0) {
</span><span class='line'>//                    canvas.drawBitmap(mCacheBitmap, new Rect(0,0,mCacheBitmap.getWidth(), mCacheBitmap.getHeight()),
</span><span class='line'>//                         new Rect((int)((canvas.getWidth() - mScale*mCacheBitmap.getWidth()) / 2),
</span><span class='line'>//                         (int)((canvas.getHeight() - mScale*mCacheBitmap.getHeight()) / 2),
</span><span class='line'>//                         (int)((canvas.getWidth() - mScale*mCacheBitmap.getWidth()) / 2 + mScale*mCacheBitmap.getWidth()),
</span><span class='line'>//                         (int)((canvas.getHeight() - mScale*mCacheBitmap.getHeight()) / 2 + mScale*mCacheBitmap.getHeight())), null);
</span><span class='line'>//                } else {
</span><span class='line'>//                     canvas.drawBitmap(mCacheBitmap, new Rect(0,0,mCacheBitmap.getWidth(), mCacheBitmap.getHeight()),
</span><span class='line'>//                         new Rect((canvas.getWidth() - mCacheBitmap.getWidth()) / 2,
</span><span class='line'>//                         (canvas.getHeight() - mCacheBitmap.getHeight()) / 2,
</span><span class='line'>//                         (canvas.getWidth() - mCacheBitmap.getWidth()) / 2 + mCacheBitmap.getWidth(),
</span><span class='line'>//                         (canvas.getHeight() - mCacheBitmap.getHeight()) / 2 + mCacheBitmap.getHeight()), null);
</span><span class='line'>//                }
</span><span class='line'>
</span><span class='line'>                //ABC : Fixed for image rotation
</span><span class='line'>                //TODO Why portrait is not opening in fulls creen
</span><span class='line'>                Matrix matrix = new Matrix();
</span><span class='line'>                int height_Canvas = canvas.getHeight();
</span><span class='line'>                int width_Canvas = canvas.getWidth();
</span><span class='line'>
</span><span class='line'>                int width = mCacheBitmap.getWidth();
</span><span class='line'>                int height = mCacheBitmap.getHeight();
</span><span class='line'>
</span><span class='line'>                float f1 = (width_Canvas - width) / 2;
</span><span class='line'>                float f2 = (height_Canvas - height) / 2;
</span><span class='line'>                matrix.preTranslate(f1, f2);
</span><span class='line'>                if(getResources().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT)
</span><span class='line'>                matrix.postRotate(270f,(width_Canvas) / 2,(height_Canvas) / 2);
</span><span class='line'>                canvas.drawBitmap(mCacheBitmap, matrix, new Paint());
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>                if (mFpsMeter != null) {
</span><span class='line'>                    mFpsMeter.measure();
</span><span class='line'>                    mFpsMeter.draw(canvas, 20, 30);
</span><span class='line'>                }
</span><span class='line'>                getHolder().unlockCanvasAndPost(canvas);
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<h4>3.OpenCV 和 OpenCV NDK 整合开发的一般途径</h4>

<p>在进行这类开发的时候，需要考虑如何在Android中使用OpenCV，并且如果需要调用摄像头的话，要考虑以下内容：<br/>
首先，是否是在原有的C/C++代码上进行移植，如果是的话，那么尽量考虑使用ndk开发，否则使用OpenCV for Android编写Java代码进行开发，效率不会比native代码低多少； <br/>
其次，如果是需要OpenCV library，是否能够容忍运行应用还需要安装OpenCV Manager，如果不能的话，则在开发时要考虑将OpenCV binaries添加到应用中进行static initialization，但其实使用OpenCV Manager是有很多好处的，上面的论文和OpenCV官网都有相应的文档介绍它的好处和使用方式； <br/>
接着，是否需要调用摄像头，如果需要的话，是使用原生Android的Camera还是使用OpenCV的Camera，如果是OpenCV Camera的话，是使用Java调用摄像头还是Native调用摄像头；<br/>
最后，图片如何进行传递，如果是单张静态图片进行处理的话，只需要路径就行了，但是如果是在视频状态下对图片进行处理的话，那么就只能传递图像数据了，这里涉及到了Android中如何获取预览的图像数据以及如何将其传递到底层，又如何进行转换(一般是YUV转成RGB)使得OpenCV可以进行处理，处理完了之后，又如何将处理得到的图片传递给Java层。</p>

<p>推荐一本书籍《Mastering OpenCV with Practical Computer Vision Projects》，电子书可以在<a href="http://www.ppurl.com/2012/12/mastering-OpenCV-with-practical-computer-vision-projects.html">皮皮书屋</a>下载，<a href="https://github.com/MasteringOpenCV">原书源码在Github上</a>。该书第一章介绍如何开发一个使用OpenCV的Android项目-<code>Cartoonifer and Skin Changer for Android</code>，这个项目涉及到了OpenCV在Android中的方方面面，采用的是第二种图像数据传递方式，其中他提出了很多可以优化的地方，包括： <br/>
①尽量使用Mat而不要使用IplImage <br/>
②尽量保证你的图像处理函数能够处理RGBA格式的图像  <br/>
③如果可以先压缩图像大小再对图像进行处理  <br/>
④使用noise filter降低图像中的噪声。</p>

<p>总之，极力推荐此书，我以后的文章中还会提到这本书，嘿嘿。</p>

<p>OK！脑子有点乱了，这节逻辑不太严谨，嘿嘿，但总算完结了！多谢关注！</p>

<p class='post-footer'>
                        Original link:<a href='http://hujiaweibujidao.github.io/blog/2013/11/18/android-ndk-and-opencv-development-3/'>http://hujiaweibujidao.github.io/blog/2013/11/18/android-ndk-and-opencv-development-3/</a><br/>Written by <a href='http://hujiaweibujidao.github.io'>hujiawei</a>&nbsp;Posted at <a href='http://hujiaweibujidao.github.io'>http://hujiaweibujidao.github.io</a><br/>Feel free to read or comment it, and if you want to copy it into your own site, please copy it with its Original Link showed above or you can see the license below for more details.<br />Thanks a lot. Hope you enjoy here! ^_^</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[android ndk and opencv development 2]]></title>
    <link href="http://hujiaweibujidao.github.io/blog/2013/11/18/android-ndk-and-opencv-development-2/"/>
    <updated>2013-11-18T15:59:00+08:00</updated>
    <id>http://hujiaweibujidao.github.io/blog/2013/11/18/android-ndk-and-opencv-development-2</id>
    <content type="html"><![CDATA[<h3>Android NDK 和 OpenCV 整合开发总结(2)</h3>

<p>这节主要介绍的内容是<a href="http://developer.android.com/tools/sdk/ndk/index.html">Android NDK</a>开发的核心内容和开发总结(包括很多常见问题的解决方案)，本节主要分为三部分：<br/>
* JNI技术和javah命令 <br/>
* Android NDK Dev Guide <br/>
* NDK开发中常见的问题</p>

<h4>1.不得不说的JNI和javah命令</h4>

<p>NDK开发的核心之一便是JNI，在<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html">Oracle官方的JNI相关文档</a>中重要的是里面的第3-4部分(数据类型和函数)，本文不会介绍这些，如果想快速入手可以查看<a href="http://my.oschina.net/zhiweiofli/blog?catalog=225458">这位作者的几篇关于JNI的文章</a>，讲得深入浅出，另外推荐一篇<a href="http://www.ibm.com/developerworks/cn/java/j-lo-jni/index.html">IBM DeveloperWorks上的文章:JNI 对象在函数调用中的生命周期</a>，讲得有点深奥哟。</p>

<ul>
<li><p><a href="http://docs.oracle.com/javase/6/docs/technotes/tools/windows/javah.html">javah命令：查看命令详细参数</a>：<br/>
<code>javah produces C header files and C source files from a Java class. These files provide the connective glue that allow your Java and C code to interact.</code></p></li>
<li><p>在Eclipse中配置<strong>万能的javah工具</strong>的方法</p></li>
</ul>


<p>(1)在<code>External Tools Configurations</code>中新建<code>Program</code></p>

<p>(2)<code>Location</code>设置为<code>/usr/bin/javah</code> [你可能不是这个位置，试试<code>${system_path:javah}</code>]</p>

<p>(3)<code>Working Directory</code>设置为<code>${project_loc}/bin/classes</code> [适用于Android项目开发]</p>

<p>(4)<code>Arguments</code>设置为<code>-jni -verbose -d "${project_loc}${system_property:file.separator}jni" ${java_type_name}</code></p>

<p>(5)OK，以后只要选中要进行&#8221;反编译&#8221;的Java Class，然后运行这个External Tool就可以了！  <br/>
<strong>注意</strong>因为我的<code>Arguments</code>设置为导出的头文件是放在项目的jni目录中，如果不是Android NDK开发的话，请自行修改输出路径，还有<code>Working Directory</code>设置为<code>${project_loc}/bin</code>，不要包含后面的<code>/classes</code>。如果还有问题的话，推荐看下<a href="http://blog.csdn.net/mirkerson/article/details/8901270">这位作者的JNI相关配置</a></p>

<h4>2.那些年的Android NDK Dev Guide</h4>

<p>在ndk的根目录下有一个html文件<code>document.html</code>，这个就是Android NDK Dev Guide，用浏览器打开可以看到里面介绍了NDK开发中的很多配置问题，不同版本的NDK差别还是蛮大的，而且NDK开发中问题会很多，不像SDK开发那么简单，所以，一旦出现了问题，运气好能够Google解决，RP弱的时候只能啃这些Guide来找答案了。这几篇文章的简单介绍可以查看<a href="http://developer.android.com/tools/sdk/ndk/index.html#Docs">Android Developer上的解释</a>。对于这部分的内容，可以阅读下<a href="http://blog.csdn.net/smfwuxiao/article/category/1328624">这位作者的几篇NDK Dev Guide的翻译版本</a>，虽然略有过时，但是看后肯定会很受用的，下面我简单介绍下这里的几个内容：</p>

<ul>
<li><strong>[1]Android NDK Overview</strong></li>
</ul>


<p>这篇文章介绍了NDK的目标和NDK开发的简易实践过程，后面的那些文章基本上都是围绕这个核心内容展开的，非常建议阅读。需要注意的是，NDK只支持Android 1.5版本以上的设备。</p>

<ul>
<li><strong>[2]Android.mk文件</strong></li>
</ul>


<p>Android.mk文件是用来描述源代码是如何进行编译的，<strong>ndk-build命令实际上对GNU Make命令的一个封装</strong>，所以，Android.mk文件的写法就类似Makefile的写法[关于Make的详细内容可以看这本书，[GNU Make的中文手册]，虽然是今年读的，但是我记得的也不多了，老了老了…] <br/>
Android.mk文件可以生成一个动态链接库或者一个静态链接库，但是只有动态链接库是会复制到应用的安装包中的，静态库一般是用来生成其他的动态链接库的。你可以在一个Android.mk文件定义一个或者多个module，不同的module可以使用相同的source file进行编译得到。你不需要列出头文件，也不需要显示指明要生成的目标文件之间的依赖关系(这些内容在GNU Make中是很重要的，虽然GNU Make中的隐式规则也可以做到)。下面以hello-jni项目中的Android.mk文件为例讲解其中重要的几点。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>LOCAL_PATH := $(call my-dir)
</span><span class='line'>include $(CLEAR_VARS)
</span><span class='line'>LOCAL_MODULE    := hello-jni
</span><span class='line'>LOCAL_SRC_FILES := hello-jni.c
</span><span class='line'>include $(BUILD_SHARED_LIBRARY)</span></code></pre></td></tr></table></div></figure>


<p>①<code>LOCAL_PATH := $(call my-dir)</code>：Android.mk文件的第一行必须要指明<code>LOCAL_PATH</code>，<code>my-dir</code>是编译系统提供的一个宏函数，这个宏函数会返回当前Android.mk文件所在的目录</p>

<p>②<code>include $(CLEAR_VARS)</code>：<code>CLEAR_VARS</code>是编译系统提供的一个变量，这个变量指向一个特殊的Makefile文件，它会清除所有除了<code>LOCAL_PATH</code>之外的其他的<code>LOCAL_XXX</code>变量。</p>

<p>③<code>LOCAL_MODULE := hello-jni</code>：必须要指定<code>LOCAL_MODULE</code>，它是指这个Android.mk要生成的目标，这个名称是一个<strong>不包含空格的唯一的字符串</strong>，编译系统会自动根据名称进行一定的修改，例如<code>foo.so</code>和<code>libfoo.so</code>得到的都是<code>libfoo.so</code>！在Java代码中进行加载的时候使用的是没有<code>lib</code>的module名。</p>

<p>④<code>LOCAL_SRC_FILES := hello-jni.c</code>：指定C/C++源文件列表，不要包含头文件。如果需要自定义C++源文件的后缀，可以配置<code>LOCAL_CPP_EXTENSION</code>参数。注意写法，我给个例子，一定要记住每行后面加上一个反斜线符，并且反斜线符后面不能再有任何内容，否则编译会报错！</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>LOCAL_SRC_FILES := hello-jni.c \
</span><span class='line'>foo.c  \
</span><span class='line'>boo.cpp</span></code></pre></td></tr></table></div></figure>


<p>⑤<code>include $(BUILD_SHARED_LIBRARY)</code>：<code>BUILD_SHARED_LIBRARY</code>是编译系统提供的一个Makefile文件，它会根据你前面提供的参数来生成动态链接库，同理，如果是<code>BUILD_STATIC_LIBRARY</code>的话，便是生成静态链接库。</p>

<p><strong>最佳实践</strong>：一般来说，<code>LOCAL_</code>作为前缀的一般定义LOCAL Module的变量，<code>PRIVATE_</code>或者<code>NDK_</code>或者<code>APP_</code>一般定义内部使用的变量，<code>lower-case</code>小写字母的名称一般也是定义内部使用的变量或者函数。如果你要在Android.mk文件定义自己的变量，建议使用<code>MY_</code>作为前缀！</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>MY_SOURCES := foo.c
</span><span class='line'>ifneq ($(MY_CONFIG_BAR),)
</span><span class='line'>   MY_SOURCES += bar.c
</span><span class='line'>endif
</span><span class='line'>LOCAL_SRC_FILES += $(MY_SOURCES)</span></code></pre></td></tr></table></div></figure>


<p>Android.mk这篇文章中后面详细介绍了很多编译系统内置的变量和函数，以及该文件内可以设置的变量，此处就不再赘述了。</p>

<ul>
<li><strong>[3]Application.mk文件</strong></li>
</ul>


<p>Application.mk文件描述的是你的应用需要使用哪些native modules，这个文件不是必须的，小项目可以不用编写这个文件。这个文件可以放在两个不同的位置，最常用的是放在jni目录下，和Android.mk文件放在一块，也可以放在<code>$NDK/apps/&lt;myapp&gt;/</code>目录下(不推荐使用后者，如果使用的是后者，那么必须要显示指定<code>APP_PROJECT_PATH</code>)</p>

<p>①<code>APP_MODULES</code>：这个参数在NDK r4之前是一定要指定的，之后便是可选的，默认情况下，NDK将编译Android.mk文件中定义的所有的modules。</p>

<p>②<code>APP_CFLAGS</code>：这个参数用来指定编译C/C++文件选项参数，例如<code>-frtti -fexceptions</code>等等，而<code>APP_CPPFLAGS</code>是专门用来指定编译C++源文件的选项参数。</p>

<p>③<code>APP_ABI</code>：这个参数很重要，默认情况下，ndk-build将生成对应<code>armeabi</code>CPU架构的库文件，你可以指定其他的CPU架构，或者同时指定多个(自从NDK r7之后，设置为<code>all</code>可以生成所有CPU架构的库文件)！关于不同CPU架构的介绍在<code>CPU Arch ABIs</code>中介绍了，我不是很懂，此文不细讲。如果想要查看某个android设备是什么CPU架构，可以上网查设备的资料，或者通过执行<code>adb shell getprop ro.product.cpu.abi</code>得到，下面这段摘自<a href="http://docs.opencv.org/doc/tutorials/introduction/android_binary_package/O4A_SDK.html">OpenCV for Android SDK</a></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>armeabi, armv7a-neon, arm7a-neon-android8, mips and x86 stand forplatform targets:
</span><span class='line'>   * armeabi is for ARM v5 and ARM v6 architectures with Android API 8+,
</span><span class='line'>   * armv7a-neon is for NEON-optimized ARM v7 with Android API 9+,
</span><span class='line'>   * arm7a-neon-android8 is for NEON-optimized ARM v7 with Android API 8,
</span><span class='line'>   * mips is for MIPS architecture with Android API 9+,
</span><span class='line'>   * x86 is for Intel x86 CPUs with Android API 9+.
</span><span class='line'>If using hardware device for testing/debugging, run the following command to learnits CPU architecture:
</span><span class='line'>*** adb shell getprop ro.product.cpu.abi ***
</span><span class='line'>If you’re using an AVD emulator, go Window &gt; AVD Manager to see thelist of availible devices. Click Edit in the context menu of theselected device. In the window, which then pop-ups, find the CPU field.</span></code></pre></td></tr></table></div></figure>


<p>④<code>APP_STL</code>：指定STL，默认情况下ndk编译系统使用最精简的C++运行时库<code>/system/lib/libstdc++.so</code>，但是你可以指定其他的。详细的内容可以查看<code>$NDK/docs/CPLUSPLUS-SUPPORT.html</code>文件，这个文件可能并没有列出在document.html中！</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>system          -&gt; Use the default minimal system C++ runtime library.
</span><span class='line'>gabi++_static   -&gt; Use the GAbi++ runtime as a static library.
</span><span class='line'>gabi++_shared   -&gt; Use the GAbi++ runtime as a shared library.
</span><span class='line'>stlport_static  -&gt; Use the STLport runtime as a static library.
</span><span class='line'>stlport_shared  -&gt; Use the STLport runtime as a shared library.
</span><span class='line'>gnustl_static   -&gt; Use the GNU STL as a static library.
</span><span class='line'>gnustl_shared   -&gt; Use the GNU STL as a shared library.</span></code></pre></td></tr></table></div></figure>


<p>我们可以从下面的表格中看出它们对C++语言特性的支持程度：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>         C++       C++   Standard
</span><span class='line'>       Exceptions  RTTI    Library
</span><span class='line'>system        no       no        no
</span><span class='line'>gabi++       yes      yes        no
</span><span class='line'>stlport      yes      yes       yes
</span><span class='line'>gnustl       yes      yes       yes</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>从中我们可以看出gnustl很不错，所以一般会配置为gnustl_static。如果选用的是gnustl的话，一般还需要在<code>C/C++ General</code>下的<code>Paths and Symbols</code>中的<code>GNU C</code>和<code>GNU C++</code>配置里添加<code>${NDKROOT}/sources/cxx-stl/gnu-libstdc++/4.6/include</code> 和 <code>${NDKROOT}/sources/cxx-stl/gnu-libstdc++/4.6/libs/armeabi-v7a/include</code> 这两项。</p>

<p>另外需要注意的是，如果你指定的是<code>xxx_shared</code>，想要在运行时加载它，并且其他的库是基于<code>xxx_shared</code>的话，一定记得要先加载<code>xxx_shared</code>，然后再去加载其他的库。</p>

<p>⑤<code>APP_PLATFORM</code>：指定目标android系统版本，注意，指定的是<code>API level</code>，一般情况下，这里可能会与<code>AndroidManifest.xml</code>文件中定义的<code>minSdkVersion</code>冲突而报错，处理办法是类似上一节中提到的修改<code>APP_PLATFORM</code>保证两个不冲突就行了。</p>

<ul>
<li><strong>[4]Stable-APIS</strong></li>
</ul>


<p>build system会自动加载C库，Math库以及C++支持库，所以你不需要通过<code>LOCAL_LDLIBS</code>指定加载他们。Android系统下有多个<code>API level</code>，每个<code>API level</code>都对应了一个Android的发布系统，对应关系如下所示。其中<code>android-6</code>，<code>android-7</code>和<code>android-5</code>是一样的NDK，也就是说他们提供的是相同的native ABIs。对应<code>API level</code>的头文件都放在了<code>$NDK/platforms/android-&lt;level&gt;/arch-arm/usr/include</code>目录下，这正是上一节中导入的项目中在<code>C/C++ General</code>下的<code>Paths and Symbols</code>中的<code>GNU C</code>和<code>GNU C++</code>配置。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Note that the build system automatically links the C library, the Math
</span><span class='line'>library and the C++ support library to your native code, there is no
</span><span class='line'>need to list them in a LOCAL_LDLIBS line.
</span><span class='line'>There are several "API Levels" defined. Each API level corresponds to
</span><span class='line'>a given Android system platform release. The following levels are
</span><span class='line'>currently supported:
</span><span class='line'>    android-3      -&gt; Official Android 1.5 system images
</span><span class='line'>    android-4      -&gt; Official Android 1.6 system images
</span><span class='line'>    android-5      -&gt; Official Android 2.0 system images
</span><span class='line'>    android-6      -&gt; Official Android 2.0.1 system images
</span><span class='line'>    android-7      -&gt; Official Android 2.1 system images
</span><span class='line'>    android-8      -&gt; Official Android 2.2 system images
</span><span class='line'>    android-9      -&gt; Official Android 2.3 system images
</span><span class='line'>    android-14     -&gt; Official Android 4.0 system images
</span><span class='line'>Note that android-6 and android-7 are the same as android-5 for the NDK,
</span><span class='line'>i.e. they provide exactly the same native ABIs!
</span><span class='line'>IMPORTANT:
</span><span class='line'>    The headers corresponding to a given API level are now located
</span><span class='line'>    under $NDK/platforms/android-&lt;level&gt;/arch-arm/usr/include</span></code></pre></td></tr></table></div></figure>


<p> 介绍几个比较重要的库：<br/>
(1)C库(libc)：不需要指定 –lpthread –lrt，也就是说它会自动链接<br/>
(2)C++库(lstdc++)：不需要指定 –lstdc++<br/>
(3)Math库(libm)：不需要指定 –lm<br/>
(4)动态链接器库(libdl)：不需要指定 –ldl <br/>
(5)Android log(liblog)：<strong>需要</strong>指定 –llog<br/>
(6)Jnigraphics库(libjnigraphics)：这个C语言库提供了对Java中Bitmap的操作，<strong>需要</strong>指定 –ljnigraphics，这个库是<code>android-8</code>新增加的内容，典型的使用方式是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Briefly, typical usage should look like:
</span><span class='line'>    1/ Use AndroidBitmap_getInfo() to retrieve information about a
</span><span class='line'>       given bitmap handle from JNI (e.g. its width/height/pixel format)
</span><span class='line'>    2/ Use AndroidBitmap_lockPixels() to lock the pixel buffer and
</span><span class='line'>       retrieve a pointer to it. This ensures the pixels will not move
</span><span class='line'>       until AndroidBitmap_unlockPixels() is called.
</span><span class='line'>    3/ Modify the pixel buffer, according to its pixel format, width,
</span><span class='line'>       stride, etc.., in native code.
</span><span class='line'>    4/ Call AndroidBitmap_unlockPixels() to unlock the buffer.</span></code></pre></td></tr></table></div></figure>


<p>(7)The Android native application APIs：<code>android-9</code>新增加的内容，这些API使得你可以完全使用native code编写android app，但是一般情况下还是需要通过jni的，相关API如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>The following headers correspond to these new native APIs (see comments
</span><span class='line'>inside them for more details):
</span><span class='line'>
</span><span class='line'>  &lt;android/native_activity.h&gt;
</span><span class='line'>
</span><span class='line'>        Activity lifecycle management (and general entry point)
</span><span class='line'>
</span><span class='line'>  &lt;android/looper.h&gt;
</span><span class='line'>  &lt;android/input.h&gt;
</span><span class='line'>  &lt;android/keycodes.h&gt;
</span><span class='line'>  &lt;android/sensor.h&gt;
</span><span class='line'>
</span><span class='line'>        To Listen to input events and sensors directly from native code.
</span><span class='line'>
</span><span class='line'>  &lt;android/rect.h&gt;
</span><span class='line'>  &lt;android/window.h&gt;
</span><span class='line'>  &lt;android/native_window.h&gt;
</span><span class='line'>  &lt;android/native_window_jni.h&gt;
</span><span class='line'>
</span><span class='line'>        Window management, including the ability to lock/unlock the pixel
</span><span class='line'>        buffer to draw directly into it.
</span><span class='line'>
</span><span class='line'>  &lt;android/configuration.h&gt;
</span><span class='line'>  &lt;android/asset_manager.h&gt;
</span><span class='line'>  &lt;android/storage_manager.h&gt;
</span><span class='line'>  &lt;android/obb.h&gt;
</span><span class='line'>        Direct (read-only) access to assets embedded in your .apk. or
</span><span class='line'>        the Opaque Binary Blob (OBB) files, a new feature of Android X.X
</span><span class='line'>        that allows one to distribute large amount of application data
</span><span class='line'>        outside of the .apk (useful for game assets, for example).
</span><span class='line'>
</span><span class='line'>All the corresponding functions are provided by the "libandroid.so" library
</span><span class='line'>version that comes with API level 9. To use it, use the following:
</span><span class='line'>
</span><span class='line'>    LOCAL_LDLIBS += -landroid</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>[5]NDK Build</strong></li>
</ul>


<p>使用<code>ndk-build</code>命令(ndk r4之后引入的)实际上是GNU Make的封装，它等价于<code>make -f $NDK/build/core/build-local.mk [参数]</code>命令。系统必须要安装GNU Make 3.81以上版本，否则编译将报错！如果你安装了GNU Make 3.81，但是默认的make命令没有启动，那么可以在执行<code>ndk-build</code>之前定义GNUMAKE这个变量，例如<code>GNUMAKE=/usr/local/bin/gmake ndk-build</code>。<br/>
<strong>注意</strong> 在Windows下进行NDK开发的话，一般使用的是Cygwin自带的Make工具，但是默认是使用NDK的awk工具，所以可能会报一个错误<code>Android NDK: Host 'awk' tool is outdated. Please define HOST_AWK to point to Gawk or Nawk !</code> 解决方案就是删除NDK自带的awk工具(<a href="http://blog.csdn.net/achellies/article/details/7531440">参考网址</a>)，这也就是第一节中使用<code>ndk-build -v</code>命令得到的GNU Make信息输出不同了，嘿嘿，我这伏笔埋的够深吧！其实，也可以使用下面的方式直接覆盖系统的环境变量</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NDK_HOST_AWK=&lt;path-to-awk&gt;
</span><span class='line'>NDK_HOST_ECHO=&lt;path-to-echo&gt;
</span><span class='line'>NDK_HOST_CMP=&lt;path-to-cmp&gt;</span></code></pre></td></tr></table></div></figure>


<p>
如果还是不行的话，参见<a href="http://stackoverflow.com/questions/8384213/android-ndk-revision-7-host-awk-tool-is-outdated-error">StackOverflow上的解答</a><br/>
在Windows先开发还有一个需要注意的是，如果是使用Cygwin对native code进行编译，那么需要在使用<code>ndk-build</code>之前调用<code>NDK_USE_CYGPATH=1</code>！(不过不用每次都使用)</p>

<p>下面是ndk-build命令的可用参数，比较常用的是 <code>ndk-build NDK_DEBUG=1</code> 或者 <code>ndk-build V=1</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  ndk-build                  --&gt; rebuild required machine code.
</span><span class='line'>  ndk-build clean            --&gt; clean all generated binaries.
</span><span class='line'>  ndk-build NDK_DEBUG=1      --&gt; generate debuggable native code.
</span><span class='line'>  ndk-build V=1              --&gt; launch build, displaying build commands.
</span><span class='line'>  ndk-build -B               --&gt; force a complete rebuild.
</span><span class='line'>  ndk-build -B V=1           --&gt; force a complete rebuild and display build
</span><span class='line'>                                 commands.
</span><span class='line'>  ndk-build NDK_LOG=1        --&gt; display internal NDK log messages
</span><span class='line'>                                 (used for debugging the NDK itself).
</span><span class='line'>  ndk-build NDK_DEBUG=1      --&gt; force a debuggable build (see below)
</span><span class='line'>  ndk-build NDK_DEBUG=0      --&gt; force a release build (see below)
</span><span class='line'>  ndk-build NDK_HOST_32BIT=1 --&gt; Always use toolchain in 32-bit (see below)
</span><span class='line'>  ndk-build NDK_APPLICATION_MK=&lt;file&gt;
</span><span class='line'>    --&gt; rebuild, using a specific Application.mk pointed to by
</span><span class='line'>        the NDK_APPLICATION_MK command-line variable.
</span><span class='line'>  ndk-build -C &lt;project&gt;     --&gt; build the native code for the project
</span><span class='line'>                                 path located at &lt;project&gt;. Useful if you
</span><span class='line'>                                 don't want to 'cd' to it in your terminal.</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p><strong>[6]NDK GDB，Import Module，Prebuilts，Standalone Toolchains以及和CPU相关的三个内容</strong>因为我没有涉及过，自己也不是很了解，所以此处暂时搁置了，以后如果用到以后补充。关于NDK调试环境的搭建可以参见<a href="http://qiang106.iteye.com/blog/1830416">这位作者的实践博文</a></p></li>
<li><p><strong>[7]<a href="http://blog.csdn.net/smfwuxiao/article/details/6612373">Tips and Tricks 建议和技巧</a></strong></p></li>
</ul>


<h4>那些曾经的头疼的问题</h4>

<ul>
<li><strong>[1]使用Android SDK Manager下载SDK时失败或者很慢</strong></li>
</ul>


<p>在Windows下修改hosts文件：<code>C:\Windows\System32\drivers\etc</code> <br/>
增加如下一行配置：<code>74.125.237.1 dl-ssl.google.com</code></p>

<ul>
<li><strong>[2]<code>Fatal signal 11 (SIGSEGV) at 0x00000004 (code=1), thread 23487 (mple)</code></strong></li>
</ul>


<p>错误原因是因为访问了非法访问的内存地址，具体的原因可能是访问了null对象或者数组，很有可能是Java层传给Native层的对象是null，导致Native层访问了非法访问的地址。<a href="http://stackoverflow.com/questions/14495242/android-fatal-signal-11-sigsegv-at-0x00000040-code-1-error?rq=1">参考网址1</a>   <a href="http://stackoverflow.com/questions/10787676/fatal-signal-11-sigsegv-at-0x00000000-code-1">参考网址2</a></p>

<ul>
<li><strong>[3]使用ADB命令向AVD中复制文件或文件夹时报错</strong></li>
</ul>


<p>默认情况下avd对应的目录是只读的，去掉只读就好了。<a href="http://www.crifan.com/ddms_import_file_error_transfer_error_read_only_file_system/">参考网址</a></p>

<ul>
<li><strong>[4]对android项目执行<code>add Native Support</code>报错</strong></li>
</ul>


<p>使用<code>add Native Support</code>时一定要记住项目不能有jni目录！如果有的话，那就只能先删除(或者备份重要内容)，然后再执行<code>add Native Support</code>。</p>

<ul>
<li><strong>[5]将String传递到Native层解析出现了乱码！</strong></li>
</ul>


<p>使用自定义的将jstring转换成char*的函数，内容如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static char* jstringToString(JNIEnv* env, jstring jstr) {
</span><span class='line'>    char* rtn = NULL;
</span><span class='line'>    jclass clsstring = env-&gt;FindClass("java/lang/String");
</span><span class='line'>    jstring strencode = env-&gt;NewStringUTF("utf-8"); //"gbk");//
</span><span class='line'>    jmethodID mid = env-&gt;GetMethodID(clsstring, "getBytes",
</span><span class='line'>            "(Ljava/lang/String;)[B");
</span><span class='line'>    jbyteArray barr = (jbyteArray) env-&gt;CallObjectMethod(jstr, mid, strencode);
</span><span class='line'>    jsize alen = env-&gt;GetArrayLength(barr);
</span><span class='line'>    jbyte* ba = env-&gt;GetByteArrayElements(barr, JNI_FALSE);
</span><span class='line'>    if (alen &gt; 0) {
</span><span class='line'>        rtn = (char*) malloc(alen + 1);
</span><span class='line'>        memcpy(rtn, ba, alen);
</span><span class='line'>        rtn[alen] = '\0';
</span><span class='line'>    }
</span><span class='line'>    env-&gt;ReleaseByteArrayElements(barr, ba, 0);
</span><span class='line'>    return rtn;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>[6]To be continued</li>
</ul>


<p>哦了，还不痛快? 请看下节<a href="http://hujiaweibujidao.github.io/blog/2013/11/18/android-ndk-and-opencv-development-3/">OpenCV 在 Android NDK 开发中的应用</a></p>

<p class='post-footer'>
                        Original link:<a href='http://hujiaweibujidao.github.io/blog/2013/11/18/android-ndk-and-opencv-development-2/'>http://hujiaweibujidao.github.io/blog/2013/11/18/android-ndk-and-opencv-development-2/</a><br/>Written by <a href='http://hujiaweibujidao.github.io'>hujiawei</a>&nbsp;Posted at <a href='http://hujiaweibujidao.github.io'>http://hujiaweibujidao.github.io</a><br/>Feel free to read or comment it, and if you want to copy it into your own site, please copy it with its Original Link showed above or you can see the license below for more details.<br />Thanks a lot. Hope you enjoy here! ^_^</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[android ndk and opencv development]]></title>
    <link href="http://hujiaweibujidao.github.io/blog/2013/11/18/android-ndk-and-opencv-developement/"/>
    <updated>2013-11-18T14:41:00+08:00</updated>
    <id>http://hujiaweibujidao.github.io/blog/2013/11/18/android-ndk-and-opencv-developement</id>
    <content type="html"><![CDATA[<h3>Android NDK 和 OpenCV 整合开发总结(1)</h3>

<p>在Samsung呆了段时间，还是学了不少东西的，主要做的任务是做<a href="http://developer.android.com/tools/sdk/ndk/index.html">Android NDK</a>开发，也涉及到了<a href="http://opencv.org/">OpenCV</a>的内容，正好自己最近在开发XFace，这些知识都用得上，所以，想写几篇文章总结下这些知识。该系列内容均为原创，摘录的部分我都会引用提示，尊重版权嘛，嘿嘿，我保证这里有不少内容是搜索不到的独家秘笈哟！很多都是我的开发经验，嘿嘿<br/>
该系列主要包括三大部分，分为下面三节来介绍，本节主要介绍第一部分</p>

<ul>
<li>Android NDK 和 OpenCV 整合开发的环境搭建以及人脸检测项目的运行测试</li>
<li><a href="http://hujiaweibujidao.github.io/blog/2013/11/18/android-ndk-and-opencv-development-2/">Android NDK 的核心内容和开发总结</a></li>
<li><a href="http://hujiaweibujidao.github.io/blog/2013/11/18/android-ndk-and-opencv-development-3/">OpenCV 在 Android NDK 开发中的应用</a></li>
</ul>


<p>[本文假设你是安装配置好了Java和Android SDK开发环境的，如果没有的话，可以看<a href="http://hujiaweiyinger.diandian.com/post/2013-10-30/setup_android_ndk_environment_and_solve_some_problems">我以前在点点博客写的这篇文章</a>，开发工具建议使用<a href="http://developer.android.com/sdk/installing/bundle.html">ADT</a>，它更加方便，包含了Android SDK 和 安装了 ADT Plugin 的 Eclipse，何乐而不为呢?]</p>

<h4>1. 下载Android NDK，解压即可</h4>

<p>下载地址： <a href="https://developer.android.com/tools/sdk/ndk/index.html">Android NDK</a> <br/>
<a href="http://download.csdn.net/download/xiao87651234/3991166">如果不能下载(公司内部可能就不让访问或者访问很慢)，可以查看这位作者的备用下载地址</a></p>

<h4>2. 下载安装OpenCV[2.6版本] (可选步骤)</h4>

<p>下载地址：<a href="http://opencv.org/">OpenCV首页</a>
<a href="http://docs.opencv.org/trunk/doc/tutorials/introduction/linux_install/linux_install.html#linux-installation">Linux平台的安装教程</a>  <a href="http://tilomitra.com/opencv-on-mac-osx/">Mac平台的安装教程</a></p>

<p>(1) 首先安装需要安装的工具和依赖包[详见前面的Linux安装教程]，Mac平台基本上只要安装CMake即可 <br/>
(2) 使用CMake编译opencv源码，然后通过make安装opencv[完成之后在<code>/usr/local/include</code>目录下便有了<code>opencv</code>和<code>opencv2</code>两个目录，在<code>/usr/local/lib</code>目录下有很多的<code>opencv</code>相关的动态库，例如<code>libopencv_core.dylib</code>等等]</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd &lt;path-to-opencv-source&gt;
</span><span class='line'>mkdir release
</span><span class='line'>cd release
</span><span class='line'>cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local .. 
</span><span class='line'>make
</span><span class='line'>sudo make install</span></code></pre></td></tr></table></div></figure>


<h4>3. 下载opencv_android_sdk 2.4.4版本，导入目录sdk/java作为Library Project (这个是OpenCV for Android)</h4>

<p>下载地址：<a href="http://sourceforge.net/projects/opencvlibrary/files/opencv-android/">opencv-android on sourceforge</a></p>

<p>[2.4.2相对比较旧了，有些新特性不支持，比如人脸识别(但是有人脸检测)，不推荐下载这个；2.4.6相对比较新，但是可能导入的Library Project一直报错，所以如果不能解决就考虑使用2.4.4，只要Library Project导入进来没问题就行]</p>

<p><a href="http://docs.opencv.org/doc/tutorials/introduction/android_binary_package/O4A_SDK.html#general-info">关于opencv for android的目录结构的详细解释</a></p>

<h4>4. 环境配置NDK和OpenCV环境</h4>

<ul>
<li>安装Android SDK(略过)和NDK，配置到系统PATH中</li>
</ul>


<p>[推荐配置，方便以后在终端执行adb和ndk-build等命令]</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>export ANDROID_SDK_ROOT=/Users/hujiawei/Android/android_sdk
</span><span class='line'>export PATH=${PATH}:${ANDROID_SDK_ROOT}/platform-tools:${ANDROID_SDK_ROOT}/tools
</span><span class='line'>export ANDROID_NDK_ROOT=/Users/hujiawei/Android/android_ndk
</span><span class='line'>export PATH=${PATH}:${ANDROID_NDK_ROOT}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>使用<code>ndk-build -v</code>测试配置</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>GNU Make 3.81
</span><span class='line'>Copyright (C) 2006  Free Software Foundation, Inc.
</span><span class='line'>This is free software; see the source for copying conditions.
</span><span class='line'>There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A
</span><span class='line'>PARTICULAR PURPOSE.
</span><span class='line'>This program built for i386-apple-darwin10.8.0</span></code></pre></td></tr></table></div></figure>


<p>如果是在Windows下，并且安装了Cygwin的话，输出就略有不同，它使用的不是系统内置的GNU Make</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ndk-build -v
</span><span class='line'>GNU Make 3.82.90
</span><span class='line'>Built for i686-pc-cygwin
</span><span class='line'>Copyright (C) 2010  Free Software Foundation, Inc.
</span><span class='line'>License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
</span><span class='line'>This is free software: you are free to change and redistribute it.
</span><span class='line'>There is NO WARRANTY, to the extent permitted by law.</span></code></pre></td></tr></table></div></figure>


<ul>
<li>在Eclipse(Android Development Tool)的设置中，在 C/C++ &ndash;> Build &ndash;> Environment 中添加下面两个配置 [添加这两项配置是为了后面进行各项关于路径配置的方便]</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NDKROOT = /Users/hujiawei/Android/android_ndk
</span><span class='line'>OPENCVROOT = /Users/hujiawei/Android/opencv_sdk</span></code></pre></td></tr></table></div></figure>


<h4>5. 运行OpenCV for Android中的Sample项目FaceDetection</h4>

<ul>
<li><p>导入OpenCV for Android中的<code>Library Project</code> &ndash; <code>OpenCV Library - 2.4.4</code></p></li>
<li><p>修改<code>Library Project</code>，改为前面导入到workspace中的<code>Library Project</code></p></li>
</ul>


<p>[原有的配置默认该项目和<code>Library Project</code>是在同一个目录下，所以如果你以前接触过的话，会发现很多文章都是告诉你要把<code>Library Project</code>拷贝到和当前项目同一个目录下，其实是完全没有必要的！]</p>

<ul>
<li>修改<code>C/C++ Build</code>，将<code>Build Command</code>改成： <code>${NDKROOT}/ndk-build</code></li>
</ul>


<p>[Windows平台则不要删除末尾的<code>.cmd</code>，Linux和Mac平台则需要删掉<code>.cmd</code>]</p>

<ul>
<li>修改<code>C/C++ General</code>，将<code>Paths and Symbols</code>中的<code>GNU C</code>和<code>GNU C++</code>配置的最后一个路径修改成 <code>${OPENCVROOT}/sdk/native/jni/include</code> (这个路径保存的是opencv的native code头文件)</li>
</ul>


<p>[建议将这个配置导出到文件中，方便以后做类似项目时可以快速进行配置]</p>

<ul>
<li>修改jni目录下的<code>Android.mk</code>，将<code>include OpenCV.mk</code>这行改成：<code>include${OPENCVROOT}/sdk/native/jni/OpenCV.mk</code></li>
</ul>


<p>[原有的配置是默认OpenCV的sdk文件夹和包含项目根目录的文件夹是同一个目录下]</p>

<ul>
<li><p>经过上面的配置之后，FaceDetection项目便没有问题了，打开jni目录下的cpp和h文件也不会报错了，当然，手机必须安装OpenCV Manager才能成功运行FaceDetection</p></li>
<li><p>运行人眼检测的示例程序</p></li>
</ul>


<p>项目来源：<a href="http://romanhosek.cz/android-eye-detection-and-tracking-with-opencv/">http://romanhosek.cz/android-eye-detection-and-tracking-with-opencv/</a><br/>
该作者根据原有的人脸检测做了一个人眼检测，博文最后附有<a href="http://romanhosek.cz/?wpdmact=process&amp;did=MS5ob3RsaW5r">下载地址</a>，我的<a href="https://github.com/yinger090807/XFace">Github</a>上已经有了一份备份，配置方式和Face Detection一样，至于人脸检测和人眼检测的算法我以后会有相关文章进行介绍，暂且期待下吧，嘿嘿<br/>
[如果配置完了之后提示一个<code>app_platform</code>的警告的话，可以在<code>Application.mk</code>文件中添加 <code>APP_PLATFORM := android-8</code>]<br/>
仔细理解上面的配置和操作，如果还有啥问题或者不清楚的可以查看<a href="http://docs.opencv.org/doc/tutorials/introduction/android_binary_package/O4A_SDK.html">OpenCV官方这篇入门文档:Manual OpenCV4Android SDK setup</a></p>

<p>两个项目运行结果：[帮主，对不住啦，谁叫您长得这么帅呢！我的脸识别不了，只能用您老的啦！] <br/>
<img class="left" src="http://hujiaweibujidao.github.io/images/201311/face_detection.png" width="350" height="500" title="face detection" >
<img class="right" src="http://hujiaweibujidao.github.io/images/201311/eye_detection.png" width="350" height="500" title="eye detection" ></p>

<p>OK！本节结束！如果觉得好，请看下节<a href="http://hujiaweibujidao.github.io/blog/2013/11/18/android-ndk-and-opencv-development-2/">Android NDK 的核心内容和开发总结</a>！</p>

<p class='post-footer'>
                        Original link:<a href='http://hujiaweibujidao.github.io/blog/2013/11/18/android-ndk-and-opencv-developement/'>http://hujiaweibujidao.github.io/blog/2013/11/18/android-ndk-and-opencv-developement/</a><br/>Written by <a href='http://hujiaweibujidao.github.io'>hujiawei</a>&nbsp;Posted at <a href='http://hujiaweibujidao.github.io'>http://hujiaweibujidao.github.io</a><br/>Feel free to read or comment it, and if you want to copy it into your own site, please copy it with its Original Link showed above or you can see the license below for more details.<br />Thanks a lot. Hope you enjoy here! ^_^</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[make your octopress easy]]></title>
    <link href="http://hujiaweibujidao.github.io/blog/2013/11/18/make-your-octopress-easy/"/>
    <updated>2013-11-18T13:11:00+08:00</updated>
    <id>http://hujiaweibujidao.github.io/blog/2013/11/18/make-your-octopress-easy</id>
    <content type="html"><![CDATA[<p>刚刚来到Octopress的世界，我的新鲜感依旧还在，呵呵，上午写了几个<code>shell</code>脚本让你在Octopress上写博客更加轻松些，至少让我轻松了很多，哈哈哈。</p>

<p>我特别头疼于类似新建文章<code>new_post["postname"]</code>这些个命令，那个下划线可能会记成短破折线，时间长了我可能就不记得这个命令了，当然，如果你是ruby开发者那就肯定不会这样啦，我这年龄大了，记忆力不行了，很难记住那么多的命令啦，还有就是我希望只要打开Terminal就可以调用这些命令，而不用每次切换目录，而且每次我新建了一个文章之后，Mou能够直接启动并打开这个新建的文章让我编辑，想想，这个世界是不是美好多了？哈哈哈</p>

<p>操作步骤：</p>

<h4>[1]新建环境变量<code>OCTOPRESS_HOME</code>，它是你的octopress的根目录，并添加到<code>PATH</code>中</h4>

<p>[下面是我在Mac上的操作，其他系统自行修改]</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo nano ~/.bash_profile  #打开并修改.bash_profile文件，下面两行是在该文件中的修改
</span><span class='line'>export OCTOPRESS_HOME=/Users/hujiawei/git/octopress  #添加OCTOPRESS_HOME变量
</span><span class='line'>export PATH=${PATH}:${OCTOPRESS_HOME}  #添加到path中
</span><span class='line'>source ~/.bash_profile  
</span><span class='line'>echo $OCTOPRESS_HOME  #验证是否变量存在
</span><span class='line'>echo $PATH  #验证path是否设置成功</span></code></pre></td></tr></table></div></figure>


<h4>[2]编写几个<code>shell</code>脚本，放在<code>OCTOPRESS_HOME</code>目录下，作用分别如下：</h4>

<ul>
<li>gen：等价于<code>rake generate</code>操作</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#! /bin/bash
</span><span class='line'>path=$OCTOPRESS_HOME
</span><span class='line'>cd "$path"
</span><span class='line'>#pwd
</span><span class='line'>rake generate
</span><span class='line'>echo "generate ok"</span></code></pre></td></tr></table></div></figure>


<ul>
<li>dep：等价于<code>rake deploy</code>操作</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#! /bin/bash
</span><span class='line'>path=$OCTOPRESS_HOME
</span><span class='line'>cd "$path"
</span><span class='line'>#pwd
</span><span class='line'>rake generate
</span><span class='line'>rake deploy
</span><span class='line'>echo "generate and deploy ok"</span></code></pre></td></tr></table></div></figure>


<ul>
<li>pre：等价于<code>rake preview</code>操作</li>
</ul>


<p>[注意，这里我是在子线程中启动预览的，所以你按下了Ctrl+C会也不会把预览给终止了，是不是瞬间又感觉这个世界又美好了很多啊，哈哈]</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#! /bin/bash
</span><span class='line'>path=$OCTOPRESS_HOME
</span><span class='line'>cd "$path"
</span><span class='line'>#pwd
</span><span class='line'>#rake watch
</span><span class='line'>rake preview &
</span><span class='line'>#echo "watch and preview ok"</span></code></pre></td></tr></table></div></figure>


<ul>
<li>gmit：等价于<code>git add/commit/push</code>几个操作的组合</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#! /bin/bash
</span><span class='line'>if [ $# -ne 1 ]
</span><span class='line'>then
</span><span class='line'>    echo "Usage - gmit  message"
</span><span class='line'>    exit 1
</span><span class='line'>fi
</span><span class='line'>path=$OCTOPRESS_HOME
</span><span class='line'>cd "$path"
</span><span class='line'>#pwd
</span><span class='line'>git add .
</span><span class='line'>git commit -m "$1"
</span><span class='line'>git push origin source
</span><span class='line'>echo "git commit and push ok"</span></code></pre></td></tr></table></div></figure>


<ul>
<li>newpost：等价于<code>new_post[""] + open Mou</code>操作组合</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#! /bin/bash
</span><span class='line'>if [ $# -ne 1 ]
</span><span class='line'>then
</span><span class='line'>    echo "Usage -newpost  postname"
</span><span class='line'>    exit 1
</span><span class='line'>fi
</span><span class='line'>path=$OCTOPRESS_HOME
</span><span class='line'>cd "$path"
</span><span class='line'>#pwd
</span><span class='line'>filepath=`rake new_post["$1"]`
</span><span class='line'>#echo "$filepath"
</span><span class='line'>#Creating new post: source/_posts/2013-11-18-test5.markdown
</span><span class='line'>OLD_IFS="$IFS"
</span><span class='line'>IFS=" "
</span><span class='line'>arr=($filepath)
</span><span class='line'>filepath=${arr[3]}
</span><span class='line'>IFS="$OLD_IFS"
</span><span class='line'>postpath="$path/$filepath"
</span><span class='line'>#echo "$postpath"
</span><span class='line'>#open Mou with the file
</span><span class='line'>open -a Mou $postpath</span></code></pre></td></tr></table></div></figure>


<ul>
<li>newpage：等价于<code>new_page[""] + open Mou</code>操作组合</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#! /bin/bash
</span><span class='line'>if [ $# -ne 1 ]
</span><span class='line'>then
</span><span class='line'>    echo "Usage - newpage  pagename"
</span><span class='line'>    exit 1
</span><span class='line'>fi
</span><span class='line'>path=$OCTOPRESS_HOME
</span><span class='line'>cd "$path"
</span><span class='line'>echo "$path"
</span><span class='line'>filepath=`rake new_page["$1"]`
</span><span class='line'>echo "$filepath"
</span><span class='line'>#Creating new page: source/projects/index.markdown
</span><span class='line'>OLD_IFS="$IFS"
</span><span class='line'>IFS=" "
</span><span class='line'>arr=($filepath)
</span><span class='line'>filepath=${arr[3]}
</span><span class='line'>IFS="$OLD_IFS"
</span><span class='line'>postpath="$path/$filepath"
</span><span class='line'>echo "$postpath"
</span><span class='line'>#open Mou with the file
</span><span class='line'>open -a Mou $postpath</span></code></pre></td></tr></table></div></figure>


<h4>[3]使用<code>chmod 777 xxx</code>修改脚本的权限，测试执行下</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd $OCTOPRESS_HOME
</span><span class='line'>chmod 777 gen  #其他文件类似
</span><span class='line'>chmod 777 pre
</span><span class='line'>chmod 777 dep
</span><span class='line'>chmod 777 gmit
</span><span class='line'>chmod 777 newpost
</span><span class='line'>chmod 777 newpage
</span><span class='line'>gen
</span><span class='line'>newpost "test new post" #当这条命令完成生成了Markdown文件之后，你会发现Mou闪电般的将文件打开了，等着你输入呢！</span></code></pre></td></tr></table></div></figure>


<p>OK！Enjoy the world of Octopress！</p>

<p class='post-footer'>
                        Original link:<a href='http://hujiaweibujidao.github.io/blog/2013/11/18/make-your-octopress-easy/'>http://hujiaweibujidao.github.io/blog/2013/11/18/make-your-octopress-easy/</a><br/>Written by <a href='http://hujiaweibujidao.github.io'>hujiawei</a>&nbsp;Posted at <a href='http://hujiaweibujidao.github.io'>http://hujiaweibujidao.github.io</a><br/>Feel free to read or comment it, and if you want to copy it into your own site, please copy it with its Original Link showed above or you can see the license below for more details.<br />Thanks a lot. Hope you enjoy here! ^_^</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hello Octopress]]></title>
    <link href="http://hujiaweibujidao.github.io/blog/2013/11/17/hello-octopress/"/>
    <updated>2013-11-17T17:03:00+08:00</updated>
    <id>http://hujiaweibujidao.github.io/blog/2013/11/17/hello-octopress</id>
    <content type="html"><![CDATA[<p>Hello world! Hello Octopress!</p>

<p>曾经因为很多问题的答案都在<a href="http://www.cnblogs.com"><strong>博客园</strong></a>上，于是我在那里驻扎了，但是，它的广告让我不能忍！</p>

<p>后来因为<a href="http://www.diandian.com"><strong>点点博客</strong></a>的小清新我瞬间就爱上了它，于是我搬家了，但是，它的冷清让我想要离开！</p>

<p>再后来<a href="http://wordpress.com"><strong>Wordpress</strong></a>进入了我的眼帘，苦于没有host，只好在BAE上安营，但是，它的龟速简直让我发指！</p>

<p>最后我终于走进了我一直忽视了的<a href="http://octopress.org/"><strong>Octopress</strong></a>，那一瞬间，我才发现，这才是我想要的！这才是我想要的博客！我可以自由的定义页面中的任何内容！</p>

<blockquote><p>A blogging framework for hackers.         &mdash; Parker Moore</p></blockquote>

<p>今天从早上开始一直到晚上终于把Octopress搭建和配置好了，好开心啊有木有！</p>

<p>下面介绍安装过程：[不是很轻松，但是也不会很难哟！]</p>

<p>安装步骤如下：</p>

<p>*<a href="http://octopress.org/docs/setup/rbenv/">安装rbenv和ruby</a></p>

<p>请确保ruby版本是1.9.3以上！我试过，如果版本低的话会出错，但是如果版本很高的话也有可能出错(我试过1.9.3-p2xx)，建议就安装1.9.3-p0，也可以使用<a href="http://octopress.org/docs/setup/rvm/">rvm</a>来管理ruby版本，我两个都试过了，推荐使用rbenv。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>brew update
</span><span class='line'>brew install rbenv
</span><span class='line'>brew install ruby-build
</span><span class='line'>rbenv install 1.9.3-p0
</span><span class='line'>rbenv rehash
</span><span class='line'>rbenv global 1.9.3-p0  #建议增加这句修改系统全局的ruby版本
</span><span class='line'>ruby --version  #查看系统ruby版本</span></code></pre></td></tr></table></div></figure>


<p>[注：如果install 1.9.3-p0时报错，提示llvm不行，需要安装gcc时按照提示的命令执行即可：<code>brew tap homebrew/dupes ; brew install apple-gcc42</code>]</p>

<p>*<a href="http://octopress.org/docs/setup/">安装Octopress</a></p>

<p>这部分耗时会长一些，其中的octopress目录名称可以随便修改，例如myblog等，<code>gem list</code>命令可以查看已经安装好了的依赖包，<code>rake install</code>就类似<code>make install</code>进行安装(Octopress的主题)，一定要确保这里执行的命令都是正确执行了的，否则后面可能出错。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git clone git://github.com/imathis/octopress.git octopress
</span><span class='line'>cd octopress
</span><span class='line'>gem install bundler
</span><span class='line'>rbenv rehash    # If you use rbenv, rehash to be able to run the bundle command
</span><span class='line'>bundle install
</span><span class='line'>rake install</span></code></pre></td></tr></table></div></figure>


<p>*<a href="http://octopress.org/docs/deploying/github/">发布到Github上</a></p>

<p>以前个人博客是在位于<code>http://username.github.com</code>这个域名下，现在改成了<code>http://username.github.io</code>，所以大家可以看到两种不同域名下的博客。另外，<a href="https://help.github.com/categories/20/articles">Github Pages</a>分为两类，一类是个人或者组织的博客，另一类是项目的介绍博客，这里只介绍如果搭建不介绍后者，但是两者基本上相同。</p>

<p>首先新建repository，名称为<code>username.github.io</code>，其中<code>username</code>是你的github用户名，拷贝repository的SSH地址，类似<code>git@github.com:username/username.github.io.git</code>。然后执行下面代码&#8220;，它主要是进行以下操作(不难理解，我就不翻译了，原文看着舒坦，嘿嘿)：</p>

<ul>
<li>Ask for and store your Github Pages repository url.</li>
<li>Rename the remote pointing to imathis/octopress from &lsquo;origin&rsquo; to &lsquo;octopress&rsquo;</li>
<li>Add your Github Pages repository as the default origin remote.</li>
<li>Switch the active branch from master to source.</li>
<li>Configure your blog&rsquo;s url according to your repository.</li>
<li>Setup a master branch in the _deploy directory for deployment.</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake setup_github_pages #按照提示输入你的repository的SSH地址
</span><span class='line'>rake generate #生成静态网页，记住，每次有修改之后都需要执行一次或者多次才能查看新的预览！
</span><span class='line'>rake deploy  #发布网页，这里会提交代码到github
</span><span class='line'>rake preview #本地预览，默认端口是4000，可以修改
</span><span class='line'>git add .
</span><span class='line'>git commit -m 'your message'
</span><span class='line'>git push origin source  #一定记着要提交source下的内容</span></code></pre></td></tr></table></div></figure>


<p>需要注意的是，如果你是Github新手的话，可能遇到<code>Permission denied (publickey)</code>，这说明你还没有添加key给当前用户，解决方案请参考<a href="https://help.github.com/articles/error-permission-denied-publickey">Error:Permission denied (publickey)</a>和<a href="https://help.github.com/articles/generating-ssh-keys">Github help:Generating SSH Keys</a>来为当前用户创建publickey，</p>

<p>通过命令<code>ssh -T billy.anyteen@github.com</code>可以查看Github是否识别当前用户，如果不能识别会返回<code>Permission denied (publickey)</code>，否则便是<code>Hi username! You've successfully authenticated, but GitHub does not # provide shell access.</code></p>

<p>另外，极力推荐一个<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">Git的简明教程</a>，作者廖雪峰是一位资深的开发者，著有畅销书籍《Spring 2.0核心技术与最佳实践》等，最近又推出了Python简明教程，非常实用！</p>

<p>*大功告成！</p>

<p>① 大致介绍下Octopress的目录结构(摘自<a href="http://www.dongwm.com/archives/qian-yi-octpressyi-ji-zi-ding-yi/">小明明s à domicile</a>)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>├─ config.rb  #指定额外的compass插件
</span><span class='line'>├─ config.ru  
</span><span class='line'>├─ Rakefile   #rake的配置文件,类似于makefile,这个我修改了一些内容
</span><span class='line'>├─ Gemfile    #bundle要下载需要的gem依赖关系的指定文件
</span><span class='line'>├─ Gemfile.lock  #这些gem依赖的对应关系,比如A的x本依赖于B的y版本,我也修改了
</span><span class='line'>├─ _config.yml  #站点的配置文件
</span><span class='line'>├─ public/  #在静态编译完成后的目录,网站只需要这个目录下的文件树
</span><span class='line'>├─ _deploy/  #deploy时候生成的缓存文件夹,和public目录一样
</span><span class='line'>├─ sass/  #css文件的源文件,过程中会compass成css
</span><span class='line'>├─ plugins/  #放置自带以及第三方插件的目录,ruby程序
</span><span class='line'>│  └── xxx.rb
</span><span class='line'>└─ source/  #这个是站点的源文件目录,public目录就是根据这个目录下数据生成的
</span><span class='line'>   └─ _includes/
</span><span class='line'>      └─ custom/  #自定义的模板目录,被相应上级html include
</span><span class='line'>         └─ asides/  #边栏模板自定义模板目录
</span><span class='line'>      └─ asides/  #边栏模板目录
</span><span class='line'>      └─ post/  #文章页面相应模板目录
</span><span class='line'>   └─ _layouts/  #默认网站html相关文件,最底层
</span><span class='line'>   └─ _posts/  #新增以及从其它程序迁移过来的数据都存在这里
</span><span class='line'>   └─ stylesheets/ #css文件目录
</span><span class='line'>   └─ javascripts/  #js文件目录</span></code></pre></td></tr></table></div></figure>


<p>② 一些配置内容</p>

<p><a href="http://octopress.org/docs/configuring/">关于如何配置Octopress</a></p>

<p><a href="http://octopress.org/docs/blogging/">关于如何创建新的page或者post以及本地预览</a></p>

<p><a href="http://octopress.org/docs/theme/">关于如何修改主题和默认的样式</a></p>

<p><a href="http://opthemes.com/">Octopress支持的第三方主题下载和预览网站</a></p>

<p><a href="http://812lcl.github.io/blog/2013/10/26/octopressce-bian-lan-ji-ping-lun-xi-tong-ding-zhi/">关于侧边栏和主题的定制，添加新浪微博，多说评论，分类标签云等等</a></p>

<p>[注意，使用多说的话，shortname不是你的个人资料中的名称，而是新建的站点给定的！另外，对于<a href="http://havee.me/internet/2013-02/add-duoshuo-commemt-system-into-octopress.html">这里</a>提到的升级问题，可以干脆直接删除data-title]</p>

<p>最有用的资料总能在这里找到：<a href="http://octopress.org/docs/">Octopress的官方文档</a></p>

<p>③ 关于<a href="http://jekyllrb.com/docs/home/">Jekyll</a></p>

<p>Octopress是基于Jekyll的，所以对Jekyll有一定的了解是很有必要的，Jekyll主页中记录了Jekyll的方方面面，最好是了解下Directory Structure，Configuration，Writing Posts，Creating Pages等等内容，这对后面的Octopress的使用会有很大帮助的。</p>

<p>④ 关于本地编写博客</p>

<p>对于前台开发，我心中向来只有一个工具<a href="www.aptana.com">Aptana</a>！所以，我把整个octopress目录作为aptana中的一个项目进行管理，至少有两个好处：</p>

<ul>
<li>aptana的git插件可以让我很清楚的看到我又改动了哪些文件中的哪些内容</li>
<li>aptana的语法高亮功能让我可以在众多的前台代码中游刃有余，对于简单的html可以直接在aptana中预览</li>
</ul>


<p>对于Markdown编辑器，我觉得Mou可能不是最好的，但是，它是很精巧的！我简直爱不释手，希望之后能够在我的博客中实现数学公式的编辑，这样会很方便，哈哈</p>

<p>哦了，今天就到这里啦！哈哈哈</p>

<p>晚安，Octopress！</p>

<p class='post-footer'>
                        Original link:<a href='http://hujiaweibujidao.github.io/blog/2013/11/17/hello-octopress/'>http://hujiaweibujidao.github.io/blog/2013/11/17/hello-octopress/</a><br/>Written by <a href='http://hujiaweibujidao.github.io'>hujiawei</a>&nbsp;Posted at <a href='http://hujiaweibujidao.github.io'>http://hujiaweibujidao.github.io</a><br/>Feel free to read or comment it, and if you want to copy it into your own site, please copy it with its Original Link showed above or you can see the license below for more details.<br />Thanks a lot. Hope you enjoy here! ^_^</p>

]]></content>
  </entry>
  
</feed>
